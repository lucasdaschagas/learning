/*
 * Copyright 1997-2011 Day Management AG
 * Barfuesserplatz 6, 4001 Basel, Switzerland
 * All Rights Reserved.
 *
 * This software is the confidential and proprietary information of
 * Day Management AG, ("Confidential Information"). You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Day.
 */

/**
 * @class CQ.wcm.EditRollover
 * @extends CQ.Ext.Component
 * <p>The EditRollover lets the user edit content through double-click and
 * provides more editing actions through a context menu. The editable area
 * is indicated with a frame when the mouse is rolling over the content.</p>
 * <p>Although not listed here, EditRollover has all the members of
 * <b>{@link CQ.wcm.EditBase}</b>.</p>
 * @constructor
 * Creates a new EditRollover.
 * @param {Object} config The config object
 */
CQ.wcm.EditRollover = CQ.Ext.extend(CQ.Ext.Component, {

    /**
     * @cfg {Boolean} isEmpty
     * True if the component is empty, ie it does not contain any content (default is false).
     */
    isEmpty: false,

    /**
     * @property {Boolean} selected (read-only)
     * True to the component selected (defaults is false).
     */
    selected: false,

    /**
     * @cfg {String} editText
     * The text to display by the edit action.
     */
    editText: null,

    /**
     * @cfg {String} deleteText
     * The text to display by the delete action.
     */
    deleteText: null,

    /**
     * @cfg {String} insertText
     * The text to display by the insert action.
     */
    insertText: null,

    /**
     * @cfg {String} emptyText
     * The text to display when edit rollover is empty or insert-only.
     */
    emptyText: null,

    /**
     * @cfg {Boolean} enableInsertOnlyText
     * Set to false to remove text when edit rollover is insert-only or empty (default is true).
     */
    enableInsertOnlyText: true,

    /**
     * @cfg {Boolean} enableHighLight
     * <b>Deprecated: Use {@link #enableHighlight} instead</b>
     * Set to false to disable highlight (default is true).
     * @deprecated Use {@link #enableHighlight} instead
     */
    enableHighLight: null,

    /**
     * @cfg {Boolean} enableHighlight
     * Set to false to disable highlight (default is true).
     * @since 5.3
     */
    enableHighlight: null,

    /**
     * @cfg {Boolean} enableContextMenu
     * Set to false to disable context menu (default is true).
     */
    enableContextMenu: null,

    /**
     * @cfg {Boolean} enableEditOnDblClick
     * Set to false to disable editing on double-click (default is true).
     */
    enableEditOnDblClick: null,

    /**
     * @cfg {Boolean} selectable
     * Set to false to not allow the component to be selected (default is true).
     */
    selectable: false,

    /**
     * @cfg {Boolean} animateShow
     * Set to true to animate when component is showing (default is true).
     */
    animateShow: null,

    /**
     * @cfg {Boolean} animateHide
     * True to animate when component is hiding (default is false).
     */
    animateHide: null,

    /**
     * @cfg {Boolean} inactiveMode
     * True to disable all user interaction on component (default is false).
     * Equivalent to: <pre><code><ul>
     * <li>isDropTarget = false</li>
     * <li>orderable = false</li>
     * <li>enableHighlight = false</li>
     * <li>enableContextMenu = false</li>
     * <li>enableEditOnDblClick = false</li>
     * <li>selectable = false</li>
     * </ul></code></pre>
     */
    inactiveMode: null,

    /**
     * Highlight object dedicated to this edit rollover.
     * @private
     * @type CQ.wcm.EditRollover.Highlight
     */
    highlight: null,

    /**
     * Placeholder added into element to contain emptyComponent or empty space to set a default minimum height.
     * @private
     * @type CQ.Ext.Element
     */
    elementPlaceholder: null,

    /**
     * Empty component added to display insert message.
     * @private
     * @type CQ.Ext.Element
     */
    emptyComponent: null,

    /**
     * The coordinates of the context menu (required for annotations).
     * @type Array
     * @private
     */
    contextMenuXY: null,

    /**
     * Defines if component is ready (has been built) or not
     * @private
     * @since 5.5
     */
    ready: false,

    constructor: function(config) {

        //enableHighLight: deprecated as of 5.3
        if( config["enableHighLight"]) {
            config["enableHighlight"] = config["enableHighLight"];
            delete config["enableHighLight"];
        }

        this.dragZoneClass = CQ.wcm.EditRollover.DragZone;
        this.dropTargetClass = CQ.wcm.EditRollover.DropTarget;

        this.constructorStart(config);

        this.applyConfigDefaults(config, {
            "renderTo":CQ.Util.ROOT_ID,
            "element":null,
            "path":"",
            "actions": CQ.wcm.EditBase.EDITANNOTATE,
            "childConfig": {
                "actions": CQ.wcm.EditBase.EDITANNOTATECOPYMOVEDELETEINSERT
            },
            "container":"menu",
            "ctrlDef":"menuitem",
            "menu": {
            },
            "menuitem": {
            },
            "listeners": {
                // note: refreshing after copy is handled in "afterinsert"
                "afteredit" : this.refreshSelf,
                "afterdelete" : this.refreshSelf,
                "afterinsert" : this.refreshCreated,
                "aftermove" : this.refreshSelfMoved
            },
            "stateful": false,
            "inlineEditing": CQ.wcm.EditBase.INLINE_MODE_AUTO,
            "targetMode": CQ.wcm.EditBase.TARGET_MODE_GHOST,
            "orderable": true,
            "enableInsertOnlyText": true,
            "isDropTarget": true,
            "enableHighlight": true,
            "enableContextMenu": true,
            "enableEditOnDblClick": true,
            "selectable": true,
            "animateShow": true,
            "animateHide": false,
            "isContained": false,
            "containerClass": "section"
        });

        if (config.inactiveMode) {
            config.isDropTarget = false;
            config.orderable = false;
            config.enableHighlight = false;
            config.enableContextMenu = false;
            config.enableEditOnDblClick = false;
            config.selectable = false;
        }

        // hack to circumvent NPE, rollovers never have a style
        delete config.style;

        CQ.wcm.EditRollover.superclass.constructor.call(this, config);
        this.el = this.element = CQ.Ext.get(this.element);
        this.el.addClass(this.getClsPath("cq-element"));


        //in case of an iframe element height is not correct
        var iframe = this.element.first("iframe");
        if (iframe) {
            this.element.setHeight(this.element.getHeight() + iframe.getHeight());
        }

        // HACK:
        // it it's a target component and it's statically included
        // we are not allowed to delete the children
        // so we are hacking another child config into this.
        if (config.params
                && config.params["./sling:resourceType"] === "cq/personalization/components/target"
                && typeof this.getParent() === "undefined") {
            config.childConfig["actions"] = CQ.wcm.EditBase.EDITANNOTATECOPYMOVEINSERT
        }

        this.buildElement.defer(16, this);

        this.constructorEnd(config);
    },

    // overriding CQ.Ext.Component#initComponent
    initComponent: function() {
        CQ.wcm.EditRollover.superclass.initComponent.call(this);

        this.addEvents(
            /**
             * Fires before the content is edited.
             * Return false from an event handler to cancel editing.
             * @event beforeedit
             * @param {CQ.wcm.EditRollover} this
             * @since 5.4
             */
            CQ.wcm.EditBase.EVENT_BEFORE_EDIT,

            /**
             * Fires when the content was edited.
             * @event afteredit
             * @param {CQ.wcm.EditRollover} this
             */
            CQ.wcm.EditBase.EVENT_AFTER_EDIT,

            /**
             * Fires before the edit component is deleted.
             * Return false from an event handler to cancel deletion.
             * @event beforedelete
             * @param {CQ.wcm.EditRollover} this
             * @since 5.4
             */
            CQ.wcm.EditBase.EVENT_BEFORE_DELETE,

            /**
             * Fires when the edit component was deleted.
             * @event afterdelete
             * @param {CQ.wcm.EditRollover} this (since 5.4)
             */
            CQ.wcm.EditBase.EVENT_AFTER_DELETE,

            /**
             * Fires when an edit component was inserted. The inserted component
             * can be accessed by <code>this</code>.
             * @event afterinsert
             * @param {String} contentPath Inserted component content path
             * @param {Object} definition Inserted component definition
             */
            CQ.wcm.EditBase.EVENT_AFTER_INSERT,

            /**
             * Fires before the edit component is moved.
             * Return false from an event handler to cancel moving.
             * @event beforemove
             * @param {CQ.wcm.EditRollover} this
             * @param {String} path Path of the component before which this component
             *                      will be inserted to
             * @since 5.4
             */
            CQ.wcm.EditBase.EVENT_BEFORE_MOVE,

            /**
             * Fires when the edit component was moved.
             * @event aftermove
             * @param {CQ.wcm.EditRollover} this
             * @param {String} path Path of the component before which this component
             *                      has been inserted to
             */
            CQ.wcm.EditBase.EVENT_AFTER_MOVE,

            /**
             * Fires before the edit component is copied.
             * Return false from an event handler to cancel copying.
             * @event beforecopy
             * @param {CQ.wcm.EditRollover} this (the component to be copied)
             * @param {String} path Path of the component before which the new component
             *                      will be inserted to
             * @since 5.4
             */
            CQ.wcm.EditBase.EVENT_BEFORE_COPY,

            /**
             * Fires after the edit component was copied.
             * @event aftercopy
             * @param {CQ.wcm.EditRollover} this (the component to be copied)
             * @param {String} path Path of the component before which the new component
             *                      has been inserted to
             * @param {String} newPath Path of the new, copied component
             * @since 5.4
             */
            CQ.wcm.EditBase.EVENT_AFTER_COPY,

            /**
             * Fires before a component is inserted into the current edit component.
             * Return false from an event handler to cancel insertion.
             * @event beforechildinsert
             * @param {CQ.wcm.EditRollover} this
             * @param {String} path The path of the inserted component
             * @since 5.4
             */
            CQ.wcm.EditBase.EVENT_BEFORE_CHILD_INSERT,

            /**
             * Fires when a component was inserted into the current edit component.
             * @event afterchildinsert
             * @param {CQ.wcm.EditRollover} this (since 5.4)
             * @param {String} path The path of the inserted component (since 5.4)
             */
            CQ.wcm.EditBase.EVENT_AFTER_CHILD_INSERT,

            /**
             * Fires when the current edit component is ready (rendered and events attached).
             * @event ready
             * @param {CQ.wcm.EditBar} this
             * @since 5.5
             */
            CQ.wcm.EditBase.EVENT_READY,

            /**
             * Fires when the highlight is shown.
             * @event showhighlight
             * @param {CQ.wcm.EditBar} this
             * @since 5.5
             */
            CQ.wcm.EditRollover.EVENT_SHOW_HIGHTLIGHT,

            /**
             * Fires when the highlight is hidden.
             * @event hidehighlight
             * @param {CQ.wcm.EditBar} this
             * @since 5.5
             */
            CQ.wcm.EditRollover.EVENT_HIDE_HIGHTLIGHT

        );

        this.on("render", function() {
            CQ.Timing.stamp("Start rendering rollover", "EditRollover#onRender", true);
            if (!this.isActionDelete() && !this.isActionCopyMove()) {
                // neither delete nor copy/move action: assume that editable is not draggable
                // (fixed paragraph (e.g. page title) and drop zone for new paragraphs)
                this.orderable = false;
            }

            this.highlight = new CQ.wcm.EditRollover.Highlight();
            this.inplaceEditHighlight = new CQ.wcm.EditRollover.Highlight();
            this.inplaceEditHighlight.addClass("cq-editrollover-inplaceediting");

            if (this[CQ.wcm.msm.MSM.PARAM_LIVE_RELATIONSHIP] != null) {
                if (this.enableHighlight && (this.isActionEdit() || this.isActionDelete())) {
                    this.handleLiveRelationship();
                }
            }
            if (this.isActionInsertOnly()) {
                var parent = this.getParent();
                if (parent && parent.handleLiveRelationship) {
                    parent.handleLiveRelationship(true);
                }
            }

            var selection = CQ.WCM.getSelection();
            selection.on("add", this.handleSelect, this);
            selection.on("remove", this.handleDeselect, this);
            selection.on("clear", this.handleSelectionClear, this);

            CQ.Timing.stamp("Completed rendering rollover", "EditRollover#onRender");
        });

        this.initComponentEnd();
    },

    /**
     * Builds an empty box if element is empty or too small and sets up listeners on the element.
     * @private
     */
    buildElement: function() {
        //actions on edit rollover element

        this.clearListeners();

        //actions on empty placeholder
        if (this.emptyComponent) {
            //this.emptyComponent.destroy();
            this.emptyComponent.hide();
            //this.emptyComponent = null;
        }

        if (this.elementPlaceholder) {
            //this.elementPlaceholder.remove();
            this.elementPlaceholder.hide();
            //this.elementPlaceholder = null;
        }

        if (this.placeholder) {
            //this.placeholder.remove();
            this.placeholder.hide();
            //this.placeholder = null;
        }

        if (!this.hidden && !this.disabled) {
            var html = "<div class=\"" + this.getClsPath("cq-placeholder") + "\"></div>";
            var defaultStyles = CQ.DOM.getBlockDefaultStyles();
            var h, pStyles;

            var elementWidth = this.element.getWidth();

            this.element.setVisibilityMode(CQ.Ext.Element.DISPLAY);
            if (this.isContained)
                this.element.parent().setVisibilityMode(CQ.Ext.Element.DISPLAY);
            this.elementHidden = false;

            if (!this.placeholder) {
              if (this.element.dom && (this.element.dom.tagName == "TBODY"
                  || this.element.dom.tagName == "THEAD"
                  || this.element.dom.tagName == "TFOOT"
                  || this.element.dom.tagName == "TR"
                  || this.element.dom.tagName == "TD")) { // related to bug#40069
                var pt = this.element.parent("TABLE");
                this.placeholder = CQ.Ext.DomHelper.insertBefore(pt, html, true);
              } else {
                this.placeholder = CQ.Ext.DomHelper.insertBefore(this.element, html, true);
              }
            }

            if( CQ.Ext.isIE6 ) {
                pStyles = CQ.Util.applyDefaults({
                    "width": elementWidth + "px",
                    "height": "0px",
                    "line-height": "0px",
                    "font-size": "0px"
                }, defaultStyles);
            } else {
                pStyles = CQ.Util.applyDefaults({
                    "width": elementWidth + "px",
                    "height": "0"
                }, defaultStyles);
            }
            this.placeholder.setStyle(pStyles);
            //to be properly hidden, placeholder must have a DISPLAY visibility mode.
            this.placeholder.setVisibilityMode(CQ.Ext.Element.DISPLAY);

            this.placeholder.show();

            var isTargetParsys = this.getTargetParent()
                                && this.getParent()
                                && this.getParent().isContainer
                                && (this.getResourceType() == CQ.wcm.EditBase.PARSYS_NEW);

            if (this.isActionInsertOnly() || this.isEmpty || isTargetParsys) {

                h = (this.enableInsertOnlyText ? CQ.themes.wcm.EditRollover.ELEMENT_MIN_HEIGHT : CQ.themes.wcm.EditRollover.ELEMENT_NO_TEXT_MIN_HEIGHT);

                if (!this.elementPlaceholder)
                    this.elementPlaceholder = this.element.insertHtml("beforeEnd", html, true);

                pStyles = CQ.Util.applyDefaults({
                    "height": h + "px",
                    "width": elementWidth + "px"
                }, defaultStyles);
                this.elementPlaceholder.setStyle(pStyles);

                //to be properly hidden, elementPlaceholder must have a DISPLAY visibility mode.
                this.elementPlaceholder.setVisibilityMode(CQ.Ext.Element.DISPLAY);

                //build the empty component

                var msg = this.emptyText ? this.emptyText : CQ.I18n.getMessage("Drag components or assets here");
                if (!this.emptyComponent) {
                    this.emptyComponent = new CQ.Ext.Container({"autoEl": "div", "cls":"cq-editrollover-insert-container", "hideMode": "display", "renderTo": CQ.Util.ROOT_ID});
                    if (this.enableInsertOnlyText) {
                        this.emptyComponent.add(new CQ.Static({"text": msg,"cls":"cq-editrollover-insert-message","tag":"span"}));
                    }
                    this.emptyComponent.doLayout();
                } else {
                    if (this.enableInsertOnlyText) {
                        this.emptyComponent.items.items[0].text = msg;
                    }
                }

                this.emptyComponent.setWidth(elementWidth);
                this.emptyComponent.setHeight(h);
                this.emptyComponent.el.setStyle("position", "absolute");
                this.emptyComponent.el.anchorTo(this.elementPlaceholder, "tl", null, false, null);

                if (this.enableContextMenu)
                    this.emptyComponent.el.on("contextmenu", this.handleContextMenu, this);
                if (this.enableHighlight && !((this.isActionInsertOnly() || this.isEmpty) && !this.enableInsertOnlyText)) {
                    this.emptyComponent.el.on("mouseover", this.handleMouseOver, this);
                }

                if (this.selectable)
                    this.emptyComponent.el.on("click", this.handleClick, this);

                //if empty element or modify action is available
                if (this.enableEditOnDblClick && (this.isActionInsertOnly() || this.isActionEdit())) {
                    this.emptyComponent.el.on("dblclick", this.handleDblClick, this);
                }

                this.elementPlaceholder.show();
                this.emptyComponent.show();
            }

            //keep track that element is linked to this edit rollover
            this.element.linkedEditComponent = this;

            //if layout is not "toolbar" (ie layout is "menu"), add right click event to the complete element (all children)
            if (this.enableContextMenu)
                this.addElementEventListener(this.element.dom, "contextmenu", this.handleContextMenu, true, this);

            if (this.enableHighlight && !((this.isActionInsertOnly() || this.isEmpty) && !this.enableInsertOnlyText)) {
                this.element.on("mouseover", this.handleMouseOver, this);
            }
            if (this.selectable)
                this.element.on("click", this.handleClick, this);

            //if empty element or modify action is available
            if (this.enableEditOnDblClick && (this.isActionInsertOnly() || this.isActionEdit())) {
                this.element.on("dblclick", this.handleDblClick, this);
            }

            //define this element as a drop target for another editComponent only if INSERT action is available
            if (this.isDropTarget === true && this.isActionInsert()) {
                this.elementDropTarget = this.dropTargetClass.getInstance(this.element, this, [CQ.wcm.EditBase.DD_GROUP_COMPONENT]);
                //component is the element in case of a rollover
                this.componentDropTarget = this.elementDropTarget;
            }

            this.buildSubDropTargets();
        }
        this.ready = true;
        this.fireEvent(CQ.wcm.EditBase.EVENT_READY,this);
        CQ.Util.observeComponent(this);
    },

    /**
     * Show or hide live status
     * @private
     */
    handleLiveStatus: function() {
        if (this.enableLiveRelationship && this.liveStatus) {
            if (CQ.WCM.isShownLayer(CQ.utils.WCM.LAYER_LCSTATUS) && !this.hidden && !this.disabled && !this.elementHidden) {
                this.liveStatus.showFrames(this, this.liveStatusLocked);
            } else {
                this.liveStatus.hideFrames();
            }
        }
    },

    /**
     * Check if live status correctly displayed (value can be change inside the dialog).
     * @private
     */
    observeLiveStatus: function() {
        if (this.enableLiveRelationship) {
            if( this.liveStatusLocked) {
                this.suspendSubDropTargets();
            } else {
                this.resumeSubDropTargets();
            }
            if (!this.liveStatusRendered) {
                this.liveStatus = new CQ.wcm.EditRollover.LiveStatus(this.liveStatusContainerMode);
                var currentObj = this;
                if (this[CQ.wcm.msm.MSM.PARAM_LIVE_RELATIONSHIP][CQ.wcm.msm.MSM.PARAM_STATUS][CQ.wcm.msm.MSM.PARAM_IS_EDITABLE]) {
                    this.liveStatus.frameRight.on("render", function() {
                        this.getEl().on("click", currentObj.switchLock, currentObj);
                    }, this.liveStatus.frameRight);
                } else {
                    this.liveStatus.frameRight.on("render", function() {
                        this.getEl().dom.title = CQ.I18n.getMessage("Inheritance is broken at the page or parent level");
                    }, this.liveStatus.frameRight);
                }
                this.liveStatusRendered = true;
            }
            this.handleLiveStatus();
        }
    },

    /**
     * Called by observer. Makes sure the rollover and its elements are always align to
     * their placeholders. See {@link CQ.Dialog#observe}.
     * @private
     */
    observe: function() {
        var w,h;

        this.observeLiveStatus();
        this.observeElementPosition();

        if (!this.hidden && !this.disabled && !this.elementHidden) {
            //case of refresh: element has been replaced but elementPlaceholder has not been rebuild.
            if (this.elementPlaceholder && this.elementPlaceholder.getHeight() == 0) {
                this.buildElement();
            } else {
                if (this.isActionInsertOnly() || this.isEmpty) {
                    w = this.element.getWidth();

                    h = (this.enableInsertOnlyText ? CQ.themes.wcm.EditRollover.ELEMENT_MIN_HEIGHT : CQ.themes.wcm.EditRollover.ELEMENT_NO_TEXT_MIN_HEIGHT);

                    if (this.elementPlaceholder) {
                        if (this.elementPlaceholder.getWidth() != w) {
                            this.elementPlaceholder.setWidth(w);
                        }
                        if (this.elementPlaceholder.getHeight() != h) {
                            this.elementPlaceholder.setHeight(h);
                        }
                    }

                    if (this.emptyComponent) {
                        if (this.emptyComponent.el.getWidth() != w) {
                            this.emptyComponent.setWidth(w);
                        }
                        if (this.emptyComponent.el.getHeight() != h) {
                            this.emptyComponent.setHeight(h);
                        }

                        if (!CQ.Util.isEqualPosition(this.emptyComponent.el.getXY(), this.elementPlaceholder.getXY(), 1)) {
                            this.emptyComponent.el.alignTo(this.elementPlaceholder, "tl-tl");
                        }
                    }
                } else {
                    if (this.emptyComponent) {
                        if (this.emptyComponent.el.getWidth() != w) {
                            this.emptyComponent.setWidth(w);
                        }
                        if (this.emptyComponent.el.getHeight() != h) {
                            this.emptyComponent.setHeight(h);
                        }

                        if (!CQ.Util.isEqualPosition(this.emptyComponent.el.getXY(), this.elementPlaceholder.getXY(), 1)) {
                            this.emptyComponent.el.alignTo(this.elementPlaceholder, "tl-tl");
                        }
                    }
                }
            }
        }
    },

    /**
     * Handles context menu on right click
     * @param {CQ.Ext.EventObject} e The event object
     * @private
     */
    handleContextMenu: function(e) {
        if (e.altKey) {
            return;
        }
        if (window.CQ_inplaceEditComp) {
            return;
        }
        CQ.WCM.select(this, e.shiftKey || e.ctrlKey, true);
        var linkedEditComponent = this.element.linkedEditComponent;
        if (linkedEditComponent && linkedEditComponent.menu) {
            linkedEditComponent.showHighlight();
            if (!linkedEditComponent.menuComponent) {
                linkedEditComponent.menuComponent = new CQ.Ext.menu.Menu({
                    defaults: {
                        scope: linkedEditComponent
                    },
                    "items": linkedEditComponent.menu.items
                });
            }
            this.contextMenuXY = e.getXY();
            linkedEditComponent.menuComponent.showAt(this.contextMenuXY);
            e.stopEvent();
        }
    },

    /**
     * Returns the offsets for a new annotation as [x, y]
     * @private
     */
    getNewAnnotationOffset: function() {
        // place new annotation relative to the context menu
        return [
            this.contextMenuXY[0] - this.element.getXY()[0],
            this.contextMenuXY[1] - this.element.getXY()[1]
        ];
    },

    /**
     * Handles window resize
     * @private
     */
    handleWindowResize: function() {
        this.hideHighlight();
    },

    /**
     * Handles selection on left click
     * @param {CQ.Ext.EventObject} e The event object
     * @private
     */
    handleClick: function(e) {
        // check if there is an inplace editing process currently active
        if (window.CQ_inplaceEditComp) {
            if (window.CQ_inplaceEditComp == this) {
                // this component is being edited - nothing to do, click must be handled by
                // the inplace editor
                return;
            }
            // another component is being edited: finish editing and continue click handling
            window.CQ_inplaceEditComp.finishInplaceEditing();
        }
        //nested paragraphs: select only highlighted one
        if( CQ.wcm.EditRollover.currentlyHighlighted === this) {
            // We'll have to detect asynchroneously if this click event is part of a double
            // click or just a single click, as the click event is fired before the dblclick
            // event.
            this.asyncSingleClick = true;
            var asyncSelected = this.selected;
            (function() {
                this.handleClickAsync(asyncSelected);
            }).defer(1, this);
            var additive = e.shiftKey || e.ctrlKey;
            if (!this.isActionCopyMove() && !this.isActionDelete() && !this.isActionInsert()) {
                if (additive) {
                    CQ.DOM.clearDocumentSelection(CQ.WCM.getContentWindow());
                }
                return;
            }
            if (this.selected) {
                if (additive) {
                    CQ.WCM.deselect(this, true);
                } else {
                    CQ.WCM.select(this, false, true);
                }
            } else {
                CQ.WCM.select(this, additive, true);
            }
        }
    },

    handleClickAsync: function(selected) {
        if (this.asyncSingleClick) {
            if (selected) {
                //do not start inplacediting if live status is locked
                if(!this.liveStatusLocked) {
                    this.startInplaceEditing();
                }
            }
        }
        this.asyncSingleClick = false;
    },

    /**
     * This will be indirectly called by {@link CQ.WCM.EditBase#startInplaceEditing}.
     * This workaround is required, as {@link CQ.WCM.EditRollover} does not extend
     * {@link CQ.WCM.EditBase} in a OO manner.
     * @private
     */
    _startInplaceEditing: function() {
        // adjust highlight size and/or position if necessary
        this.inplaceEditor.addRepositionListener(function() {
            this.inplaceEditHighlight.showFrames(this);
        }.createDelegate(this));
        this.inplaceEditor.addResizeListener(function() {
            this.inplaceEditHighlight.adjustHighlightSize(this);
        }.createDelegate(this));
        this.inplaceEditHighlight.showFrames(this);
    },

    /**
     * Common things to do if inplace editing is over (finished or cancelled!)
     * @private
     */
    _resetInplaceEditing: function() {
        this.inplaceEditor.removeAllResizeListeners();
        this.inplaceEditHighlight.hideFrames(this);
        this.on(CQ.wcm.EditBase.EVENT_AFTER_EDIT, function(e) {
            CQ.wcm.EditRollover.preventNextHighlight = false;
        }, this, {
            "single": true
        });
    },

    /**
     * This will be indirectly called by {@link CQ.WCM.EditBase#finishInplaceEditing}.
     * This workaround is required, as {@link CQ.WCM.EditRollover} does not extend
     * {@link CQ.WCM.EditBase} in a OO manner.
     * @private
     */
    _finishInplaceEditing: function() {
        this._resetInplaceEditing();
    },

    /**
     * This will be indirectly called by {@link CQ.WCM.EditBase#cancelInplaceEditing}.
     * This workaround is required, as {@link CQ.WCM.EditRollover} does not extend
     * {@link CQ.WCM.EditBase} in a OO manner.
     * @private
     */
    _cancelInplaceEditing: function() {
        this._resetInplaceEditing();
    },

    /**
     * Handles double click
     * @param {CQ.Ext.EventObject} e The event object
     * @private
     */
    handleDblClick: function(e) {
        this.asyncSingleClick = false;
        // if inplace editing, ignore double click
        if (window.CQ_inplaceEditComp == this) {
            // use browser default behaviour (usually selects entire word on double click)
            return;
        }
        if (this.isActionEdit()) {
            CQ.wcm.EditBase.showDialog(this, CQ.wcm.EditBase.EDIT);
        } else {
            if (this.isActionInsert())
                CQ.wcm.EditBase.showDialog(this, CQ.wcm.EditBase.INSERT);
        }
        e.stopEvent();
    },

    /**
     * Handles mouse over
     * @param {CQ.Ext.EventObject} e The event object
     * @private
     */
    handleMouseOver: function(e) {
        if (!CQ.Ext.dd.DragDropMgr.dragCurrent && !CQ.WCM.isContentWindowLoading()) {
            if (window.CQ_inplaceEditComp != null) {
                this.hideHighlight();
                return;
            }
            //if no current highlight
            if (!CQ.wcm.EditRollover.currentlyHighlighted) {
                if (CQ.wcm.EditRollover.preventNextHighlight) {
                    CQ.wcm.EditRollover.preventNextHighlight = false;
                } else {
                    this.showHighlight();
                }
            } else {
                //if current highlighted object is a parent
                if (this.isParentHighlighted()) {
                    //hide parent highlight and show current object highlight
                    CQ.wcm.EditRollover.currentlyHighlighted.hideHighlight();
                    this.showHighlight();
                } else {
                    if (CQ.wcm.EditRollover.currentlyHighlighted !== this) {
                        //if not, request a highlight. Highlight will be given by current highlighted object in hideHighlight()
                        CQ.wcm.EditRollover.requestHighlight = this;
                    }
                }
            }
        }
        e.stopEvent();
    },

    /**
     * Handles mouse move
     * @param {CQ.Ext.EventObject} e The event object
     * @private
     */
    handleDocumentMouseMove: function(e) {
    if(this.element) {
            var hlw = CQ.themes.wcm.EditRollover.HIGHLIGHT_WIDTH;
            var hlp = CQ.themes.wcm.EditRollover.HIGHLIGHT_PADDING;
            var r = this.element.getRegion();
            var x = e.getPageX();
            var y = e.getPageY();
            var regionWidthHighlight = new CQ.Ext.lib.Region(r.top - hlw - hlp, r.right + hlw + hlp, r.bottom + hlw + hlp, r.left - hlw - hlp);
            if (!regionWidthHighlight.contains(new CQ.Ext.lib.Region(y, x, y, x)) ||
                this !== CQ.wcm.EditRollover.currentlyHighlighted) {
                this.hideHighlight();
            }
            regionWidthHighlight = null;
        }
    },

    /**
     * Handles document scroll
     * @param {CQ.Ext.EventObject} e The event object
     * @private
     */
    handleDocumentScroll: function(e) {
    	this.hideHighlight();
    },

    /**
     * Handles select
     * @param {Number} index Index in selection
     * @param {Object} item Selected object
     * @private
     */
    handleSelect: function(index, item) {
        if (item != this) return;
        if (!this.selected) {
            this.selected = true;
            this.highlight.addClass("cq-editrollover-selected");
            this.highlight.showFrames(this);

            if( this.enableLiveRelationship && !CQ.WCM.isShownLayer(CQ.WCM.LAYER_LCSTATUS)) {
                var clazz = this.liveStatusLocked ? "cq-editrollover-selected-livestatus-right-lock" : "cq-editrollover-selected-livestatus-right-unlock";
                clazz = "cq-editrollover-selected-livestatus  " + clazz;

                this.highlight.lock = new CQ.Ext.BoxComponent({autoEl: 'div', cls:clazz, renderTo: CQ.Util.ROOT_ID});
                this.highlight.lock.getEl().alignTo(this.highlight.frameRight.getEl(), "tl", [-20, 4]);
                this.highlight.lock.show();

                var currentObj = this;
                if (this[CQ.wcm.msm.MSM.PARAM_LIVE_RELATIONSHIP][CQ.wcm.msm.MSM.PARAM_STATUS][CQ.wcm.msm.MSM.PARAM_IS_EDITABLE]) {
                    this.highlight.lock.getEl().on("click", currentObj.switchLock, currentObj);
                } else {
                    this.highlight.lock.getEl().dom.title = CQ.I18n.getMessage("Inheritance is broken at the page or parent level");
                }
            }
        }
    },

    /**
     * Handles deselect
     * @param {Object} item Selected object
     * @private
     */
    handleDeselect: function(item) {
        if (item != this) return;
        if (this.selected) {
            if( this.highlight.lock) {
                this.highlight.lock.hide();
                this.highlight.lock.getEl().remove();
                this.highlight.lock = null;
            }
            this.highlight.hideFrames(this);
            this.highlight.removeClass("cq-editrollover-selected");
            this.selected = false;

        }
    },

    /**
     * Handles selection clear
     * @private
     */
    handleSelectionClear: function() {
        this.handleDeselect(this); // force deselect
    },


    /**
     * Shows the high light around the edit rollover.
     * @private
     * @since 5.3
     */
    showHighlight: function() {
        if (this.enableHighlight && this.element) {
            //TODO Request to EXT to have a public property access or a getter
            if (!CQ.Ext.dd.DragDropMgr.dragCurrent && !CQ.WCM.isContentWindowLoading()) {
                CQ.wcm.EditRollover.currentlyHighlighted = this;

                this.element.un("mouseover", this.handleMouseOver, this);
                this.addDocumentEventListener("mousemove", this.handleDocumentMouseMove, this);
                this.addDocumentEventListener("scroll", this.handleDocumentScroll, this);
                CQ.Ext.EventManager.onWindowResize(this.handleWindowResize, this);
                this.highlight.showFrames(this);
            }
        }
    },

    /**
     * Shows the high light around the edit rollover.
     * @private
     * @deprecated Use {@link #showHighlight} instead
     */
    showHighLight: this.showHighlight,

    /**
     * Hides the highlight.
     * @private
     * @since 5.3
     */
    hideHighlight: function() {
        if (CQ.wcm.EditRollover.currentlyHighlighted === this) {
            delete CQ.wcm.EditRollover.currentlyHighlighted;
        }

        this.removeDocumentEventListener("mousemove", this.handleDocumentMouseMove, this);
        this.removeDocumentEventListener("scroll", this.handleDocumentScroll, this);
        CQ.Ext.EventManager.removeResizeListener(this.handleWindowResize, this);

        if (this.enableHighlight && this.element) {
            //Workaround: no hasListener method on CQ.Ext.Element. Remove listener first to not add it twice
            this.element.un("mouseover", this.handleMouseOver, this);
            this.element.on("mouseover", this.handleMouseOver, this);
        }

        if (CQ.wcm.EditRollover.requestHighlight && !CQ.Ext.dd.DragDropMgr.dragCurrent) {
            CQ.wcm.EditRollover.currentlyHighlighted = CQ.wcm.EditRollover.requestHighlight;
            CQ.wcm.EditRollover.currentlyHighlighted.showHighlight();
            delete CQ.wcm.EditRollover.requestHighlight;
        }
        if (!this.selected && this.highlight) {
            this.highlight.hideFrames(this);
        }
    },

    /**
     * Hides the highlight.
     * @private
     * @deprecated Use {@link #hideHighlight} instead
     */
    hideHighLight: this.hideHighlight,

    /**
     * Clears all listeners related to this component.
     * @private
     */
    clearListeners: function() {
        if (CQ.wcm.EditRollover.currentlyHighlighted === this) {
            delete CQ.wcm.EditRollover.currentlyHighlighted;

            this.removeDocumentEventListener("mousemove", this.handleDocumentMouseMove, this);
            this.removeDocumentEventListener("scroll", this.handleDocumentScroll, this);
            CQ.Ext.EventManager.removeResizeListener(this.handleWindowResize, this);
        }

        if (this.emptyComponent) {
            this.emptyComponent.el.un("contextmenu", this.handleContextMenu, this);
            this.emptyComponent.el.un("mouseover", this.handleMouseOver, this);
            this.emptyComponent.el.un("click", this.handleClick, this);
        }
        if (this.element) {
            this.element.un("mouseover", this.handleMouseOver, this);
            this.element.un("click", this.handleClick, this);
            this.element.un("dblclick", this.handleDblClick, this);
            this.removeElementEventListener(this.element.dom, "contextmenu", this.handleContextMenu, true, this);
        }
    },

    /**
     * Shows the edit rollover.
     * @param {Boolean} ignoreNested If true sub editables are not hidden (since 5.4)
     * @public
     */
    show: function(ignoreNested) {
        this.hidden = false;
        this.hideHighlight();
        if (this.liveStatus) {
            this.liveStatus.showFrames();
        }

        //CQ-40524 in case of REFRESH_PARENT event instead of aftermove, this.element will be null
        if (this.element) {
            CQ.WCM.showPlaceholders(this.element);
            this.buildElement();

            if (this.isContained && this.isActionInsertOnly())
                this.element.parent().show();
        }
        this.resumeDropTargets();

        if (ignoreNested !== true) {
            //finally show nested editable: this avoid sub editbars to appear at the wrong place in the page
            var nestedEditables = CQ.WCM.getNestedEditables(this.path);
            for(var i = 0; i < nestedEditables.length; i++) {
                var editable = CQ.WCM.getEditable(nestedEditables[i]);
                if( editable ) {
                    editable.show(true);
                }
            }
        }

        this.showAnnotations();

        return this;
    },

    /**
     * Hides the edit rollover.
     * @param {Boolean} ignoreNested If true sub editables are not hidden (since 5.4)
     * @public
     */
    hide: function(ignoreNested) {
        if (ignoreNested !== true) {
            //finally hide nested editable: this avoid sub editbars to appear at the wrong place in the page
            var nestedEditables = CQ.WCM.getNestedEditables(this.path);
            for(var i = 0; i < nestedEditables.length; i++) {
                var editable = CQ.WCM.getEditable(nestedEditables[i]);
                if( editable ) {
                    editable.hide(true); //then we should ignore the nested here
                }
            }
        }

        this.suspendDropTargets();
        this.hidden = true;

        if (this.liveStatus) {
            this.liveStatus.hideFrames();
        }

        if (this.element) {
            this.hideHighlight();

            if (this.isContained && this.isActionInsertOnly()) {
                this.element.parent().hide();
            }

            //this.clearListeners(); // todo: use suspendEvents instead?
            CQ.WCM.hidePlaceholders(this.element);
            this.buildElement();
        }

        this.hideAnnotations();

        return this;
    },

    /**
     * Converts a potentiel {@link CQ.wcm.EditBar} toolbar action to a context menu action.
     * @param {String/Object} actionToConvert Action to convert: simple string or complex config
     * @private
     */
    convertAction: function(actionToConvert) {
        if (actionToConvert != null) {
            if (typeof actionToConvert == "string") {
                var convertedAction = CQ.wcm.EditRollover.ActionsConvertor[actionToConvert];
                if (convertedAction != null) {
                    if (typeof convertedAction == 'string') {
                        if (convertedAction.length > 0) {
                            return convertedAction;
                        } else {
                            return null;
                        }
                    } else {
                        return convertedAction;
                    }
                } else {
                    return {"text": actionToConvert, "disabled": true};
                }
            } else {
                if (actionToConvert.xtype) {
                    //force text type and context menu, force any text to be a titleseparator
                    if (actionToConvert.xtype == "tbtext" || actionToConvert.xtype == "text") {
                        actionToConvert.xtype = "titleseparator";
                        actionToConvert.title = actionToConvert.text;
                        return actionToConvert;
                    } else {
                        //if actions is an object with xtype equals to one of the toolbar xtype, convert it to the menu action
                        if (CQ.wcm.EditRollover.TBXTypesToMenuActions[actionToConvert.xtype] != null) {
                            return this.convertAction(CQ.wcm.EditRollover.TBXTypesToMenuActions[actionToConvert.xtype]);
                        }
                    }
                } else {
                    // if no xtype, force to text
                    if (actionToConvert.handler || actionToConvert.listeners) {
                        return actionToConvert;
                    } else {
                        return CQ.Util.applyDefaults(actionToConvert, {"disabled":true});
                    }
                }
            }
        }
        return actionToConvert;
    },

    /**
     * Hides the element part of the component.
     * @param {Boolean} keepParent If true, parent is not hidden
     * @param {Boolean} ignoreNested If true sub editables are not hidden (since 5.4)
     * @private
     */
    hideElement: function(keepParent, ignoreNested) {
        if (ignoreNested !== true) {
            //first hide nested editable: this avoid sub editbars to appear at the wrong place in the page
            var nestedEditables = CQ.WCM.getNestedEditables(this.path);
            for(var i = 0; i < nestedEditables.length; i++) {
                var editable = CQ.WCM.getEditable(nestedEditables[i]);
                if( editable ) {
                    editable.hide(true);
                    editable.hideElement(false, true);
                }
            }
        }

        this.elementHidden = true;

        if (this.liveStatus) {
            this.liveStatus.hideFrames();
        }

        this.hideHighlight();

        this.savedElementHeight = this.element.getHeight();
        this.savedElementWidth = this.element.getWidth();

        this.element.hide(this.animateHide);

        if (keepParent !== true && this.isContained)
            this.element.parent().hide();


        if (this.emptyComponent) {
            this.emptyComponent.hide();
        }

        if (this.elementPlaceholder) {
            this.elementPlaceholder.hide();
        }
    },

    /**
     * Shows the element part of the component.
     * @param {Boolean} ignoreNested If true sub editables are not hidden (since 5.4)
     * @private
     */
    showElement: function(ignoreNested) {
        this.elementHidden = false;

        if (this.emptyComponent) {
            this.emptyComponent.show();
        }

        if (this.elementPlaceholder) {
            this.elementPlaceholder.show();
        }

        //CQ-40524 in case of REFRESH_PARENT event instead of aftermove, this.element will be null
        if (this.element) {
            if (this.isContained)
                this.element.parent().show();

            this.element.show(this.animateShow);

            this.savedElementHeight = this.element.getHeight();
            this.savedElementWidth = this.element.getWidth();
        }
        if (ignoreNested !== true) {
            //finally show nested editable: this avoid sub editbars to appear at the wrong place in the page
            var nestedEditables = CQ.WCM.getNestedEditables(this.path);
            for(var i = 0; i < nestedEditables.length; i++) {
                var editable = CQ.WCM.getEditable(nestedEditables[i]);
                if( editable ) {
                    editable.showElement(true);
                    editable.show(true);
                }
            }
        }
    },

    /**
     * Refreshes the component: rezise placeholder and show placeholder.
     * @private
     */
    refreshComponent: function() {
        this.placeholder.setHeight(0);
        this.placeholder.show();
    },

    /**
     * Returns the placeholder where inline dialog is anchored to.
     * @return {CQ.Ext.Element} Placeholder
     * @private
     */
    getInlinePlaceholder: function() {
        return this.placeholder;
    },

    /**
     * Returns the initial height of the placeholder where inline dialog is anchored to.
     * @private
     */
    getInlinePlaceholderInitialHeight: function() {
        return 0;
    },

    /**
     * Removes the edit rollover.
     * @public
     */
    remove: function(ignoreNested) {
        if (ignoreNested !== true) {
            //first remove all nested editables to avoid JS error and inconsistencies
            var nestedEditables = CQ.WCM.getNestedEditables(this.path);
            for(var i = 0; i < nestedEditables.length; i++) {
                var editable = CQ.WCM.getEditable(nestedEditables[i]);
                if( editable ) {
                    editable.remove(true);
                }
            }
        }

        this.removeDropTargets();

        //cleanup selection
        CQ.WCM.deselect(this);
        var selection = CQ.WCM.getSelection();
        selection.un("add", this.handleSelect, this);
        selection.un("remove", this.handleDeselect, this);
        selection.un("clear", this.handleSelectionClear, this);
        this.removeSelectionListeners();
        this.removeClipboardListeners();

        CQ.WCM.unregisterDialog("editdialog-" + this.path);
        CQ.WCM.unregisterDialog("insertdialog-" + this.path);
        CQ.WCM.unregisterEditable(this.path);
        CQ.Util.cancelObservation(this);

        if (this.liveStatus) {
            this.liveStatus.hideFrames();
            CQ.Ext.destroy(this.liveStatus);
            CQ.Ext.ComponentMgr.unregister(this.liveStatus);
            delete this.liveStatus;
        }

        if (this.placeholder) {
            CQ.Ext.destroy(this.placeholder);
            CQ.Ext.ComponentMgr.unregister(this.placeholder);
            delete this.placeholder;
        }

        if (this.menuComponent) {
            CQ.Ext.destroy(this.menuComponent);
            CQ.Ext.ComponentMgr.unregister(this.menuComponent);
            delete this.menuComponent;
        }

        if (this.highlight) {
            this.highlight.hideFrames(this);
            CQ.Ext.destroy(this.highlight);
            CQ.Ext.ComponentMgr.unregister(this.highlight);
            delete this.highlight;
        }
        if (this.inplaceEditHighlight) {
            this.inplaceEditHighlight.hideFrames();
            CQ.Ext.destroy(this.inplaceEditHighlight);
            CQ.Ext.ComponentMgr.unregister(this.inplaceEditHighlight);
            delete this.inplaceEditHighlight;
        }
        this.removeAnnotations();

        this.clearListeners();
        CQ.Ext.ComponentMgr.unregister(this);

        if (this.emptyComponent) {
            CQ.Ext.destroy(this.emptyComponent);
            delete this.emptyComponent;
        }
        CQ.Ext.destroy(this.element);
        CQ.Ext.ComponentMgr.unregister(this.element);

        delete this.element;

        this.destroy();
		this.purgeListeners();
    },

    /**
     * Adds the given event listener to the given HTML element.
     * @private
     * @param {HTMLElement} element The element
     * @param {String} name The name of the event listener
     * @param {Function} func The function of the event listener
     * @param {Boolean} deep True if event listener should also be
     *        added to child elements
     * @param {Object} scope (optional) The scope in which to execute the handler function.
     * The handler function's "this" context.
     */
    addElementEventListener: function(element, name, func, deep, scope) {
        if (element &&
            (element.tagName == "script" ||
             element.tagName == "input" ||
             element.tagName == "select" ||
             element.tagName == "button" ||
             element.tagName == "a")) {
            // don't add event listeners to these elements
            return;
        }
        /*if (!element.tagName) {
         return;
         }*/

        var cmp = CQ.Ext.get(element);
        if (cmp) {
            cmp.addListener(name, func, scope);
            if (deep) {
                for (var i = 0; i < element.childNodes.length; i++) {
                    this.addElementEventListener(element.childNodes.item(i), name, func, false, scope);
                }
            }
        }
    },

    /**
     * Removes the given event listener from the given HTML element.
     * @private
     * @param {HTMLElement} element The element
     * @param {String} name The name of the event listener
     * @param {Function} func The function of the event listener
     * @param {Boolean} deep True if event listener should also be
     *        removed from child elements
     * @param {Object} scope (optional) The scope in which to execute the handler function.
     * The handler function's "this" context.
     */
    removeElementEventListener: function(element, name, func, deep, scope) {
        if (element &&
            (element.tagName == "script" ||
             element.tagName == "input" ||
             element.tagName == "select" ||
             element.tagName == "button" ||
             element.tagName == "a")) {
            // don't add event listeners to these elements
            return;
        }
        /*if (!element.tagName) {
         return;
         }*/
        var cmp = CQ.Ext.get(element);
        if (cmp) {
            cmp.removeListener(name, func, scope);
            if (deep) {
                for (var i = 0; i < element.childNodes.length; i++) {
                    this.removeElementEventListener(element.childNodes.item(i), name, func, false, scope);
                }
            }
        }
    },

    /**
     * Adds an event listener with the given name and function to the document.
     * @private
     * @param {String} name The event name
     * @param {Function} func The function to call in case of event
     */
    addDocumentEventListener: function(name, func, scope) {
        this.addElementEventListener(document, name, func, false, scope);
    },

    /**
     * Adds an event listener with the given name and function to the document.
     * @private
     * @param {String} name The event name
     * @param {Function} func The function to call in case of event
     */
    removeDocumentEventListener: function(name, func, scope) {
        this.removeElementEventListener(document, name, func, false, scope);
    }

});

CQ.Ext.reg("editrollover", CQ.wcm.EditRollover);

//overrides current CQ.wcm.EditRollover class with methods contained in CQ.wcm.EditBase.
CQ.Ext.override(CQ.wcm.EditRollover, CQ.wcm.EditBase);

//configuration for action conversion
CQ.wcm.EditRollover.ActionsConvertor = new Array;

//separator aliases
CQ.wcm.EditRollover.ActionsConvertor["separator"] = "-";
CQ.wcm.EditRollover.ActionsConvertor["-"] = CQ.wcm.EditRollover.ActionsConvertor["separator"];

//spacer aliases: spacers are removed from context menus
CQ.wcm.EditRollover.ActionsConvertor["spacer"] = "";//{"text": " ", "disabled": true};
CQ.wcm.EditRollover.ActionsConvertor[" "] = CQ.wcm.EditRollover.ActionsConvertor["spacer"];

//fill aliases: fills are removed from context menus
CQ.wcm.EditRollover.ActionsConvertor["fill"] = "";//{"text": " ", "disabled": true};
CQ.wcm.EditRollover.ActionsConvertor["->"] = CQ.wcm.EditRollover.ActionsConvertor["fill"];

//conversion from toolbar xtypes to menu action "types"
CQ.wcm.EditRollover.TBXTypesToMenuActions = new Array;
CQ.wcm.EditRollover.TBXTypesToMenuActions["tbseparator"] = "separator";
CQ.wcm.EditRollover.TBXTypesToMenuActions["tbspacer"] = "spacer";
CQ.wcm.EditRollover.TBXTypesToMenuActions["tbfill"] = "fill";

/**
 * @class CQ.wcm.EditRollover.DragZone
 * @extends CQ.wcm.EditBase.DragZone
 * The EditRollover.DragZone is a drag zone for a {@link CQ.wcm.EditRollover}.
 */
CQ.wcm.EditRollover.DragZone = CQ.Ext.extend(CQ.wcm.EditBase.DragZone, {
    /**
     * Hides edit component
     * @private
     */
    hideEditComponent: function() {
        CQ.wcm.EditRollover.DragZone.superclass.hideEditComponent.call(this);
        for (var i = 0; i < this.dragData.items.length; i++) {
            try {
                CQ.WCM.deselect(this.dragData.items[i]);
                this.dragData.items[i].highlight.hideFrames();
            } catch (e) {
            }
        }
    }

});

CQ.wcm.EditRollover.DisabledDragZone = CQ.Ext.extend(CQ.Ext.dd.DragZone, {
    constructor: function(el, config) {
        config = config || {};

        var dragEl = document.createElement("div");
        CQ.Ext.fly(dragEl).addClass("cq-editrollover-livestatus-disabled");
        dragEl.innerHTML = CQ.I18n.getMessage("Fixed Component");

        CQ.Ext.apply(config, {
            ddel: dragEl,
            ddGroup: "match_nothing"
        });

        CQ.wcm.EditRollover.DisabledDragZone.superclass.constructor.call(this, el, config);
    },

    getDragData: function(e) {
        return this;
    },

    getRepairXY : function(e, data){
        // Turn off the repair animation (which the animRepair config property fails to do since it
        // never gets written into the StatusProxy).
        return null;
    }
});

/**
 * Returns an instance of an {@link CQ.wcm.EditRollover.DragZone} and manages drag and drop groups.
 * @static
 * @param {Mixed} element The element
 * @param {CQ.wcm.EditRollover} editComponent The edit component
 * @param {String[]} groups (optional) The drag & drop groups
 * @return {CQ.wcm.EditRollover.DragZone} The drag zone
 * @public
 */
CQ.wcm.EditRollover.DragZone.getInstance = function(element, editComponent, groups) {
    var dz = new CQ.wcm.EditRollover.DragZone(element, {"editComponent": editComponent});
    if (groups) {
        var i = 0;
        for (; i < groups.length; i++)
            dz.addToGroup(groups[i]);
        //as ddGroup is not specified in the config, a "default" group has been set by Ext. Remove it.
        dz.removeFromGroup(CQ.wcm.EditBase.DD_GROUP_DEFAULT);
    }
    return dz;
};

CQ.wcm.EditRollover.DisabledDragZone.getInstance = function(element) {
    return new CQ.wcm.EditRollover.DisabledDragZone(element, {});
};

/**
 * @class CQ.wcm.EditRollover.DropTarget
 * @extends CQ.wcm.EditBase.DropTarget
 * The EditRollover.DropTarget is a drop target for a {@link CQ.wcm.EditRollover}.
 */
CQ.wcm.EditRollover.DropTarget = CQ.Ext.extend(CQ.wcm.EditBase.DropTarget, {

     //overriding CQ.wcm.EditBase.DropTarget#notifyEnter
    notifyEnter: function(dragSource, e, data) {
        return CQ.wcm.EditRollover.DropTarget.superclass.notifyEnter.call(this, dragSource, e, data);
    },

    //overriding CQ.wcm.EditBase.DropTarget#notifyOver
    notifyOver : function(dragSource, e, data) {
        this.editComponent.highlight.hideFrames();
        return CQ.wcm.EditRollover.DropTarget.superclass.notifyOver.call(this, dragSource, e, data);
    }

});

/**
 * Returns an instance of a {@link CQ.wcm.EditRollover.DropTarget} and manages drag and drop groups.
 * @static
 * @param {Mixed} element The element
 * @param {CQ.wcm.EditRollover} editComponent The edit component
 * @param {String[]} groups (optional) The drag & drop groups
 * @param {Object} config (optional) The config object
 * @return {CQ.wcm.EditRollover.DropTarget} The drop target
 */
CQ.wcm.EditRollover.DropTarget.getInstance = function(element, editComponent, groups, config) {
    config = config || {};

    if (editComponent)
        config.editComponent = editComponent;

    var dt = new CQ.wcm.EditRollover.DropTarget(element, config);

    if (groups) {
        var i = 0;
        for (; i < groups.length; i++)
            dt.addToGroup(groups[i]);
        //as ddGroup is not specified in the config, a "default" group has been set by Ext. Remove it.
        dt.removeFromGroup(CQ.wcm.EditBase.DD_GROUP_DEFAULT);
    }
    return dt;
};

/**
 * Name of event to be fired when highlight is shown
 * @static
 * @final
 * @type String
 * @private
 */
CQ.wcm.EditRollover.EVENT_SHOW_HIGHTLIGHT = "showhighlight";

/**
 * Name of event to be fired when highlight is hidden
 * @static
 * @final
 * @type String
 * @private
 */
CQ.wcm.EditRollover.EVENT_HIDE_HIGHTLIGHT = "hidehighlight";

/**
 * @class CQ.wcm.EditRollover.Highlight
 * @extends CQ.Ext.Component
 * The EditRollover.Highlight is a highlight of {@link CQ.wcm.EditRollover} contained element.
 * @constructor
 * Creates a new Highlight.
 * @private
 */
CQ.wcm.EditRollover.Highlight = CQ.Ext.extend(CQ.Ext.Component, {
    /**
     * Left frame of the high light
     * @private
     * @type {CQ.Ext.BoxComponent}
     */
    frameLeft: null,

    /**
     * Right frame of the high light
     * @private
     * @type {CQ.Ext.BoxComponent}
     */
    frameRight: null,

    /**
     * Bottom frame of the high light
     * @private
     * @type {CQ.Ext.BoxComponent}
     */
    frameBottom: null,

    /**
     * Top frame of the high light
     * @private
     * @type {CQ.Ext.BoxComponent}
     */
    frameTop: null,

    constructor: function() {
        CQ.wcm.EditRollover.Highlight.superclass.constructor.call(this);
        this.frameLeft = new CQ.Ext.BoxComponent({autoEl: 'div', cls:'cq-editrollover-highlight-left'});
        this.frameRight = new CQ.Ext.BoxComponent({autoEl: 'div', cls:'cq-editrollover-highlight-right'});
        this.frameBottom = new CQ.Ext.BoxComponent({autoEl: 'div', cls:'cq-editrollover-highlight-bottom'});
        this.frameTop = new CQ.Ext.BoxComponent({autoEl: 'div', cls:'cq-editrollover-highlight-top'});
    },

    /**
     * Adjusts the size of the highlight to the current size of the specified edit rollover.
     * @param {CQ.wcm.EditRollover} editRollover The edit rollover to adjust the size to
     */
    adjustHighlightSize: function(editRollover) {

        var hlw = CQ.themes.wcm.EditRollover.HIGHLIGHT_WIDTH;
        var hlp = CQ.themes.wcm.EditRollover.HIGHLIGHT_PADDING;

        var width = editRollover.element.getWidth();
        var height = editRollover.element.getHeight();
        var left = this.frameLeft.el.getLeft() + hlw + hlp;
        var top = this.frameTop.el.getTop() + hlw + hlp;

        this.frameTop.setWidth(width + 2 * hlw + 2 * hlp);
        this.frameTop.setHeight(hlw);
        this.frameBottom.setPosition(left - hlw - hlp, top + height + hlp);
        this.frameBottom.setWidth(width + 2 * hlw + 2 * hlp);
        this.frameBottom.setHeight(hlw);
        this.frameLeft.setWidth(hlw);
        this.frameLeft.setHeight(height + 2 * hlp);
        this.frameRight.setPosition(left + width + hlp, top - hlp);
        this.frameRight.setWidth(hlw);
        this.frameRight.setHeight(height + 2 * hlp);
    },

    /**
     * Renders and shows the frames of the high light
     * @param {Element} renderTo Render to element
     * @param {Object} editRollover Show frames around this component
     * @public
     */
    showFrames: function(editRollover) {
        if (!this.frameLeft.rendered) this.frameLeft.render(CQ.Util.ROOT_ID);
        if (!this.frameRight.rendered) this.frameRight.render(CQ.Util.ROOT_ID);
        if (!this.frameBottom.rendered) this.frameBottom.render(CQ.Util.ROOT_ID);
        if (!this.frameTop.rendered) this.frameTop.render(CQ.Util.ROOT_ID);


        if (editRollover) {
            var element = editRollover.element;
            var hlw = CQ.themes.wcm.EditRollover.HIGHLIGHT_WIDTH;
            var hlp = CQ.themes.wcm.EditRollover.HIGHLIGHT_PADDING;

            var width = element.getWidth();
            var height = element.getHeight();
            if( editRollover.emptyComponent ) {
                height = editRollover.emptyComponent.getEl().getHeight();
            }

            var left = element.getLeft();
            var top = element.getTop();

            this.frameTop.setWidth(width + 2 * hlw + 2 * hlp);
            this.frameTop.setHeight(hlw);
            this.frameTop.setPosition(left - hlw - hlp, top - hlw - hlp);

            this.frameBottom.setWidth(width + 2 * hlw + 2 * hlp);
            this.frameBottom.setHeight(hlw);
            this.frameBottom.setPosition(left - hlw - hlp, top + height + hlp);

            this.frameLeft.setWidth(hlw);
            this.frameLeft.setHeight(height + 2 * hlp);
            this.frameLeft.setPosition(left - hlw - hlp, top - hlp);

            this.frameRight.setWidth(hlw);
            this.frameRight.setHeight(height + 2 * hlp);
            this.frameRight.setPosition(left + width + hlp, top - hlp);

            if (editRollover.orderable) {
                if (!this.frameTop.dd) {
                    this.frameTop.dd = CQ.wcm.EditRollover.DragZone.getInstance(this.frameTop.getEl(), editRollover, [CQ.wcm.EditBase.DD_GROUP_COMPONENT]);
                } else {
                    this.frameTop.dd.unlock();
                    this.frameTop.dd.clearGroups();
                    this.frameTop.dd.editComponent = editRollover;
                    this.frameTop.dd.addToGroups([CQ.wcm.EditBase.DD_GROUP_COMPONENT]);
                }

                if (!this.frameBottom.dd) {
                    this.frameBottom.dd = CQ.wcm.EditRollover.DragZone.getInstance(this.frameBottom.getEl(), editRollover, [CQ.wcm.EditBase.DD_GROUP_COMPONENT]);
                } else {
                    this.frameBottom.dd.unlock();
                    this.frameBottom.dd.clearGroups();
                    this.frameBottom.dd.editComponent = editRollover;
                    this.frameBottom.dd.addToGroups([CQ.wcm.EditBase.DD_GROUP_COMPONENT]);
                }

                if (!this.frameLeft.dd) {
                    this.frameLeft.dd = CQ.wcm.EditRollover.DragZone.getInstance(this.frameLeft.getEl(), editRollover, [CQ.wcm.EditBase.DD_GROUP_COMPONENT]);
                } else {
                    this.frameLeft.dd.unlock();
                    this.frameLeft.dd.clearGroups();
                    this.frameLeft.dd.editComponent = editRollover;
                    this.frameLeft.dd.addToGroups([CQ.wcm.EditBase.DD_GROUP_COMPONENT]);
                }

                if (!this.frameRight.dd) {
                    this.frameRight.dd = CQ.wcm.EditRollover.DragZone.getInstance(this.frameRight.getEl(), editRollover, [CQ.wcm.EditBase.DD_GROUP_COMPONENT]);
                } else {
                    this.frameRight.dd.unlock();
                    this.frameRight.dd.clearGroups();
                    this.frameRight.dd.editComponent = editRollover;
                    this.frameRight.dd.addToGroups([CQ.wcm.EditBase.DD_GROUP_COMPONENT]);
                }
            } else {
                if (!this.frameTop.dd) {
                    this.frameTop.dd = CQ.wcm.EditRollover.DisabledDragZone.getInstance(this.frameTop.getEl());
                }
                if (!this.frameBottom.dd) {
                    this.frameBottom.dd = CQ.wcm.EditRollover.DisabledDragZone.getInstance(this.frameBottom.getEl());
                }
                if (!this.frameLeft.dd) {
                    this.frameLeft.dd = CQ.wcm.EditRollover.DisabledDragZone.getInstance(this.frameLeft.getEl());
                }
                if (!this.frameRight.dd) {
                    this.frameRight.dd = CQ.wcm.EditRollover.DisabledDragZone.getInstance(this.frameRight.getEl());
                }
            }

            this.frameLeft.show();
            this.frameRight.show();
            this.frameBottom.show();
            this.frameTop.show();

            editRollover.fireEvent(CQ.wcm.EditRollover.EVENT_SHOW_HIGHTLIGHT, this);
        }
    },

    /**
     * Hides the frames
     * @public
     */
    hideFrames: function(editRollover) {
        this.frameLeft.hide();
        this.frameRight.hide();
        this.frameBottom.hide();
        this.frameTop.hide();

        if( editRollover ) {
            editRollover.fireEvent(CQ.wcm.EditRollover.EVENT_HIDE_HIGHTLIGHT, this);
        }
    },

    /**
     * Adds a CSS class to all the frames
     * @param {String} cls CSS class name
     * @public
     */
    addClass: function(cls) {
        this.frameLeft.addClass(cls);
        this.frameRight.addClass(cls);
        this.frameBottom.addClass(cls);
        this.frameTop.addClass(cls);
    },

    /**
     * Removes CSS class from all the frames
     * @param {String} cls CSS class name
     * @public
     */
    removeClass: function(cls) {
        this.frameLeft.removeClass(cls);
        this.frameRight.removeClass(cls);
        this.frameBottom.removeClass(cls);
        this.frameTop.removeClass(cls);
    },

    /**
     * Calls {@link CQ.Ext.util.Observable#on} method on all the frames.
     * @public
     */
    on: function(name, fnc, scope) {
        this.frameLeft.on(name, fnc, scope);
        this.frameRight.on(name, fnc, scope);
        this.frameBottom.on(name, fnc, scope);
        this.frameTop.on(name, fnc, scope);
    },

    /**
     * Calls {@link CQ.Ext.util.Observable#un} method on all the frames.
     * @public
     */
    un: function(name, fnc, scope) {
        this.frameLeft.un(name, fnc, scope);
        this.frameRight.un(name, fnc, scope);
        this.frameBottom.un(name, fnc, scope);
        this.frameTop.un(name, fnc, scope);
    },

    /**
     * Destroys all the frames and current object
     * @public
     */
    destroy: function() {
        CQ.Ext.destroy(this.frameLeft);
        CQ.Ext.destroy(this.frameRight);
        CQ.Ext.destroy(this.frameBottom);
        CQ.Ext.destroy(this.frameTop);

        delete this.frameLeft;
        delete this.frameRight;
        delete this.frameBottom;
        delete this.frameTop;

        CQ.wcm.EditRollover.Highlight.superclass.destroy.call(this);
    }

});

/**
 * @deprecated Use {@link CQ.wcm.EditRollover.Highlight} instead
 * @private
 */
CQ.wcm.EditRollover.HighLight = CQ.wcm.EditRollover.Highlight;

/**
 * @class CQ.wcm.EditRollover.LiveStatus
 * @extends CQ.Ext.Component
 * The LiveStatus displayes the live relationship of a component.
 * Default display is done through a surrounding rectangle based on 4 {@link CQ.Ext.BoxComponent}.
 * @constructor
 * Creates a new LiveStatus.
 * @param {Boolean} containerMode True if LiveStatus should behave as a container of others LiveStatus
 * @private
 */
CQ.wcm.EditRollover.LiveStatus = CQ.Ext.extend(CQ.Ext.Component, {
    /**
     * Left frame of the high light
     * @private
     * @type {CQ.Ext.BoxComponent}
     */
    frameLeft: null,

    /**
     * Right frame of the high light
     * @private
     * @type {CQ.Ext.BoxComponent}
     */
    frameRight: null,

    /**
     * Bottom frame of the high light
     * @private
     * @type {CQ.Ext.BoxComponent}
     */
    frameBottom: null,

    /**
     * Top frame of the high light
     * @private
     * @type {CQ.Ext.BoxComponent}
     */
    frameTop: null,

    /**
     * True if LiveStatus should behave as a container of others LiveStatus
     * @private
     * @type {Boolean}
     */
    containerMode: false,

    /**
     * @cfg {String} lockCls
     * CSS class for lock state (left, top, bottom frames)
     */
    lockCls: "cq-editrollover-livestatus-lock",

    /**
     * @cfg {String} lockRightCls
     * CSS class for lock state (right frame)
     */
    lockRightCls: "cq-editrollover-livestatus-right-lock",

    /**
     * @cfg {String} unlockCls
     * CSS class for unlock state (left, top, bottom frames)
     */
    unlockCls: "cq-editrollover-livestatus-unlock",

    /**
     * @cfg {String} unlockRightCls
     * CSS class for unlock state (right frame)
     */
    unlockRightCls: "cq-editrollover-livestatus-right-unlock",

    constructor: function(containerMode) {
        CQ.wcm.EditRollover.LiveStatus.superclass.constructor.call(this);

        if (containerMode) {
            this.containerMode = true;
        }

        this.frameLeft = new CQ.Ext.BoxComponent({autoEl: 'div', cls:'cq-editrollover-livestatus-left'});
        this.frameRight = new CQ.Ext.BoxComponent({autoEl: 'div', cls:'cq-editrollover-livestatus-right'});
        this.frameBottom = new CQ.Ext.BoxComponent({autoEl: 'div', cls:'cq-editrollover-livestatus-bottom'});
        this.frameTop = new CQ.Ext.BoxComponent({autoEl: 'div', cls:'cq-editrollover-livestatus-top'});
    },

    /**
     * Renders and shows the frames of the high light
     * @param {DOMElement} renderTo Render to element
     * @param {Object} editComponent Show frames around this component
     * @public
     */
    showFrames: function(editComponent, lock) {
        if (!this.frameLeft.rendered) this.frameLeft.render(CQ.Util.ROOT_ID);
        if (!this.frameRight.rendered) this.frameRight.render(CQ.Util.ROOT_ID);
        if (!this.frameBottom.rendered) this.frameBottom.render(CQ.Util.ROOT_ID);
        if (!this.frameTop.rendered) this.frameTop.render(CQ.Util.ROOT_ID);


        if (editComponent) {
            var element = editComponent.element;
            var hlw = 1;//CQ.themes.wcm.editComponent.HIGHLIGHT_WIDTH;
            var hlp = 2;//CQ.themes.wcm.editComponent.HIGHLIGHT_PADDING;
            var lockPadding = 10;

            var width = element.getWidth();
            var height = element.getHeight();
            var left = element.getLeft();
            var top = element.getTop();

            if (this.containerMode) {
                hlp += 4;
                width += 14;
                lockPadding = 2;
            }

            this.frameTop.setWidth(width + 2 * hlw + 2 * hlp);
            this.frameTop.setHeight(hlw);
            this.frameTop.setPosition(left - hlw - hlp, top - hlw - hlp);

            this.frameBottom.setWidth(width + 2 * hlw + 2 * hlp);
            this.frameBottom.setHeight(hlw);
            this.frameBottom.setPosition(left - hlw - hlp, top + height + hlp);

            this.frameLeft.setWidth(hlw);
            this.frameLeft.setHeight(height + 2 * hlp);
            this.frameLeft.setPosition(left - hlw - hlp, top - hlp);

            this.frameRight.setWidth(hlw);
            this.frameRight.setHeight(height + 2 * hlp);
            this.frameRight.setPosition(left + width - lockPadding - hlp - hlw - 6, top - hlp);

            if (lock) {
                this.displayLock();
            } else {
                this.displayUnLock();
            }

            this.frameLeft.show();
            this.frameRight.show();
            this.frameBottom.show();
            this.frameTop.show();
        }
    },

    /**
     * Switches LiveStatus to lock state
     * @public
     */
    displayLock: function() {
        this.frameRight.removeClass(this.unlockRightCls);
        this.frameLeft.removeClass(this.unlockCls);
        this.frameBottom.removeClass(this.unlockCls);
        this.frameTop.removeClass(this.unlockCls);

        this.frameRight.addClass(this.lockRightCls);
        this.frameLeft.addClass(this.lockCls);
        this.frameBottom.addClass(this.lockCls);
        this.frameTop.addClass(this.lockCls);
    },

    /**
     * Switches LiveStatus to unlock state
     * @public
     */
    displayUnLock: function() {
        this.frameRight.removeClass(this.lockRightCls);
        this.frameLeft.removeClass(this.lockCls);
        this.frameBottom.removeClass(this.lockCls);
        this.frameTop.removeClass(this.lockCls);

        this.frameLeft.addClass(this.unlockCls);
        this.frameRight.addClass(this.unlockRightCls);
        this.frameBottom.addClass(this.unlockCls);
        this.frameTop.addClass(this.unlockCls);
    },

    /**
     * Hides the frames
     * @public
     */
    hideFrames: function() {
        this.frameLeft.hide();
        this.frameRight.hide();
        this.frameBottom.hide();
        this.frameTop.hide();
    },

    /**
     * Adds a CSS class to all the frames
     * @param {String} cls CSS class name
     * @public
     */
    addClass: function(cls) {
        this.frameLeft.addClass(cls);
        this.frameRight.addClass(cls);
        this.frameBottom.addClass(cls);
        this.frameTop.addClass(cls);
    },

    /**
     * Removes CSS class from all the frames
     * @param {String} cls CSS class name
     * @public
     */
    removeClass: function(cls) {
        this.frameLeft.removeClass(cls);
        this.frameRight.removeClass(cls);
        this.frameBottom.removeClass(cls);
        this.frameTop.removeClass(cls);
    },

    /**
     * Calls {@link CQ.Ext.util.Observable#on} method on all the frames.
     * @public
     */
    on: function(name, fnc, scope) {
        this.frameLeft.on(name, fnc, scope);
        this.frameRight.on(name, fnc, scope);
        this.frameBottom.on(name, fnc, scope);
        this.frameTop.on(name, fnc, scope);
    },

    /**
     * Calls {@link CQ.Ext.util.Observable#un} method on all the frames.
     * @public
     */
    un: function(name, fnc, scope) {
        this.frameLeft.un(name, fnc, scope);
        this.frameRight.un(name, fnc, scope);
        this.frameBottom.un(name, fnc, scope);
        this.frameTop.un(name, fnc, scope);
    },

    /**
     * Destroys all the frames and current object
     * @public
     */
    destroy: function() {
        CQ.Ext.destroy(this.frameLeft);
        CQ.Ext.destroy(this.frameRight);
        CQ.Ext.destroy(this.frameBottom);
        CQ.Ext.destroy(this.frameTop);

        delete this.frameLeft;
        delete this.frameRight;
        delete this.frameBottom;
        delete this.frameTop;

        CQ.wcm.EditRollover.LiveStatus.superclass.destroy.call(this);
    }
});
