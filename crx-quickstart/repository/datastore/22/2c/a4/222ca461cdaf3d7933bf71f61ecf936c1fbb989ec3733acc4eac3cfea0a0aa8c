/*
 * Copyright 1997-2008 Day Management AG
 * Barfuesserplatz 6, 4001 Basel, Switzerland
 * All Rights Reserved.
 *
 * This software is the confidential and proprietary information of
 * Day Management AG, ("Confidential Information"). You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Day.
 */

/**
 * @class CQ.wcm.ContentFinderTab
 * @extends CQ.Ext.Panel
 * <p>ContentFinderTab is a specialized panel providing features used in the
 * tab panels of the {@link CQ.wcm.ContentFinder}. Typically it is featuring a
 * search form - the Query Box - and a data view to display the search
 * results.</p>
 * <p>The ContentFinderTab class provides static methods to easily receive
 * config object of the required items.</p>
 * @constructor
 * Creates a new ContentFinderTab.
 * @param {Object} config The config object
 */
CQ.wcm.ContentFinderTab = CQ.Ext.extend(CQ.Ext.Panel, {

    /**
     * @cfg {Number} ranking
     * The ranking for the position in the Content Finder's tab panel. Tabs without
     * any ranking are pushed aback.
     */

    /**
     * The fields of the tabs single form. If there are multiple forms on the tab
     * fields is null.
     * @type CQ.Ext.Component[]
     * @private
     */
    fields: null,


    /**
     * @cfg {String} pathComboId
     * If the Result Box contains a Path Combo (usually created using
     * {@link CQ.wcm.ContentFinderTab#getPathComboConfig}) this property must
     * specify the ID of the Path Combo.
     * @private
     */

    dataView: null,

    form: null,

    history: null,

    initComponent: function() {
        CQ.wcm.ContentFinderTab.superclass.initComponent.call(this);

        try {
            this.dataView = this.findByType("dataview")[0];
        }
        catch (e) {}

        try {
            var forms = this.findByType("form");
            if (forms.length == 1) {
                var form = forms[0];
                this.fields = CQ.Util.findFormFields(form);
            }
        }
        catch (e) {}

        if (this.historyId) {
            this.history = CQ.Ext.getCmp(this.historyId);
        }

    },

    constructor: function(config) {
        config = CQ.Util.applyDefaults(config, {
            "layout": "border",
//            "title": config.title ? config.title : "",
            "items": [],
            "listeners": {
                "show": function() {
                    this.loadStore(this.getParams());
                }
            }
        });

        CQ.wcm.ContentFinderTab.superclass.constructor.call(this, config);
    },

    /**
     * Gets all parameters of the parent form of the specified component, i.e.
     * the component is usually a form field or a composite field.
     * @param {CQ.Ext.Component} comp The component
     * @private
     */
    getParams: function(comp) {
        var fields;
        if ((this.fields == null) && comp) {
            var form = comp.findParentByType("form");
            fields = CQ.Util.findFormFields(form);
        }
        else {
            fields = this.fields;
        }
        var params = new Object();
        for (var name in this.fields) {
            var f = this.fields[name];
            for (var i = 0; i < f.length; i++) {

                // todo: checkboxes and radio buttons currently only work within CQ.form.Selection
                // todo: (where checkboxes return an array of values which will be transformed to single
                // todo: params inside the store)
                params[name] = f[i].getValue();
            }
        }
        return params;
    },

    /**
     * Submits the Query Box and loads the store of the data view. The Query Box
     * will be the parent form of the specified component.
     * @param {CQ.Ext.Component} comp The component, usually a field or composite field
     */
    submitQueryBox: function(comp) {
        try {
            var params = this.getParams(comp);

            var query = this.getQueryValue();
            //todo: search, not openFolder: reasonable to show path?
//            var startIndex = query.indexOf("path:");
//            if (startIndex != -1) {
//                // todo: respect quotes/spaces in path
//                startIndex += 5; // + "path:".length
//                var endIndex = query.indexOf(" ", startIndex);
//                var path;
//                if (endIndex != -1) {
//                    path = query.substring(startIndex,  endIndex);
//                }
//                else {
//                    path = query.substring(startIndex);
//                }
//                CQ.wcm.ContentFinderTab.adjustPathCombo(this, path);
//            }
//            else {
//                CQ.wcm.ContentFinderTab.disablePathCombo(this);
//            }
            CQ.wcm.ContentFinderTab.disablePathCombo(this);

            this.loadStore(params);
        }
        catch(e) {
            CQ.Log.error("ContentFinderTab#submitQueryBox: " + e.message);
        }
    },

    // loads the store of the data view with the specified params
    // private
    loadStore: function(params) {
        try {
            this.loading = true;
            this.dataView.store.load({
                "params": params
            });
        }
        catch(e) {
            CQ.Log.error("ContentFinderTab#loadStore: " + e.message);
        }
    },

    /**
     * Sets the value of the query field. The query field is the first field of
     * the name "query".
     * @param {String} value The value
     */
    setQueryValue: function(value) {
        //todo: make name configurable?
        //todo: -> pass as parameter? cf tab config?
        var name = "query";
        try {
            this.fields[name][0].setValue(value);
        }
        catch (e) {}
    },

    /**
     * Returns the value of the query field. The query field is the first field
     * of the name "query".
     * @return {String} value
     */
    getQueryValue: function(value) {
        //todo: make name configurable?
        //todo: -> pass as parameter? cf tab config?
        var name = "query";
        try {
            return this.fields[name][0].getValue();
        }
        catch (e) {}
    }

});

CQ.Ext.reg("contentfindertab", CQ.wcm.ContentFinderTab);

//todo: no longer in use? (May 2009)
/**
 * The default root path for the search.
 * @type String
 * @private
 */
CQ.wcm.ContentFinderTab.ROOTPATH = "/content";

//todo: no longer in use? (May 2009)
/**
 * The default URL for the data view.
 * @type String
 * @private
 */
CQ.wcm.ContentFinderTab.DATAVIEW_URL = "/bin/wcm/search/gql.json";

/**
 * <p>Returns a {@link CQ.Ext.form.FormPanel FormPanel} config object for the
 * Query Box. The specified config will be merged with defaults.
 * @param {Object} config A {@link CQ.Ext.form.FormPanel} config object.<br>
 * Typically onlty the following two properties needs to be specified:</p>
 * <ul>
 * <li><code>{@link CQ.Ext.form.FormPanel#id id}</code> : String<br>
 * The specified config should contain an unique property id to become {@link #stateful}.
 * If id is set the Content Finder will open after loading the last viewed tab.</li>
 * <li><code>{@link CQ.Ext.form.FormPanel#items items}</code> : CQ.Ext.Component[]<br>
 * The property items contains the form fields of the Query Box.</li>
 * </ul>
 * @return {Object} The specified {@link CQ.Ext.form.FormPanel} config object merged with defaults
 * @static
 */
CQ.wcm.ContentFinderTab.getQueryBoxConfig = function(config) {
    config = CQ.Util.applyDefaults(config, {
        "xtype": "form",
        "method": "GET",
        "region": "north",
        "height": CQ.themes.wcm.ContentFinderTab.QUERYBOX_HEIGHT,
        "bodyStyle": CQ.themes.wcm.ContentFinderTab.QUERYBOX_BODYSTYLE,
        "layout": "fit",
        "split": true,
        "autoScroll": true,
        "cls": "cq-cft-querybox",
        "baseParams": {
            "_charset_": "utf-8"
        },
        "defaults": {
            "hideLabel": true,
            "anchor": CQ.themes.wcm.ContentFinderTab.QUERYBOX_ANCHOR,
            "stateful": false,
            "style": CQ.themes.wcm.ContentFinderTab.QUERYBOX_FIELDS_STYLE
        }
    });
    return config;
};

/**
 * <p>Returns a {@link CQ.form.SuggestField SuggestField} config object for a
 * suggest field. The specified config will be merged with defaults. In most use
 * cases the suggest field is the main field of the Suggest Box. Often it is
 * even the solely field.</p>
 * <p>The default name is "query". If it is not overwritten this field can be
 * accessed by {@link #setQueryValue} and {@link #getQueryValue}.</p>
 * <p></p>
 * @param {Object} config A {@link CQ.form.SuggestField} config object
 * @return {Object} The specified {@link CQ.form.SuggestField} config object merged with defaults
 * @static
 */
CQ.wcm.ContentFinderTab.getSuggestFieldConfig = function(config) {
    config = CQ.Util.applyDefaults(config, {
        "xtype": "suggestfield",
        "name": "query",
        // override default top margin set in CQ.wcm.ContentFinderTab#getQueryBoxConfig
        "style": "margin-top:0;",
        "onTriggerClick": function(evt) {
            // "onTriggerClick" is called when the button is clicked and as well
            // when the down arrow key is hit. Latter does not pass "evt".
            if (evt) {
                this.search();
            }
        },
        "listeners": {
            "search": function() {
                this.search();
            }
        },
        "search": function() {
            var tab = this.findParentByType("contentfindertab");
            if (tab.history) {
                tab.history.addHistory(tab.getParams(tab));
            }
            tab.submitQueryBox.call(tab, this);
        }
    });
    return config;
};

/**
 * <p>Returns a {@link CQ.Ext.form.ComboBox ComboBox} config object for a
 * specific combo box that lists the path of the search results. Typically it
 * is displayed in the {@link #CQ.Ext.Panel#tbar toolbar} of the
 * {@link #ContentFinderTab.getResultsBoxConfig Results Box}. The specified
 * config will be merged with defaults.</p>
 * @param {Object} config A {@link CQ.Ext.form.ComboBox} config object
 * @return {Object} The specified {@link CQ.Ext.form.ComboBox} config object merged with defaults
 * @static
 * @private
 */
CQ.wcm.ContentFinderTab.getPathComboConfig = function(config) {
    config = CQ.Util.applyDefaults(config, {
        "xtype": "combo",
        "mode": "local",
        "displayField": "text",
        "editable": false,
        "triggerAction": "all",
        "disabled": true,
        "cls": "cq-cft-pathcombo",
        "listClass": "cq-cft-pathcombo-list",
        "width": 131,
        "listWidth": 131,
        "store": new CQ.Ext.data.SimpleStore({
            "fields": ["value", "text"],
            "data": []
        }),
        "listeners": {
            "select": function(combo, record) {
                var tab = CQ.Ext.getCmp(config.tabId);
                CQ.wcm.ContentFinderTab.openFolder(tab, record.data.value);
            }
        }
    });
    return config;
};

/**
 * Creates and return the tree for the browse tab.
 * @static
 * @param {Object} config Config overrides
 */
CQ.wcm.ContentFinderTab.getBrowseTree = function(config, treeID, resultBoxID) {
   // configure tree root
   if (!config.treeRoot) config.treeRoot = new Object();
   this.treeRootConfig = CQ.Ext.applyIf(config.treeRoot, {
       "name":"content",
       "text": CQ.I18n.getMessage("Content"),
       "draggable": false,
       "expanded":true
   });
   // configure tree loader
   if (!config.treeLoader) config.treeLoader = new Object();
   this.treeLoaderConfig = CQ.Ext.applyIf(config.treeLoader, {
       "baseParams": {
           "predicate":"siteadmin",
           "_charset_":"utf-8"
       },
       "requestMethod":"GET",
       "dataUrl":"/content.ext.json",
       "baseAttrs": {
           "draggable":false,
           "iconCls":"folder"
       },
       "listeners": {
           "beforeload": function(loader, node) {
               this.dataUrl = node.getPath() + ".ext.json";
           }
       },
       "createNode": function(attr) {
           if (this.baseAttrs) {
               CQ.Ext.applyIf(attr, this.baseAttrs);
           }

           if (attr.type == "cq:Page") {
               attr.iconCls = "page";
           }
           else if (/.*[fF]older/.test(attr.type)) {
               // all types ending with "folder", e.g. "sling:Folder", "nt:folder"
               attr.iconCls = "folder";
           }
           else if (attr.cls) {
               attr.iconCls = attr.cls;
           }

           if (this.applyLoader !== false) {
               attr.loader = this;
           }
           if (typeof attr.uiProvider == 'string') {
               attr.uiProvider = this.uiProviders[attr.uiProvider] || eval(attr.uiProvider);
           }
           // HACK: this hack is necessary to have all entries displayed
           // as folder (without server modification)
           if (attr.leaf) {
               delete attr.leaf;
               attr.children = [];
               attr.expanded = true;
           }
           var node;
           if (attr.leaf) {
               node = new CQ.Ext.tree.TreeNode(attr);
           } else {
               node = new CQ.Ext.tree.AsyncTreeNode(attr);
           }
           return node;
       },
       "filterFn":function(dataObj) {
           if (CQ.Ext.isArray(dataObj)) {
               for (var i = 0; i < dataObj.length;) {
                   if (dataObj[i]["type"] == "dam:Asset") {
                       dataObj.splice(i, 1);
                   } else {
                       var children = dataObj[i].children;
                       if (children) {
                           var childCnt = children.length;
                           var noChildVisible = true;
                           for (var j = 0; j < childCnt; j++) {
                               if (children[j]["type"] != "dam:Asset") {
                                   noChildVisible = false;
                                   break;
                               }
                           }
                           if (noChildVisible) {
                               dataObj[i].leaf = true;
                           }
                           delete dataObj[i].children;
                       }
                       i++;
                   }
               }
           }
           return dataObj;
       }
   });
   var tree = new CQ.Ext.tree.TreePanel({
       "id":treeID,
       "lines":true,
       "animate": true,
       "enableDD": false,
       "containerScroll": true,
       "autoScroll":true,
       "split":true,
       "stateful":true,
       "region":"north",
       "height":220,
       "loader":new CQ.tree.FilteredTreeLoader(this.treeLoaderConfig),
       "root":new CQ.Ext.tree.AsyncTreeNode(this.treeRootConfig)
   });
   tree.getSelectionModel().addListener("selectionchange", (config.selectionchangeListener != null ? config.selectionchangeListener : function(selModel, node) {
       var store = CQ.Ext.getCmp(resultBoxID).items.get(0).store;
       store.proxy.api["read"].url = CQ.shared.HTTP.encodePath(node.getPath()) + ".contentfinder.assets.json";

       store.reload();
   }));
   return tree;
};

/**
 * <p>Returns a {@link CQ.Ext.Panel Panel} config object for the default Results
 * Box. The specified configs will be merged with defaults.</p>
 * @param {Object} config A {@link CQ.Ext.Panel} config object for the wrapping panel.<br>
 *                  Typically the following properties are defined:
 *                  <ul><li><code>itemsDDGroups</code> : String[]<br>
 *                  Required to enable drag and drop of result items of the ContentFinderTab
 *                  to a content page. All items of the result set will belong to
 *                  the same group.</li>
 *                  <li><code>mergeItemsDDGroups</code> : String[] <br>
 *                  When itemsDDGroups is present, it may be required that the actual dd groups from the item to be taken into account.
 *                  The mergeItemsDDGroups groups will be merged into the drag zone group when present on the item and itemsDDGroups is set.
 *                  Please note that this setting does not make sense when itemsDDGroups is not set, since then the drag zone group will always contain the item's actual groups by design.
 *                  </li>
 *                  <li><code>itemsDDNewParagraph</code> : Object<br>
 *                  Specifies which CQ component will be created if a result item is
 *                  dropped onto the content page in order to create a new paragraph.
 *                  <ul><li><code>path</code> : String<br>
 *                  The path of the component, e.g. "foundation/component/image".</li>
 *                  <li><code>propertyName</code> : String<br>
 *                  The name of the component's property that will be set, e.g. "./fileReference"</li>
 *                  </ul></li></ul>
 * @param {Object} proxyConfig A {@link CQ.Ext.data.DataProxy} config object for the proxy
 *                  of the store (see next parameter).<br>
 *                  <ul><li><code>url</code> : String<br>
 *                  Typically the url property is specified. The Query Box will be
 *                  submitted to this URL.
 * @param {Object} storeConfig A {@link CQ.Ext.data.GroupingStore} config object for the store
 * @param {String} refreshInterval (optional) The interval to refresh the results. The
 *                  refreshing feature is required to automatically show freshly uploaded files.
 *                  Use "0" to disable refreshing completely (defaults to {@link CQ#CQ.CF_REFRESH_INTERVAL CQ.CF_REFRESH_INTERVAL}).
 * @return {Object} The specified {@link CQ.Ext.Panel} config object merged with defaults
 * @static
 */
CQ.wcm.ContentFinderTab.getResultsBoxConfig = function(config, proxyConfig,
        storeConfig, refreshInterval, noRefreshButton) {

    proxyConfig = CQ.Util.applyDefaults(proxyConfig, {
        "url": "x",
        "method": "GET"
    });

    storeConfig = CQ.Util.applyDefaults(storeConfig, {
        "autoLoad": false,
        "proxy": new CQ.Ext.data.HttpProxy(proxyConfig),
        "reader": new CQ.Ext.data.JsonReader({
            "totalProperty": "results",
            "root": "hits",
            "fields": [
                "name", "path", "title", CQ.shared.XSS.getXSSPropertyName("title"), "excerpt", "mimeType", "isFolder",
                "contentType", "ddGroups", "ddNewParagraph", "size", "lastModified", "ck"
            ],
            "id": "path"
        }),
        "baseParams": {
            "_charset_": "utf-8"
        },
        "listeners": {
            "load": function(store, records, options) {
                store.records = records;
            }
        }
    });
    var dvStore = new CQ.Ext.data.GroupingStore(storeConfig);

    config = CQ.Util.applyDefaults(config, {
        "xtype": "panel",
        "region": "center",
        "autoScroll": true,
        "itemsDDGroups": [],
        "mergeItemsDDGroups": [],
        "itemsDDNewParagraph": null,
        "triggerScrollOffset": 80,
        "oneParameterPagination": true,
        "pageSize": 10,
        "listeners":{
            "render":function(comp) {
                var dataView = comp.items.get(0);
                var store = dataView.store;

                // create load indicator
                dataView.indicatorEl = comp.el.createChild({
                    "tag":"div",
                    "cls":"cq-cft-load-indicator"
                });

                // add scroll listener for pagination
                if (!config.disableContinuousLoading) {
                    comp.body.on("scroll", function(e, t) {
                        if (!store.records) {
                            //store has never been loaded before
                            return;
                        }
                        if (dataView.loading || dataView.refreshing) {
                            // loading or last refresh is still running
                            return;
                        }
                        if (t.scrollTop > 0
                            && (t.scrollTop + t.clientHeight
                                + this.triggerScrollOffset >= t.scrollHeight)
                            && !dataView.refreshing) {

                            if (!dataView.moreStore) {
                                // create a store to check for changes
                                dataView.moreStore = new CQ.Ext.data.GroupingStore({
                                    "proxy": new CQ.Ext.data.HttpProxy({
                                        "url": store.proxy.url,
                                        "method": store.proxy.conn.method
                                    }),
                                    "reader": store.reader,
                                    "listeners": {
                                        "load": function() {
                                            var index = store.getCount();
                                            for (var i = 0; i < dataView.moreStore.getCount(); i++) {
                                                var record = dataView.moreStore.getAt(i);
                                                store.add(record);
                                            }
                                            dataView.refreshing = false;
                                            dataView.indicatorEl.hide();
                                        }
                                    },
                                    "dataView": this
                                });
                            }
                            var params = store.lastOptions.params == undefined ?
                                            store.baseParams : store.lastOptions.params;

                            if (!params.query || (params.query.indexOf("limit:") == -1)) {
                                dataView.refreshing = true;

                                var moreParams = {};
                                for (var p in params) {
                                    moreParams[p] = params[p];
                                }
                                if (config.twoParametersPagination) {
                                    moreParams.limit = store.baseParam ? store.baseParam : config.pageSize;
                                    moreParams.start = store.getCount();
                                }
                                else {
                                    moreParams.limit = store.getCount() + ".." + (store.getCount() + config.pageSize);
                                }

                                dataView.indicatorEl.alignTo(comp.el, 'bl-bl?', [18, -20]);
                                dataView.indicatorEl.show();
                                dataView.moreStore.load({
                                    "params":moreParams
                                });
                            }
                        }
                    }, this);
                }
            }
        },
        "items": {
            "xtype": "dataview",
            "cls": "cq-cft-dataview",
            "layout": "fit",
            "loadingText": CQ.I18n.getMessage("Loading content..."),
            "multiSelect": true,
            "singleSelect": true,
            "overClass": "x-view-over",
            "emptyText": CQ.I18n.getMessage("No content items to display"),
            "tpl": CQ.wcm.ContentFinderTab.THUMBS_TEMPLATE,
            "itemSelector": CQ.wcm.ContentFinderTab.THUMBS_ITEMSELECTOR,
            "store": dvStore,
            "prepareData": function(data) {
                data.shortTitle = CQ.Ext.util.Format.ellipsis(data.name, 15);
                data.title = data.title ? data.title : ""; // eliminate "null"
                data[CQ.shared.XSS.getXSSPropertyName("title")] = data[CQ.shared.XSS.getXSSPropertyName("title")] ? data[CQ.shared.XSS.getXSSPropertyName("title")] : ""; // eliminate "null"
                data.id = this.id;
                data.isFolder = data.isFolder === true ? true : false;
                data.ddGroups = data.ddGroups ? data.ddGroups : CQ.wcm.ContentFinderTab.CONTENT_UNDEFINED;
                data.formattedSize = data.size ? CQ.Util.formatFileSize(data.size) : "";
                try {
                    data.lastModified = CQ.wcm.SiteAdmin.formatDate(data.lastModified);
                }
                catch(e) { }


                // depracated since 5.3
                data.img140Postfix = ".thumb.100.140.png";
                data.img70Postfix = ".thumb.50.70.png";
                data.img48Postfix = ".thumb.48.48.png";

                if (data.path) {
                    data.pathEncoded = data.path.replace(/"/g, "&#34").replace(/'/g, "&#27");
                    data.pathEncodedTitle = data.path.replace(/&/g, "&#38;").replace(/"/g, "&#34");
                }
                return data;
            },
            "listeners": {
                "click": function(dataView, index, item, e) {
                    // "changeselection" is called twice (on mousedown and -up)
                    // therefore use "click" instead

                    var records = this.getSelectedRecords();

                    // find common groups
                    var r0 = records[0];
                    
                    // dd groups defined in config: use for all
                    if (this.ddGroupsFromConfig) {
                        // make an exception for the group in the mergeItemsDDGroups array
                        if (r0
                                && r0.data
                                && r0.data.ddGroups) {
                            for (var exceptGroupsIdx = 0 ; exceptGroupsIdx < this.mergeItemsDDGroups.length ; exceptGroupsIdx ++) {
                                var groupName = this.mergeItemsDDGroups[exceptGroupsIdx];
                                var foundGroup = false;
                                
                                for (var i = 0 ; i < r0.data.ddGroups.length ; i++) {
                                    if (r0.data.ddGroups[i] == groupName) {
                                        foundGroup = true;
                                        break;
                                    }
                                }
                                
                                this.dragZone.removeFromGroup(groupName);
                                
                                if (foundGroup) {
                                    this.dragZone.addToGroup(groupName);
                                }
                            }
                        }
                        return;
                    }

                    // remove existing groups and ddNewParagraph
                    for (var g in this.dragZone.groups) {
                        this.dragZone.removeFromGroup(g);
                    }
                    this.dragZone.itemsDDNewParagraph = {};

                    if (!r0) {
                        // deselcet all
                        return;
                    }
                    if (r0.data.ddGroups) {
                        for (var i = 0; i < r0.data.ddGroups.length; i++) {
                            var group = r0.data.ddGroups[i];
                            var common = true;
                            for (var j = 1; j < records.length; j++) {
                                var rX = records[j];
                                for (var k = 0; k < rX.data.ddGroups.length; k++) {
                                    if (group == rX.data.ddGroups[k]) {
                                        // record X has "group" in common
                                        common = true;
                                        break;
                                    }
                                    common = false;
                                }
                                if (!common) {
                                    // record X does not have "group" in common -> do not add
                                    break;
                                }
                            }
                            if (common) {
                                this.dragZone.addToGroup(group);
                            }
                        }
                    }

                    if (r0.data.ddNewParagraph) {
                        var common = true;
                        for (var i = 1; i < records.length; i++) {
                            var rX = records[i];
                            if (r0.data.ddNewParagraph.path != rX.data.ddNewParagraph.path ||
                                r0.data.ddNewParagraph.propertyName != rX.data.ddNewParagraph.propertyName) {

                                common = false;
                                break;
                            }
                        }
                        if (common) {
                            this.dragZone.itemsDDNewParagraph = r0.data.ddNewParagraph;
                            this.dragZone.addToGroup(CQ.wcm.EditBase.DD_GROUP_COMPONENT);
                        }
                    }

                },
                "load": function() {
                    this.loading = false;
                },
                "render": function(dataView) {
                    if (refreshInterval == undefined) {
                        refreshInterval = CQ.CF_REFRESH_INTERVAL;
                    }
                    if (refreshInterval && refreshInterval != "0") {
                        CQ.Util.observeComponent(this, refreshInterval);
                    }

                    dataView.loadMask = new CQ.Ext.LoadMask(dataView.getEl(), {
                        "store": this.store
                    });

                    dataView.dragZone = new CQ.wcm.ContentFinderTab.DragZone(dataView, {
                        "containerScroll": false
                    });
                    dataView.dragZone.removeFromGroup(CQ.wcm.EditBase.DD_GROUP_DEFAULT);

                    if (config.itemsDDGroups && CQ.Ext.isArray(config.itemsDDGroups) && config.itemsDDGroups.length > 0) {
                        this.ddGroupsFromConfig = true;
                        for (var i = 0; i < config.itemsDDGroups.length; i++) {
                            dataView.dragZone.addToGroup(config.itemsDDGroups[i]);
                        }
                    }

                    if (config.mergeItemsDDGroups && CQ.Ext.isArray(config.mergeItemsDDGroups) && config.mergeItemsDDGroups.length > 0) {
                        this.mergeItemsDDGroups = config.mergeItemsDDGroups;
                    } else {
                        this.mergeItemsDDGroups = [];
                    }
                    
                    if (config.itemsDDNewParagraph) {
                        // create new paragraphs by dropping assets
                        dataView.dragZone.itemsDDNewParagraph = config.itemsDDNewParagraph;
                        dataView.dragZone.addToGroup(CQ.wcm.EditBase.DD_GROUP_COMPONENT);
                    }
                }
            },
            "observe": function() {
                // check for any changes on the server (files created/deleted)
                if (!this.store.records) {
                    //store has never been loaded before
                    return;
                }
                if (this.loading || this.refreshing) {
                    // loading or last refresh is still running
                    return;
                }

                if (!this.tab) {
                    this.tab = this.findParentByType("contentfindertab");
                }
                var tabPanel = CQ.Ext.getCmp(CQ.wcm.ContentFinder.TABPANEL_ID);
                if (tabPanel.getActiveTab() != this.tab) {
                    // tab not active: do not refresh
                    return;
                }

                this.refreshing = true;

                //todo: checkStore for own stores / applyDefaults
                if (!this.checkStore && this.store.proxy.api["read"].url) {
                    // create a store to check for changes
                    this.checkStore = new CQ.Ext.data.GroupingStore({
                        "proxy": new CQ.Ext.data.HttpProxy({
                            "url": this.store.proxy.api["read"].url,
                            "method": "GET"
                        }),
                        "reader": new CQ.Ext.data.JsonReader({
                            "totalProperty": "results",
                            "root": "hits",
                            "fields": [
                                "name", "path", "title", CQ.shared.XSS.getXSSPropertyName("title"), "excerpt", "mimeType", "isFolder", "ddGroups"
                            ],
                            "id": "path"
                        }),
                        "listeners": {
                            "load": function() {
                                var store = this.dataView.store;
                                var checkStore = this.dataView.checkStore;

                                var num = store.getCount();
                                for (var i = 0; i < num; i++) {
                                    var record = store.getAt(i);
                                    if (!checkStore.getById(record.id)) {
                                        store.remove(record);
                                        num--;
                                    }
                                }
                                num = checkStore.getCount();
                                for (var i = 0; i < num; i++) {
                                    var record = checkStore.getAt(i);
                                    if (!store.getById(record.id)) {
                                        store.insert(i, record);
                                    }
                                }
                                this.dataView.refreshing = false;
                            }
                        },
                        "dataView": this
                    });
                }

                // update check store URL, stores URL might be changed programmatically
                this.checkStore.proxy.api["read"].url = this.store.proxy.api["read"].url;

                // load check store with last params
                var params = this.store.lastOptions.params == undefined ?
                    this.store.baseParams : this.store.lastOptions.params;

                var checkParams = {};
                for (var p in params) {
                    checkParams[p] = params[p];
                }

                // check for limit constraints
                if (!checkParams.query || (checkParams.query.indexOf("limit:") == -1)) {
                    if (config.twoParametersPagination) {
                        moreParams.limit = this.store.baseParam ? this.store.baseParam : config.pageSize;
                        moreParams.start = 0;
                    }
                    else {
                        checkParams.limit = 0 + ".." + this.store.getCount();
                    }
                }
                this.checkStore.load({
                    "params": checkParams
                });
            }
        }
    });

    // replace string "refreshButton" in top and bottom bar by a refresh button
    try {
        for (var i = 0; i < config.tbar.length; i++) {
            if (config.tbar[i] == CQ.wcm.ContentFinderTab.REFRESH_BUTTON) {
                config.tbar[i] = CQ.wcm.ContentFinderTab.getRefreshButton(dvStore);
            }
        }
    } catch(e) { }
    try {
        for (var i = 0; i < config.bbar.length; i++) {
            if (config.bbar[i] == CQ.wcm.ContentFinderTab.REFRESH_BUTTON) {
                config.bbar[i] = CQ.wcm.ContentFinderTab.getRefreshButton(dvStore);
            }
        }
    } catch(e) { }

    return config;
};

// private
CQ.wcm.ContentFinderTab.getRefreshButton = function(store) {
    return new CQ.Ext.Button({
        "iconCls": "cq-siteadmin-refresh",
        "handler": function() {
            store.reload();
        },
        "tooltip": CQ.I18n.getMessage("Refresh")
    });
};

CQ.wcm.ContentFinderTab.resultDblClick = function(e, id, path, isFolder, ddGroups) {
    try {
        if (ddGroups != CQ.wcm.ContentFinderTab.CONTENT_UNDEFINED && !e.altKey) {
            // double click on page or asset > open
            if (ddGroups == CQ.wcm.ContentFinderTab.CONTENT_PAGE) {
                // page > open in content window
                CQ.wcm.ContentFinder.loadContentWindow(path + '.html');
            }
            else {
                // asset > open in new window
                CQ.Util.reload(window, CQ.HTTP.externalize(path, true));
            }

        }
//        else if (ddGroups == CQ.wcm.ContentFinderTab.CONTENT_PAGE && e.altKey && e.shiftKey) {
//            // [alt][shift] double click pages
//            console.log("openPars!");
//        }
        else if (isFolder) {
            // double click on folder
            // [alt] double click pages
            var dataView = CQ.Ext.getCmp(id);
            var tab = dataView.findParentByType("contentfindertab");
            CQ.wcm.ContentFinderTab.openFolder(tab, path);
        }
    }
    catch (e) { }
};

CQ.wcm.ContentFinderTab.openFolder = function(tab, path) {
    tab.setQueryValue("path:" + path);
    var params = tab.getParams();
    params["openFolder"] = "true";

    if (tab.history) {
        tab.history.addHistory(params);
    }

    CQ.wcm.ContentFinderTab.adjustPathCombo(tab, path);

    tab.loadStore(params);
};

/**
 * Splits the specified path and displays the single items in the
 * {@link CQ.wcm.ContentFinderTab#getPathComboConfig Path Combo}.
 * @param {CQ.wcm.ContentFinderTab} tab Content Finder Tab that hosts the Path Combo
 * @param {String} path The path to display
 * @private
 */
CQ.wcm.ContentFinderTab.adjustPathCombo = function(tab, path) {
    try {
        if (!tab.pathCombo && tab.pathComboId) {
            tab.pathCombo = CQ.Ext.getCmp(tab.pathComboId);
        }
        if (tab.pathCombo) {
            var data = [];
            var currentPath = path;
            while (currentPath.lastIndexOf("/") != 0) {
                currentPath = currentPath.substring(0, currentPath.lastIndexOf("/"));
                var name = currentPath.substring(currentPath.lastIndexOf("/") + 1);
                data.push([
                    currentPath,
                    name ? name : "/"
                ]);
            }
            tab.pathCombo.store.loadData(data);
            tab.pathCombo.setDisabled(false);
            tab.pathCombo.setValue(path.substring(path.lastIndexOf("/") + 1));
        }
    }
    catch (e) {
//        console.log(e.message);
    }
};

/**
 * Disables the {@link CQ.wcm.ContentFinderTab#getPathComboConfig Path Combo}.
 * @param {CQ.wcm.ContentFinderTab} tab Content Finder Tab that hosts the Path Combo
 * @private
 */
CQ.wcm.ContentFinderTab.disablePathCombo = function(tab) {
    if (!tab.pathCombo && tab.pathComboId) {
        tab.pathCombo = CQ.Ext.getCmp(tab.pathComboId);
    }
    if (tab.pathCombo) {
        tab.pathCombo.setValue("");
        tab.pathCombo.setDisabled(true);
    }
};

/**
 * The default {@link CQ.Ext.DataView#itemSelector itemSelector} for the
 * {@link #ContentFinderTab.THUMBS_TEMPLATE default thumbnails data view}.
 * @static
 * @final
 * @type String
 */
CQ.wcm.ContentFinderTab.THUMBS_ITEMSELECTOR = ".thumb-wrap";


/**
 * The {@link CQ.Ext.Template template} of the default thumbnails data view.
 * Note, that the extjs quick tips (ext:qtip) attribute must be html encoded
 * twice in order to be protected against XSS attacks. (CQ5-28053)
 * @static
 * @final
 * @type String
 */
CQ.wcm.ContentFinderTab.THUMBS_TEMPLATE =
    '<tpl for=".">' +
        '<div class="thumb-wrap">' +
        '<div class="thumb"' +
        ' style="background-image:url(\'{[CQ.wcm.ContentFinderTab.THUMBS_URL(values)]}\');"' +
        ' ondblclick="CQ.wcm.ContentFinderTab.resultDblClick(event, \'{id}\',\'{pathEncoded}\',{isFolder},\'{ddGroups}\');"' +
        ' ext:qtip="<nobr>{[CQ.shared.XSS.getXSSValue(CQ.shared.XSS.getXSSValue(values.title))]}</nobr>{[values.title ? "<br/>" : ""]}<nobr>{[CQ.shared.XSS.getXSSValue(CQ.shared.XSS.getXSSValue(values.name))]}</nobr>"' +
        '></div>' +
        '<span>{[CQ.shared.XSS.getXSSValue(values.shortTitle)]}</span>' +
        '</div>' +
        '</tpl>' +
        '<div class="x-clear"></div>';

/**
 * Helper function that is responsible for creating the URL for a thumbnail from
 * {@link CQ.wcn.ContentFinderTab#THUMBS_TEMPLATE}.
 * @param {Object} values The value object
 * @return {String} The URL
 * @private
 * @since 5.6
 */
CQ.wcm.ContentFinderTab.THUMBS_URL = function(values, width, height) {
	
    width = (width ? width : 100);
    height = (height ? height : 140);
    
    //update thumbnail reference for sets
    if(values.mimeType.indexOf('Multipart/Related') == 0) {
		values.path += '.folderthumbnail.jpg';
    }
    
    // encode path not in externalize - otherwise "#" in asset name or path is not encoded
    var externalized = CQ.HTTP.externalize(CQ.shared.XSS.getXSSValue(
            CQ.HTTP.encodePath(values.path)));
    externalized += ".thumb." + width + "." + height + (values.ck ? "." + values.ck : "")
            + ".png";
    return CQ.shared.HTTP.getXhrHookedURL(externalized);
};

/**
 * The default {@link CQ.Ext.DataView#itemSelector itemSelector} for the
 * {@link #ContentFinderTab.THUMBS_SHADOW_TEMPLATE thumbnails with shadow data view}.
 * @static
 * @final
 * @type String
 * @since 5.4
 */
CQ.wcm.ContentFinderTab.THUMBS_SHADOW_ITEMSELECTOR = ".thumb-sh-wrap";


/**
 * The {@link CQ.Ext.Template template} of the thumbnails with shadow data view.
 * Note, that the extjs quick tips (ext:qtip) attribute must be html encoded
 * twice in order to be protected against XSS attacks. (CQ5-28053)
 * @static
 * @final
 * @type String
 * @since 5.4
 */
CQ.wcm.ContentFinderTab.THUMBS_SHADOW_TEMPLATE =
    '<tpl for=".">' +
        '<div class="thumb-sh-wrap">' +
        '<table class="thumb""><tr>' +
        '<td><table><tr><td><img src="{[CQ.wcm.ContentFinderTab.THUMBS_URL(values)]}"' +
        ' ondblclick="CQ.wcm.ContentFinderTab.resultDblClick(event, \'{id}\',\'{pathEncoded}\',{isFolder},\'{ddGroups}\');"' +
        ' ext:qtip="<nobr>{[CQ.shared.XSS.getXSSValue(CQ.shared.XSS.getXSSValue(values.title))]}</nobr>{[values.title ? "<br/>" : ""]}<nobr>{[CQ.shared.XSS.getXSSValue(CQ.shared.XSS.getXSSValue(values.name))]}</nobr>"' +
        '></td></tr></table></td>' +
        '</tr></table>' +
        '<span>{[CQ.shared.XSS.getXSSValue(values.shortTitle)]}</span>' +
        '</div>' +
        '</tpl>' +
        '<div class="x-clear"></div>';


/**
 * The default {@link CQ.Ext.DataView#itemSelector itemSelector} for the
 * {@link #ContentFinderTab.DETAILS_TEMPLATE default details data view}.
 * @static
 * @final
 * @type String
 */
CQ.wcm.ContentFinderTab.DETAILS_ITEMSELECTOR = ".cq-cft-search-item";

/**
 * The {@link CQ.Ext.Template template} of the details data view with shadow.
 * Note, that the extjs quick tips (ext:qtip) attribute must be html encoded
 * twice in order to be protected against XSS attacks. (CQ5-28053)
 * @static
 * @final
 * @type String
 */
CQ.wcm.ContentFinderTab.DETAILS_SHADOW_TEMPLATE =
    '<tpl for=".">' +
        '<div class="cq-cft-search-item" ondblclick="CQ.wcm.ContentFinderTab.resultDblClick(event, \'{id}\', \'{pathEncoded}\', {isFolder}, \'{ddGroups}\');">' +
        '<div class="cq-cft-search-thumb">' +
        '<table><tr><td>' +
        '<img alt="{[CQ.shared.XSS.getXSSValue(values.pathEncoded)]}" src="{[CQ.wcm.ContentFinderTab.THUMBS_URL(values, 48, 48)]}">' +
        '</td></tr></table>' +
        '</div>' +
        '<div class="cq-cft-search-text-wrapper">' +
        '<div class="cq-cft-search-title">{[CQ.shared.XSS.getXSSValue(values.name)]}</div>' +
        '{[values.title ? "<div>" + CQ.shared.XSS.getXSSValue(values.title) + "</div>" : ""]}' +
        '<div>{[CQ.shared.XSS.getXSSValue(values.formattedSize)]}</div>' +
        '<div>{[CQ.shared.XSS.getXSSValue(values.lastModified)]}</div>' +
        '</div>' +
        '<div class="cq-cft-search-separator"></div>' +
        '</div>' +
        '</tpl>';


/**
 * The default {@link CQ.Ext.DataView#itemSelector itemSelector} for the
 * {@link #ContentFinderTab.DETAILS_SHADOW_TEMPLATE details data view with shadow}.
 * @static
 * @final
 * @type String
 * @since 5.4
 */
CQ.wcm.ContentFinderTab.DETAILS_SHADOW_ITEMSELECTOR = ".cq-cft-search-item";

/**
 * The {@link CQ.Ext.Template template} of the default details data view.
 * Note, that the extjs quick tips (ext:qtip) attribute must be html encoded
 * twice in order to be protected against XSS attacks. (CQ5-28053)
 * @static
 * @final
 * @type String
 * @since 5.4
 */
CQ.wcm.ContentFinderTab.DETAILS_TEMPLATE =
    '<tpl for=".">' +
        '<div class="cq-cft-search-item" ondblclick="CQ.wcm.ContentFinderTab.resultDblClick(event, \'{id}\', \'{pathEncoded}\', {isFolder}, \'{ddGroups}\');">' +
        '<div title="{[CQ.shared.XSS.getXSSValue(values.pathEncodedTitle)]}" class="cq-cft-search-thumb" style="background-image:url(\'{[CQ.wcm.ContentFinderTab.THUMBS_URL(values, 48, 48)]}\');"></div>' +
        '<div class="cq-cft-search-text-wrapper">' +
        '<div class="cq-cft-search-title">{[CQ.shared.XSS.getXSSValue(values.name)]}</div>' +
        '{[values.title ? "<div>" + CQ.shared.XSS.getXSSValue(values.title) + "</div>" : ""]}' +
        '<div>{[CQ.shared.XSS.getXSSValue(values.formattedSize)]}</div>' +
        '<div>{[CQ.shared.XSS.getXSSValue(values.lastModified)]}</div>' +
        '</div>' +
        '<div class="cq-cft-search-separator"></div>' +
        '</div>' +
        '</tpl>';

CQ.wcm.ContentFinderTab.CONTENT_UNDEFINED = "";

CQ.wcm.ContentFinderTab.CONTENT_PAGE = "page";

/**
 * In {@link #ContentFinderTab.getResultsBoxConfig getResultsBoxConfig}
 * this string will be replaced in the config of {@link CQ.Ext.Panel#tbar} and
 * {@link CQ.Ext.Panel#bbar} by a refresh button.
 * @static
 * @final
 * @type String
 * @since 5.4
 */
CQ.wcm.ContentFinderTab.REFRESH_BUTTON = "refreshButton";


/**
 * Drag and drop
 * @private
 */
CQ.wcm.ContentFinderTab.DragZone = CQ.Ext.extend(CQ.wcm.ContentFinderDragZone, {
    constructor: function(view, config) {
        this.view = view;
        CQ.wcm.ContentFinderTab.DragZone.superclass.constructor.call(this, view.getEl(), config);
    },

    /**
     * Inits the drags and builds the proxy.
     * @see CQ.Ext.dd.DragZone#onInitDrag
     * @private
     */
    onInitDrag: function(x, y) {
        CQ.wcm.EditBase.DragZone.superclass.onInitDrag.call(this, x, y);
        var dz = this;
        this.flashDropTargetsCheck = window.setInterval(function() {
            if (!dz) return;
            var m = dz.mouse;
            var now = new Date().valueOf();
            if (m && dz.matchRange(m.pos, m.lastPos) &&
                (now - m.time) > 2000) {
                dz.flashDropTargets(CQ.WCM.altKey);
                m.time = now;
            } else {
                dz.normalizeDropTargets();
            }
            m.lastPos = m.pos;
        }, 500);
    },

    getDragData : function(e) {
        //debugger;
        var target = e.getTarget(this.view.itemSelector);

        if (target) {
            var view = this.view;
            if (!view.isSelected(target)) {
                view.onClick(e);
            }
            var selNodes = view.getSelectedNodes();
            var selRecords = view.getSelectedRecords();
            var dragData = {
                nodes:selNodes,
                records:selRecords
            };
            if (selNodes.length == 1) {
                // single item
                this.initialxy = CQ.Ext.Element.fly(target.firstChild).getXY();

                dragData.ddel = CQ.DOM.prepareForCloning(target.firstChild, true).cloneNode(true);
                dragData.ddel.className += " cq-cft-ddproxy";
                dragData.single = true;
            } else {
                // multiple items
                var div = document.createElement('div'); // create the multi element drag "ghost"
                // todo: div width/height depending on template (?)
                div.style.width = (
                    CQ.themes.wcm.ContentFinderTab.DDPROXY_MULTI_OFFSET * (selNodes.length - 1) +
                        CQ.themes.wcm.ContentFinderTab.DDPROXY_WIDTH) + "px";
                div.style.height = (
                    CQ.themes.wcm.ContentFinderTab.DDPROXY_MULTI_OFFSET * (selNodes.length - 1) +
                        CQ.themes.wcm.ContentFinderTab.DDPROXY_HEIGHT) + "px";

                for (var i = 0, len = selNodes.length; i < len; i++) {
                    var clone = CQ.DOM.prepareForCloning(selNodes[i].firstChild, true).cloneNode(true);
                    clone.className += " cq-cft-ddproxy";
                    clone.style.position = "absolute";
                    var offset = i * CQ.themes.wcm.ContentFinderTab.DDPROXY_MULTI_OFFSET;
                    clone.style.left =
                        (CQ.themes.wcm.ContentFinderTab.DDPROXY_PADDING_LEFT + offset) + "px";
                    clone.style.top =
                        (CQ.themes.wcm.ContentFinderTab.DDPROXY_PADDING_TOP + offset) + "px";
                    div.appendChild(clone);
                }
                dragData.ddel = div;
                dragData.multi = true;
            }
            return dragData;
        }
        return null;
    },

    // the default action is to "highlight" after a bad drop
    // but since an image can't be highlighted, let's frame it
    afterRepair:function() {
        for (var i = 0, len = this.dragData.nodes.length; i < len; i++) {
//            CQ.Ext.fly(this.dragData.nodes[i]).frame('#8db2e3', 1);
        }
        this.dragging = false;
    },

    // override the default repairXY with one offset for the margins and padding
    getRepairXY : function(e) {
        if (!this.dragData.multi) {
            this.initialxy[0] += 3;
            this.initialxy[1] += 3;
            return this.initialxy;
        }
        return false;
    },

    onInvalidDrop: function(dropTarget, e) {
        CQ.wcm.ContentFinderTab.DragZone.superclass.onInvalidDrop.call(this, dropTarget, e);
        this.clearAnimations(dropTarget);
    },

    clearAnimations: function(dropTarget, keepTarget) {
        if (dropTarget) {
            if (dropTarget.hideHighlight) {
                dropTarget.hideHighlight();
            }
            if (!keepTarget && dropTarget.editComponent && dropTarget.editComponent.hideTarget) {
                dropTarget.editComponent.hideTarget();
            }
        }

        this.normalizeDropTargets();
        window.clearInterval(this.flashDropTargetsCheck);
    },

    notifyDropDT: function(dropTarget, e, data) {
        var ret = false;

        if (this.isInplaceEditingComponent(dropTarget)) {
            this.clearAnimations(dropTarget);
            if (this.isInplaceEditingDropAllowed(dropTarget)) {
                dropTarget.editComponent.notifyInplaceEditingDrop(this);
                return true;
            }
        }

        if (this.isDropAllowed(dropTarget, (e && e.altKey))) {
            var editComponent = dropTarget.editComponent;
            if (!this.isInsertOnlyComponent(dropTarget) && e && !e.altKey) {
                this.clearAnimations(dropTarget);
                var values = [];
                for (var i = 0; i < this.dragData.records.length; i++) {
                    values.push(this.dragData.records[i].data.path);
                }
                var propertyName = dropTarget.propertyName;
                var postParams = dropTarget.postParams;
                // Add in post params using values from drag data, if parameter is prefixed.
                for (var p in postParams) {
                	if (p.indexOf("./DRAG_RECORD_") == 0) {
	                	var trunc = p.substring(14); // chop the ./DRAG_RECORD_
	                	for (i = 0; i < this.dragData.records.length; i++) {
	                		if (this.dragData.records[i].data[trunc] != undefined && this.dragData.records[i].data[trunc] != "") {
	                			postParams["./"+trunc] = this.dragData.records[i].data[trunc];
	                		} else {
	                			postParams["./"+trunc] = ""; // prior values are blanked out
	                		}
	                	}
                	}
                }
                // drop without holding alt key: replace content
                window.setTimeout(function() {
                    var contentWin = CQ.WCM.getContentWindow();
                    var data = null;
                    var uu = contentWin.CQ.undo.util.UndoUtils;
                    var um = contentWin.CQ.undo.UndoManager;
                    if (um.isEnabled()) {
                        data = uu.getCurrentData(editComponent);
                    }
                    editComponent.updateParagraph(propertyName, values, postParams);
                    // handle undo if necessary
                    if (um.isEnabled()) {
                        var changedData = { };
                        changedData[propertyName] = values;
                        // resolve multivalue placeholder (i.e., "./image$/file")
                        var resolvedProperties = uu.resolveMultiValuePlaceholder(
                            changedData);
                        var originalData = { };
                        var propCnt = resolvedProperties.length;
                        var originalParameters = uu.jsonToSlingParameters(data.data);
                        for (var p = 0; p < propCnt; p++) {
                            propertyName = resolvedProperties[p].property;
                            originalData[propertyName] = originalParameters[propertyName];
                            if (resolvedProperties[p].resolved) {
                                // ensure that the last modified information gets
                                // updated on each undo/redo
                                var sepPos = propertyName.lastIndexOf("/");
                                if (sepPos > 0) {
                                    var prefix = propertyName.substring(0, sepPos);
                                    originalData[prefix + "/jcr:lastModified"] = "";
                                    originalData[prefix + "/jcr:lastModifiedBy"] = "";
                                    changedData[prefix + "/jcr:lastModified"] = "";
                                    changedData[prefix + "/jcr:lastModifiedBy"] = "";
                                }
                            }
                        }
                        // merge extra parameters (resourceType; type-specific data like
                        // rotate, crop, map; etc.)
                        for (var key in postParams) {
                            if (postParams.hasOwnProperty(key)) {
                                if (originalParameters[key]) {
                                    originalData[key] = originalParameters[key];
                                } else {
                                    originalData[key] = "";
                                }
                                changedData[key] = postParams[key];
                            }
                        }
                        var undoHistory = um.getHistory();
                        var undoStep = undoHistory.createUndoStep(undoHistory
                            .createStepConfig());
                        var formStub = new contentWin.CQ.undo.util.FormStub();
                        var compType = editComponent.getResourceType();
                        undoStep.addUndoAction(
                            new contentWin.CQ.undo.actions.UpdateParagraphAction(
                                undoHistory.getIdManager(), editComponent.path,
                                compType, originalData, changedData, formStub));
                        undoStep.commit();
                    }
                }, 1);
                ret = true;
            }

            if (this.isInsertOnlyComponent(dropTarget) || (e && e.altKey)) {
                this.clearAnimations(dropTarget, true);
                var msg = CQ.I18n.getMessage("Inserting paragraph...");
                editComponent.maskTarget(msg);

                var definition = CQ.WCM.getComponentConfig(this.itemsDDNewParagraph.path);
                if (definition) {
                    var params = {};
                    if (this.itemsDDNewParagraph.params) {
                        for (var p in this.itemsDDNewParagraph.params) {
                            params[p] = this.itemsDDNewParagraph.params[p];
                        }
                    }

                    var paramsArray = [];
                    for (var i = 0; i < this.dragData.records.length; i++) {
                        var p = CQ.utils.Util.copyObject(params);
                        p[this.itemsDDNewParagraph.propertyName] = this.dragData.records[i].data.path;
                        paramsArray.push(p);
                    }

                    // drop while holding alt key: create new paragraph
                    window.setTimeout(function() {
                        for (var i = 0; i < paramsArray.length; i++) {
                            editComponent.createParagraph(definition, paramsArray[i]);
                        }
                        editComponent.hideTarget();
                    }, 1);
                    ret = true;
                }
            }
        }

        this.clearAnimations(dropTarget, true);

        return ret;
    },

    notifyEnterDT: function(dropTarget, e) {
        if (this.isDropAllowed(dropTarget, (!e || e.altKey))) {
            if (this.isInsertOnlyComponent(dropTarget) || (e && e.altKey)) {
                if (dropTarget.editComponent) {
                    dropTarget.editComponent.showTarget();
                }
                dropTarget.hideHighlight();
            } else {
                dropTarget.showHighlight();
            }
        }
        return '';
    },

    notifyOutDT: function(dropTarget, e) {
        if (dropTarget.editComponent) {
            dropTarget.editComponent.hideTarget(true);
        }
        dropTarget.hideHighlight();
        return '';
    },

    notifyOverDT : function(dropTarget, e) {
        var isDropAllowed = this.isDropAllowed(dropTarget, (!e || e.altKey));
        if (isDropAllowed) {
            if (this.isInsertOnlyComponent(dropTarget) || (e && e.altKey)) {
                if (dropTarget.editComponent) {
                    dropTarget.editComponent.showTarget();
                }
                dropTarget.hideHighlight();
            } else {
                if (dropTarget.editComponent) {
                    dropTarget.editComponent.hideTarget();
                }
            }
        }

        return isDropAllowed ? this.dropAllowed : this.dropNotAllowed;
    },

    isDropAllowed: function(dropTarget, altKey) {
        // handle inplace editing first
        if (this.isInplaceEditingComponent(dropTarget)) {
            return this.isInplaceEditingDropAllowed(dropTarget);
        }
        // special case: column break and new paragraphs, regardless of altKey
        if (this.isInsertOnlyComponent(dropTarget)) {
            return this.isComponentDropAllowed(dropTarget);
        }
        // special case: altKey param not provided.
        if (altKey == undefined) {
            return (this.isNonComponentDropAllowed(dropTarget) || this.isComponentDropAllowed(dropTarget));
        }

        return (altKey !== true ? this.isNonComponentDropAllowed(dropTarget) : this.isComponentDropAllowed(dropTarget));
    },

    isInplaceEditingComponent: function(dropTarget) {
        var contentWin = CQ.WCM.getContentFinder().getContentWindow();
        var ipeComp = window.CQ_inplaceEditComp || contentWin.CQ_inplaceEditComp;
        return (dropTarget.editComponent && (ipeComp === dropTarget.editComponent));
    },

    isInplaceEditingDropAllowed: function(dropTarget) {
        return dropTarget.editComponent.isInplaceEditingDropAllowed(this);
    },

    isInsertOnlyComponent: function(dropTarget) {
        return dropTarget.editComponent && dropTarget.editComponent.isActionInsertOnly();
    },

    isNonComponentDropAllowed: function(dropTarget) {
        if (dropTarget && dropTarget.groups) {
            var excludeObj = {};
            excludeObj[CQ.wcm.EditBase.DD_GROUP_COMPONENT] = true;
            //if no accept property or if not accepting everything
            if (CQ.Util.isIntersecting(this.groups, dropTarget.groups, excludeObj)) {
                var mimeType = this.dragData.records[0].data.mimeType;
                if (mimeType && dropTarget.ddAccept && dropTarget.ddAccept.indexOf("*") == -1) {
                    return CQ.Util.isAcceptedMimeType(dropTarget.ddAccept, mimeType);
                } else {
                    return true;
                }
            }
        }
        return false;
    },

    isComponentDropAllowed: function(dropTarget) {
        return dropTarget &&
            dropTarget.groups &&
            dropTarget.groups[CQ.wcm.EditBase.DD_GROUP_COMPONENT] &&
            this.itemsDDNewParagraph &&
            this.itemsDDNewParagraph.path &&
            dropTarget.editComponent &&
            dropTarget.editComponent.isInsertAllowed(this.itemsDDNewParagraph.path);
    },

    flashDropTargets: function(altKey) {
        if (!this.dropTargetsHighlighted) {
            //var excludeObj = {};
            //excludeObj[CQ.wcm.EditBase.DD_GROUP_COMPONENT] = true;
            for (var i = 0; i < this.dropTargets.length; i++) {
                //if no accept property or if not accepting everything
                // if(!CQ.Util.isIntersecting(this.groups, this.dropTargets[i].groups, excludeObj)) {
                if (!this.isDropAllowed(this.dropTargets[i], altKey)) {
                    // filter unrelated DD groups
                    continue;
                }
                if (this.dropTargets[i] == this.cachedTarget) {
                    // don't highlight the drop target we're over
                    continue;
                }
                this.dropTargets[i].flash();
            }
            this.dropTargetsHighlighted = true;
        }
    },

    normalizeDropTargets: function() {
        for (var i = 0; i < this.dropTargets.length; i++) {
            this.dropTargets[i].normalize();
            //if (this.dropTargets[i] != this.cachedTarget) {
            //  this.dropTargets[i].hideHighlight();
            //}
        }
        this.dropTargetsHighlighted = false;
    },

    onDragCancel: function(e, dropTarget) {
        this.clearAnimations(dropTarget);
    }

});

