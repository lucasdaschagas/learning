/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2012 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE: All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproducxtion of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */
(function (document, $) {

    "use strict";

    var SV_SEGMENT_CIRCLE_BEGIN = "sv-segmenthandle-circle-begin";
    var SV_SEGMENT_CIRCLE_END = "sv-segmenthandle-circle-end";
    var SV_SEGMENT_CIRCLE = "sv-segmenthandle-circle";
    var SV_TIMELINESEGMENTBODY = "sv-timelinesegmentbody";

    var SV_TIMELINE_PLAYBACK_MARKER_CL = "sv-timeline-playbackmarker";
    var SV_TIMELINE_PLAYBACK_MARKER_TOP_CL = "sv-timeline-playbackmarker-top";
    var SV_DRAG_CONTENT_CL = "sv-dragcontent";
    var SV_TIMELINEHEADER_CL = "sv-timelineheader";
    var SV_VIDEO_STATUS_CL = "sv-videostatus";
    var SV_TIMELINE_PRODUCT_BODY_CL = "sv-timelineproductbody";
    var SV_TIMELINE_PRODUCT_BODY_LIST_CL = "foundation-collection foundation-layout-list list";
    var SV_TIMELINESEGMENTCONTAINER_CL = "sv-timelinesegmentcontainer";
    var SV_TIMELINE_PRODUCT_HEADER_CL = "sv-timelineproductheader";
    var SV_TIMELINE_CONTENT_CL = "sv-timelinecontent";
    var SV_TIMELINESEGMENTS_CL = "sv-timelinesegments";
    var SV_SEGMENT_TIME_LABEL = "sv-segmenttimelabel";
    var SV_TIMELINESLIDERLABEL_CL = "sv-timelinesliderlabel";
    var SV_TIMELINESLIDER_CL = ".sv-timelineslider";
    var SV_PRESET_PREVIEW_CL = "sv-presetpreview";

    var SV_ASSET_PRESET_PREVIEW = "#asset-preset-preview";
    var SV_ASSET_PREVIEW_INFO_ID = '#asset-preview-info';
    //confirmation modal
    var SV_CONFIRMATION = '#svideo-confirmation',
        SV_CONFIRMATION_OK = '#svideo-confirmation-ok',
        SV_CONFIRMATION_CANCEL = '#svideo-confirmation-cancel';
    var SV_CONTENT = "#content";
    var SV_ASSET_PREVIEW = "#asset-preview";
    // select preset popover
    var SV_SELECTPRESET = '#svideo-selectpreset';
    // preset preview modal
    var SV_PREVIEW = '#svideo-presetpreview',
        // dialog = header + viewer
        SV_PREVIEW_DIALOG = SV_PREVIEW + " > div:nth-child(2)", //coral dialog wrapper
        SV_PREVIEW_HEADER = SV_PREVIEW + " > div:nth-child(2) > div", // coral dialog header
        SV_PREVIEW_VIEWER = SV_PREVIEW + " coral-dialog-content > div:nth-child(1)";  // coral dialog content > sv-presetpreview first div

    var SV_BTN_SAVE = "#btn-save";
    var SV_BTN_DELETE = "#btn-deleteproduct";
    var SV_BTN_SPLIT = "#btn-splitsegment";
    var SV_BTN_MERGE = "#btn-mergesegment";
    var SV_BTN_ADDSEGMENT = "#btn-addsegment";
    var SV_BTN_CANCEL = "#btn-cancel";
    var SV_BTN_PLAYPAUSE = "#btn-playpause";
    var SV_BTN_PLAY = "#btn-play";
    var SV_BTN_PAUSE = "#btn-pause";
    var SV_BTN_MULTI_SELECT = "#btn-multiselect";
    var SV_TIMELINE_RESOLUTION_LABEL = "#sv-timelinesliderlabel";
    var SV_BTN_PREVIEW = "#btn-preview";
    var SV_BTN_SELECTPRESET = "#btn-selectpreset";
    var SV_PRESET_POPOVER = "+ coral-popover";
    var SV_VIDEO_EDITOR_TIME = "#asset-preview_videoTime";
    var SV_VIDEO_EDITOR_SCRUBBER_TIME = "#asset-preview_videoScrubberTime";

    var ASSET_INFO_ID = '#asset-info';
    var BTN_UNDO = "#btn-undo";
    var BTN_REDO = "#btn-redo";

    //selectors
    var SV_PERIOD = ".";
    var SV_DRAG_CONTENT = SV_PERIOD + SV_DRAG_CONTENT_CL;
    var SV_TIMELINESEGMENTS = SV_PERIOD + SV_TIMELINESEGMENTS_CL;
    var SV_TIMELINE_CONTENT = SV_PERIOD + SV_TIMELINE_CONTENT_CL;
    var SV_TIMELINEHEADER = SV_PERIOD + SV_TIMELINEHEADER_CL;
    var SV_VIDEO_STATUS = SV_PERIOD + SV_VIDEO_STATUS_CL;
    var SV_TIMELINE_PRODUCT_BODY =  SV_PERIOD + SV_TIMELINE_PRODUCT_BODY_CL;
    var SV_TIMELINE_PRODUCT_HEADER =  SV_PERIOD + SV_TIMELINE_PRODUCT_HEADER_CL;
    var SV_PRESET_PREVIEW = SV_PERIOD + SV_PRESET_PREVIEW_CL;
    var SV_TIMELINE_SEGMENTS = SV_PERIOD + SV_TIMELINESEGMENTS_CL;
    var SV_TIMELINE_SEGMENT_CONTAINER = SV_PERIOD + SV_TIMELINESEGMENTCONTAINER_CL;
    var SV_TIMELINE_SEGMENT_CONTAINER_SELECTED = SV_PERIOD + SV_TIMELINESEGMENTCONTAINER_CL + ".selected";
    var SV_TIMELINE_SLIDER_LABEL = SV_PERIOD + SV_TIMELINESLIDERLABEL_CL;
    var SV_TIMELINE_SLIDER = SV_PERIOD + SV_TIMELINESLIDER_CL;
    var SV_TIMELINE_PLAYBACK_MARKER = SV_PERIOD + SV_TIMELINE_PLAYBACK_MARKER_CL;
    var ASSET_LIST_ID = '#assetList';
    var ASSET_LIST_OVERLAY_ID = "#assetListOverlay";
    var ASSET_LIST_MASONRY_SELECTOR = ASSET_LIST_ID + ' > coral-masonry';
    var MASONRY_ITEM_SELECTOR = 'coral-masonry-item';
    var ASSET_LIST_MASONRY_ITEM_SELECTOR = ASSET_LIST_MASONRY_SELECTOR + ' > ' + MASONRY_ITEM_SELECTOR;
    var SV_VIEWERAREA = ".s7sv-viewerarea";
    var SV_TIMELINE = ".sv-timeline";
    //properties
    var SV_ZERO_SEGMENT = "sv-segment-0";
    var SV_S7DURATION = "s7duration";
    var SV_TIME = "time";
    var SV_RIGHT = "right";
    var SV_LEFT = "left";
    var SV_CLICK = "click";
    var SV_DISABLED_PROPERTY = "disabled";
    var SV_BEGIN = "begin";
    var SV_END = "end";
    var SV_DIV = "<div></div>";
    var SV_DRAG_BEGIN = "drag_begin";
    var SV_DRAG_END = "drag_end";
    var SV_DRAG_TYPE = "dragtype";
    var SV_SECONDS_ABBV = "s";
    var SV_PRESET_SELECTION = "s7preset-selection";
    //events
    var SV_EVENT_SEGMENT_SELECTED = "sv-segment-selected";
    var SV_TIMELINE_SELECTED = "sv-timeline-selected";
    var SV_EVENT_SEGMENT_UNSELECTED =  'sv-segment-unselected';
    var SV_EVENT_MULTI_SEGMENT_SELECTED = 'sv-multi-segment-selected';
    var SV_EVENT_TIMELINE_ASSET_SELECTED = 'sv-timeline-asset-selected';
    var SV_DATA_READY = "sv-data-ready";
    var SV_SEGMENT_DATA_READY = "sv-segment-data-ready";
    var SV_VIDEO_PLAYER_READY = "sv-videoplayer-ready";
    var	SV_MODIFY_SEGMENT = "sv-modify-segment";
    var SV_VIDEO_STATUS_EVENT = "on_videostate_change";
    var SV_EVENT_SEGMENT_DATA_CHANGED = "sv-data-change";
    var SV_PRODUCT_ROW_DELETED = "sv-product-row-deleted";
    var SV_UNDO_CLICKED = "sv-undo";
    var SV_REDO_CLICKED = "sv-redo";
    var SV_CHANGE = "change";
    var SV_HISTORY_POSITION_CHANGE = "sv-history-position-change";
    var SV_VIDEO_CURRENT_TIME_EVENT = "sv-video-current-time-event";
    var SV_VIDEO_SEEK_EVENT = "sv-video-seek-event";
    var SV_PRESET_DATA_READY = 'sv-preset-data-ready';
    var SV_PRESET_SELECTED = 'sv-preset-selected';
    var SV_PRESET_SHOW_PREVIEW = 'sv-preset-show-preview';
    var SV_PRESET_PREVIEW_READY = 'sv-preset-preview-ready';
    var SV_RESOLUTION_CHANGE = "sv-resolution-change";
    // data
    // key for saving in video asset metadata in CRX
    var DATA_PRESET_METADATA_KEY = "shoppablevideo_viewerpreset";
    // internal key for preset list data
    var DATA_PRESET_LIST_KEY = "viewerpresetlist";

    var REBUILD_TIMEOUT = -1;

    // HTML pages
    var BASE_REDIRECT_URL = Granite.HTTP.externalize('/assets.html');
    var BASE_REDIRECT_SUFFIX = "/content/dam";
    //this is the current selected segment object
    var SELECTED_TIMELINE_DIV = null;
    var SELECTED_TIMELINE_DIV_POS = -1;
    //this is a hash of selected elements for 'merge' segment
    var selectedTimelineSegments = [];
    var prevSelectedIds = [];
    var prevSelectedRowURL = "";
    var dragArea = null;
    var segments = [];
    var videoPlayer = null;
    var curPresetData = null;	// current preset selection for preview
    var _currentResolution = 5;
    var _initialWidth = 0;
    var _initialResolution = 5;
    var _percentOfChange = 0;
    var _defMaxSecondWidth = 200;
    var _sliderControl = null;
    var _min_merge_amount = 1;

    var MULTI_SELECT_MODE = false;
    /**
     *  Shoppable Video controller class
     */
    $(document).one("foundation-contentloaded", function (e) {

        removeWizardControls();
        // WORK-AROUND: it may be a granite issue or by design. The "backdrop" attribute of the foundation/dialog has
        // been hardcoded to static.  This prevents closing the preview dialog by clicking on the backdrop.
        document.querySelector(SV_PREVIEW).setAttribute("backdrop", "modal");

        // WORK-AROUND: this is a granite gap. The support for the "displaymode" attribute of the cyclebutton has not
        // been implemented.  This prevents the Play/Pause button for showing both text and icon.
        document.querySelector(SV_BTN_PLAYPAUSE).setAttribute("displaymode", "icontext");

        // WORK-AROUND: pulldown hides the select preset button by default because the preset items were not implemented
        // directly under the pull down list.  They were implemented as "sub-list" item inside a container as the first
        // item of the pull down list.  By default, pull down hides the button because container is not an instance of
        // Coral.AnchorList.Item
        if (document.querySelector(SV_BTN_SELECTPRESET).show) {
            document.querySelector(SV_BTN_SELECTPRESET).show();
        }

        //setup the default current resolution based on the length of video
        setCurrentResolution(
            calculateSliderDefault()
        );

        // Manually hide the assetPicker since it uses granite container instead of granite dialog.
        // TODO: Will refactor later
        hideAssetPicker();

        // instantiate the OOTB Video Viewer - this is in videopreview
        createVideoViewer("asset-preview");
        initScreen();
        setupSlider();

        /**
         * Shoppable Video Timeline methods
         */
        /**
         * buildSegments is used to build the timeline segments from the existing VTT
         * data. It parses the JSON object passed
         * @param jsn
         */
        function buildSegments(jsn) {

            addPlaybackMarker();

            var i, t0, t1, segDOM, seg, iter, pos;
            iter = 0;
            for (i = 0; i <= jsn.length; i++) {
                if (jsn[i]){
                    t0 = jsn[i].t0;
                    t1 = jsn[i].t1;
                    createTimelineSegment(t0, t1, iter, i);
                    iter++;
                }
            }
        }
        /**
         * CQ-64087 - default wizard behavior was causing 'save' to disable when page was 'dirty'
         */
        function removeWizardControls(){
            var rel_wizard_next_control = "form.foundation-wizard>nav " +
                ".foundation-wizard-control[data-foundation-wizard-control-action=\"next\"]";

            $(rel_wizard_next_control).removeClass("foundation-wizard-control");
        }
        /**
         * disableAllButtons is a utility function to disable all the buttons
         * in the timeline controls only, not any of the upper level buttons.
         */
        function disableAllButtons(){
            $(SV_BTN_DELETE).prop(SV_DISABLED_PROPERTY, true);
            $(SV_BTN_ADDSEGMENT).prop(SV_DISABLED_PROPERTY, true);
            $(SV_BTN_MULTI_SELECT).prop(SV_DISABLED_PROPERTY, true);
            $(SV_BTN_SPLIT).prop(SV_DISABLED_PROPERTY, true);
            $(SV_BTN_MERGE).prop(SV_DISABLED_PROPERTY, true);
        }
        /**
         * initScreen is called during the page construction to handle setting up the screen
         * and UI items
         */
        function initScreen() {
            disableAllButtons();
            createDragArea();
            layoutDivs();
        }
        /**
         * manually hide the assetPicker since it uses granite container for now, instead of granite dialog. 
         * TODO: this custom assetPicker container needs to be refactored to use the granite dialog later.
         */
        function hideAssetPicker() {
            $('#assetpickermodal').hide();
        }

        /**
         * onResolutionChange is the handler for the segment duration slider component
         */
        function onResolutionChange(e){
            var txt = e.target.value;
            var rawresolution = parseInt(txt);
            if (isNaN(rawresolution) || (rawresolution <= 0)) rawresolution = calculateSliderDefault();
            if (rawresolution > 60) rawresolution = 60;
            _sliderControl.set("value", rawresolution);
            setCurrentResolution(rawresolution);
            $(this).val(rawresolution + SV_SECONDS_ABBV);
        }
        /**
         *
         */
        function setupSlider(){
            var defVal = calculateSliderDefault();
            $(SV_TIMELINE_RESOLUTION_LABEL).val(defVal + SV_SECONDS_ABBV);
            _sliderControl = new Coral.Slider().set({
                ticks:false,
                filled:true,
                tooltips:false,
                min:1,
                max:60,
                step:1,
                value:defVal
            });

            _sliderControl.on(SV_CHANGE, function(e){
                var resolution = e.target.value;
                var cRes = getCurrentResolution();
                if (resolution != cRes){
                    setCurrentResolution(resolution);
                }
            });

            $(SV_TIMELINESLIDER_CL).append(_sliderControl);
        }
        /**
         * addDurationEntryTransition just sets up the slider entry field fade in/out
         */
/* Not needed as the resolutin label is always visible with the slider
        function addDurationEntryTransition(){
            var sliderEntry = $(SV_TIMELINE_RESOLUTION_LABEL);
            sliderEntry.hide();
            $(".sv-timelinecontrols").hover(
                function(){
                    sliderEntry.fadeIn();
                },
                function(){
                    sliderEntry.fadeOut();
                }
            );
        }
*/
        /**
         *
         */
        function addPlaybackMarker(){
            var div = $(SV_DIV);
            var indiv = $(SV_DIV);
            div.append(indiv);
            indiv.addClass(SV_TIMELINE_PLAYBACK_MARKER_TOP_CL)
            var target = $(SV_TIMELINE);
            div.addClass(SV_TIMELINE_PLAYBACK_MARKER_CL);
            target.append(div);
        }
        /**
         * Look up the preset data in array of preset data that matches the preset uri
         * @param presetUri
         * @returns {*}
         */
        function findPresetData(presetUri) {
            var preset = null;
            var presetList = $(document).data(DATA_PRESET_LIST_KEY);
            if (presetList) {
                $.each(presetList, function() {
                    if (this.uri && this.uri == presetUri) {
                        preset = this;
                    }
                });
            }
            return preset;
        }

        /**
         *
         * @returns {number}
         */
        function calculateSliderDefault(){
            var duration = getCurrentDuration();
            if (duration > 180){
                return 60;
            }else if (duration > 120 && duration <= 180){
                return 30;
            }else if (duration > 60 && duration <= 120){
                return 20;
            }else if (duration > 30 && duration <= 60){
                return 10;
            }
            return 5;
        }
        /**
         * Update the preset name to the menu bar.
         * @param presetName
         */
        function displayPresetName(presetName) {
            // Update preset name to icon
            $(SV_BTN_SELECTPRESET)[0].label.textContent = presetName;
        }
        /**
         * Retain a reference of the preset data for previewing.
         * Select preset data on the preset list GUI with check mark.
         * Display preset name in the menu bar.
         * @param presetData
         */
        function applyPresetData(presetData) {
            if (presetData) {
                curPresetData = presetData;
                $(document).data(DATA_PRESET_METADATA_KEY, presetData.uri);
                $.selectPreset(presetData.uri);
                displayPresetName(presetData.id);
            }
        }
        /*
         Update preset selection with value loaded from JCR
         */
        function updateViewerPreset(presetUri) {
            // !! preserve loaded value !!
            $(document).data(DATA_PRESET_METADATA_KEY, presetUri);

            // if viewer list available, make selection
            var presetData = findPresetData(presetUri);
            applyPresetData(presetData);
        }

        /**
         *
         * @param res
         */
        function setCurrentResolution(res){
            _currentResolution = res;
            $(SV_TIMELINE_RESOLUTION_LABEL).val(res + SV_SECONDS_ABBV);
            $(document).trigger({"type" : SV_RESOLUTION_CHANGE, "resolution":res});
        }

        /**
         *
         * @param res
         */
        function calculatePercentOfChange(res){
            var pchng = Math.abs(((_initialResolution - res)/_initialResolution));
            _percentOfChange = pchng;
        }

        /**
         *
         */
        function removeTimelinePlaybackMarker(){
            var hasDiv = $(SV_TIMELINE_PLAYBACK_MARKER).length > 0;
            if (hasDiv) {
                $(SV_TIMELINE_PLAYBACK_MARKER).remove();
            }
        }
        /**
         *
         */
        function rebuildAll(){

            removeTimelinePlaybackMarker();
            clearSegmentData();
            prevSelectedIds = selectedTimelineSegments.slice();
            REBUILD_TIMEOUT = window.setTimeout(waitForFinalEvent, 550);
            selectedTimelineSegments = [];

            $(SV_TIMELINE_SEGMENTS).empty();
            $(SV_TIMELINE_SEGMENT_CONTAINER).empty();
            segments = [];
            clearDragArea();
            $(SV_DRAG_CONTENT).remove();
            initScreen();
            buildSegments($.sv.getCurrentState());
            if (videoPlayer){
                updateStatus(videoPlayer.getCurrentTime());
            }
            toggleDeleteButtonToSegment();
            selectAllPrevious();
            /**
             * internal function that handles the set timeout proxy
             */
            function waitForFinalEvent (){
                clearTimeout(REBUILD_TIMEOUT);
                REBUILD_TIMEOUT = -1;
                selectAllPrevious();
            }

            /**
             * iterates over the list of previous selected DIV's
             * resizing clears the whole UI and rebuilds so we have to track
             * what was previously selected and what wasn't
             */
            function selectAllPrevious() {

                for (var i = 0; i < prevSelectedIds.length; i++) {

                    var seg = prevSelectedIds[i];

                    //if multi-select, add the right style to the existing DOM objects
                    if (seg) {
                        $(document).trigger({
                            "type": SV_EVENT_SEGMENT_SELECTED,
                            "target": $("#" + (seg).id + ".sv-timelinesegmentcontainer").children()[0],
                            "id": seg.id
                        });
                        //re-select the product row
                        var rows = $("#" + (seg).id + ".sv-timelinesegmentcontainer").find("article");
                        for (var y = 0; y < rows.length; y++){
                            var pth = $(rows[y]).data("path");
                            if (pth == prevSelectedRowURL){
                                var $rw = $(rows[y]).get(0);
                                $($rw).addClass("selected");
                                $(SV_BTN_DELETE)[0].label.textContent = Granite.I18n.get("Delete Product");
                                $(SV_BTN_DELETE).prop(SV_DISABLED_PROPERTY, false);
                                break;
                            }
                        }
                    }
                }
                //clear previous selected id's
                prevSelectedIds = [];
            }
        }

        //methods
        /**
         * Enable or disable Delete button according to the selected segments.
         * Enable delete button only when only the last segment has been selected.
         */
        function toggleDeleteButtonToSegment() {

            $(SV_BTN_DELETE).prop(SV_DISABLED_PROPERTY, true);
            var hasSelectedSegment = $(SV_TIMELINE_SEGMENT_CONTAINER_SELECTED).length > 0;
            var isLastSegment = parseInt($(SELECTED_TIMELINE_DIV).attr("id")) == (segments.length - 1);
            var isMultiSelected = (selectedTimelineSegments.length > 1);
            $(SV_BTN_DELETE).prop(SV_DISABLED_PROPERTY, !isLastSegment || !hasSelectedSegment || isMultiSelected);
            $(SV_BTN_DELETE)[0].label.textContent = Granite.I18n.get("Delete Segment");
        }
        /**
         * Enable and Display the Delete Segment, Merge Segment and Split Segment buttons based on the selected segments.
         */
        function toggleMenuBarItems(toggleDeleteButton){
            if (toggleDeleteButton) {
                toggleDeleteButtonToSegment();
            }
            $(SV_BTN_MERGE).prop(SV_DISABLED_PROPERTY, (!selectedTimelineSegments.length > _min_merge_amount) ||
                (selectedTimelineSegments.length <= _min_merge_amount) || (!isValidSequence()));
            $(SV_BTN_SPLIT).prop(SV_DISABLED_PROPERTY, (selectedTimelineSegments.length < _min_merge_amount) ||
                (selectedTimelineSegments.length > _min_merge_amount));
        }
        /**
         *
         */
        function submitChanges() {
            if (isEmptyVTT()){
                $(document).trigger('sv-delete-data');
            }else{
                $(document).trigger('sv-submit-data');
            }
        }
        /**
         *
         * @returns {boolean}
         */
        function isEmptyVTT(){
            var list = $.sv.getCurrentState();
            for (var i = 0; i < list.length; i++){
                if (list[i]) return false;
            }
            return true;
        }
        /**
         *
         */
        function deleteAction(){
            //what type of delete is it? segment or product?
            if ($('article.sv-timelinerow.selected').length > 0) {
                $(document).trigger(SV_PRODUCT_ROW_DELETED);
                toggleDeleteButtonToSegment();
            } else {
                if (SELECTED_TIMELINE_DIV){
                    removeTimelinePlaybackMarker();
                    var id = getCurrentSegmentId();
                    //remove this from the list of selected segments
                    removeSelectedSegment(SELECTED_TIMELINE_DIV);
                    $(document).trigger({ type:"sv-delete-segment","id":id});
                    $(SV_CONTENT + " " + SV_TIMELINE_SEGMENT_CONTAINER).remove();
                    clearSegmentData();
                    segments = [];
                    buildSegments($.sv.getCurrentState());
                    toggleMenuBarItems();
                    toggleDeleteButtonToSegment();

                    $(document).trigger( SV_EVENT_SEGMENT_UNSELECTED );
                };
            }
        }
        /*
         STEPS:
         1) build WebVTT content based on current state
         2) show preview dialog with InteractiveVideoViewer
         */
        /**
         *
         * @param preset
         */
        function preview(preset) {
            // 1) build WebVTT content based on current state
            var title = $(SV_ASSET_PREVIEW_INFO_ID).data('title');
            var videoDuration = $(SV_ASSET_PRESET_PREVIEW).data('s7duration');  // in seconds
            videoDuration = videoDuration ? Number(videoDuration) * 1000 : 0;   // in milliseconds
            var isRemote = $(".dm-setup-info").data("remoteasset");
            var companyId = $(".dm-setup-info").data("scene7companyid");
            var interactiveDataCues = $.sv.buildInteractiveDataCues(title, videoDuration, isRemote, companyId);

            // 2) dispatch event to preview in InteractiveVideoViewer with specified preset as INTERACTIVE_VIDEO type
            $(document).trigger({ "type": SV_PRESET_SHOW_PREVIEW,
                "id":"asset-preset-preview", "preset": preset, "interactiveData": interactiveDataCues });
        }

        // DO NOT REMOVE THIS FUNCTION - necessary for supporting variable previewing presets with non-100% width/height
        /**
         * Before disposing the viewer, remove width and height added to the preview in order to achieve optimal aspect
         * ratio as specified in the viewer preset CSS.  This ensure that the new preview will not be affected by the
         * size constraints added for the current preset.
         */
        $(document.querySelector(SV_PREVIEW)).on('coral-overlay:beforeclose', function(event) {
            // It is important to reset the styles enfored after viewer's initComplete
            // (relayed to event SV_PRESET_PREVIEW_READY).  Otherwise, sizing will be affect when
            // the next preset is selected.
            var outerContainer = document.querySelector(SV_PREVIEW_VIEWER);

            var $divAsset = $(SV_ASSET_PRESET_PREVIEW);

            // reset outer container styles
            outerContainer.style.width = "";
            outerContainer.style.height = "";

            // reset viewer <div> styles
            $divAsset.css("width", "");
            $divAsset.css("height", "");

            // reset dialog size
            var $div = $(SV_PREVIEW_DIALOG);
            $div.css("width", "");
            $div.css("height", "");

            // dispose viewer every time preview is closed
            s7disposeInteractiveViewer($(SV_ASSET_PRESET_PREVIEW));
        });


        /**
         *
         */
        function clearSegmentData(){
            $(SV_CONTENT + " " + SV_TIMELINE_SEGMENT_CONTAINER).remove();
            clearDragArea();
            segments = [];
        }
        //this shows the matching status element for timeline display
        /**
         *
         * @param time
         */
        function updateStatus(time){
            var millis = ((time / 1000) * calculateOneSecond());
            $(SV_TIMELINE_PLAYBACK_MARKER).css("left", millis);
            segmentExistsForTimestamp(time, true);
        }
        /**
         *
         * @param time
         * @param adjustBtn
         * @returns {boolean}
         */
        function segmentExistsForTimestamp(time, adjustBtn){
            var begin, end, segId, segs;
            segs = segments.length;
            if (segs == 0 && time > 1000){
                $(SV_BTN_ADDSEGMENT).prop(SV_DISABLED_PROPERTY, false);
            }

            if ($(SV_ASSET_PREVIEW).data("inNewSegment")){
                $(SV_BTN_ADDSEGMENT).prop(SV_DISABLED_PROPERTY, true);
                $(SV_ASSET_PREVIEW).data("inNewSegment", false);
                return;
            }

            var seg = segments[segs - 1];

            if (seg){
                segId = $(seg).attr("id");
                end = $(seg).data(SV_END);
                if (time > end){
                    //disable add segment button
                    $(SV_BTN_ADDSEGMENT).prop(SV_DISABLED_PROPERTY, false);
                    return true;
                }else{
                    $(SV_BTN_ADDSEGMENT).prop(SV_DISABLED_PROPERTY, true);
                    return false;
                }
                return true;
            }
            //we need to keep this for when we support adding between segments
            /*
             for (var i = 0; i < segs; i++){
             var seg = segments[i];
             segId = $(seg).attr("id");
             begin = $(seg).data(SV_BEGIN);
             end = $(seg).data(SV_END);
             var isInRange = numberInRange((time), (begin), (end));
             if (isInRange && adjustBtn){
             //disable add segment button
             $(SV_BTN_ADDSEGMENT).attr(SV_DISABLED_PROPERTY, true);
             break;
             }else{
             $(SV_BTN_ADDSEGMENT).attr(SV_DISABLED_PROPERTY, false);
             }
             }
             return true;
             */

        }
        /**
         *
         * @returns {number}
         */
        function getCurrentResolution(){
            //todo: calculate / cleanup this to get dynamically when called
            return _currentResolution;
        }
        /**
         *
         * @returns {number}
         */
        function getCurrentDuration(){
            var duration = $(SV_ASSET_PREVIEW).data(SV_S7DURATION);
            return (typeof duration == "undefined") ? 0 : duration;
        }

        /**
         *
         * @returns {*}
         */
        function getScrollLeft(){
            return $(SV_TIMELINE).scrollLeft();
        }

        /**
         *
         * @returns {number}
         */
        function getMaxWidth() {
            var calcSecondWidth = (_defMaxSecondWidth / getCurrentResolution()) / 1000;
            var duration = getCurrentDuration();
            var wid = (_defMaxSecondWidth * duration) / getCurrentResolution();
            return wid;
        }
        /**
         *
         */
        function createDragArea(){
            var cont = $(SV_DIV);
            cont.addClass(SV_DRAG_CONTENT_CL);
            var target = $(SV_TIMELINE);
            target.append(cont);
        }

        /**
         *
         */
        function clearDragArea(){
            $(SV_DRAG_CONTENT).empty();
        }

        /**
         *
         * @param cont
         */
        function adjustDragArea(cont){

            var wid = $(cont).width();
            var lft = parseInt(($(cont).parent()).css(SV_LEFT));
            var right = parseInt(($(cont).parent()).css(SV_RIGHT));
            var rbtn = $("." + SV_SEGMENT_CIRCLE_END);
            var lbtn = $("." + SV_SEGMENT_CIRCLE_BEGIN);
            var target = $(SV_TIMELINEHEADER);
            var drgWid = getDragWidth();

            $(lbtn).css(SV_LEFT, (lft - drgWid));
            $(rbtn).css(SV_LEFT, (lft + wid) - drgWid);
            target.css(SV_RIGHT, right);
            target.css(SV_LEFT, lft);
        }
        /**
         *
         */
        function layoutDivs() {

            var duration = $(SV_ASSET_PREVIEW).data(SV_S7DURATION);
            var sections = (duration / getCurrentResolution());
            var calcSecondWidth = (_defMaxSecondWidth/getCurrentResolution());

            var elm = $(SV_TIMELINESEGMENTS);
            for (var i = 0; i < (sections); i++) {
                var newdiv = createTimelineDiv(i, sections, (getCurrentResolution() * calcSecondWidth));
                elm.append(newdiv);
                newdiv.addClass("sv-box");
            }
        }

        /**
         *
         * @param id
         * @param sections
         * @param width
         * @returns {*|HTMLElement}
         */
        function createTimelineDiv(id, sections, width) {

            var res = getCurrentResolution();
            res = (res * (id + 1));
            var label = formatSeconds(res);
            var elm = $(SV_DIV);
            elm.append(label);
            $(elm).attr("id", "segment" + id);
            $(elm).css("width", width);
            return elm;
        }
        /**
         *
         * @param pos
         * @returns {number}
         */
        function getNormalizedPosition(pos){
            var calcSecondWidth = (_defMaxSecondWidth/getCurrentResolution())/1000;
            return Math.round(pos * calcSecondWidth);
        }

        /**
         *
         * @param begin
         * @param end
         * @param iterator
         * @param pos
         * @param autoSelect
         */
        function createTimelineSegment(begin, end, iterator, pos, autoSelect){

            //there is already a DIV
            if (iterator < 0) return;
            var cont = $(SV_DIV);
            $(cont).addClass(SV_TIMELINESEGMENTCONTAINER_CL);
            //just check if we have a valid position

            $(cont).data("id", "sv-segment-" + iterator);
            $(cont).data("pos", pos);
            $(cont).attr("id", iterator);
            $(cont).attr("tabindex", 0);

            $(cont).attr("title", "Segment " + (iterator + 1));
            $(cont).data("begin", begin);
            $(cont).data("end", end);

            segments.push(cont);

            var target = $(SV_TIMELINE);
            var ptime = (end - begin);
            var duration = $(SV_ASSET_PREVIEW).data(SV_S7DURATION);
            var perc = ((ptime/(duration * 1000))).toFixed(4);

            var wid = $(SV_TIMELINE).width();
            var mainwid = $(SV_TIMELINE_CONTENT).width();
            var maxWidth = getMaxWidth();

            var cwid = (maxWidth * perc);
            var rLeft = calculateLeft(begin, maxWidth);
            var leftPosition = getNormalizedPosition(begin);
            var rRight = (wid - cwid) - leftPosition;

            begin = Math.round(begin / 1000) * 1000;
            end = Math.round(end / 1000) * 1000;

            $(cont).data(SV_TIME, ptime);
            $(cont).css(SV_RIGHT, rRight);
            $(cont).css(SV_LEFT, rLeft);

            target.append(cont);

            var label = formatSeconds((begin/1000)) + "-" + formatSeconds((end/1000));

	    $(cont).keydown(function(e){
    	        if (e.which == 13 || e.which == 32){
                    e.preventDefault();
                    var id = $($(this).get(0)).attr("id");
                    id = $($(this).get(0)).data("pos");
	            $(document).trigger({"type": SV_EVENT_SEGMENT_SELECTED, "target":$(this).children(0), "id":id});
                    var seek = $(SELECTED_TIMELINE_DIV).data(SV_BEGIN);
                    if(videoPlayer && seek >= 0){
                        videoPlayer.seek(seek);
                    }                
                }
            });

            $(cont).on(SV_EVENT_SEGMENT_DATA_CHANGED, function(e) {
                //forward event
                handleSegmentDataChange(e);
            });

            createSegmentBody(wid, cont, label, autoSelect);

            $(document).trigger({"type" : SV_SEGMENT_DATA_READY, "segment":cont, "segmentId":pos});
        }

        /**
         * update segment data model when a row is added, removed, or re-ordered
         * @param e
         */
        function handleSegmentDataChange(e) {

            var segId = $(e.target).data('pos');
            var segmentModel = $.sv.getSegmentByID(segId);
            var productRows = $(e.target).find('article.sv-timelinerow');
            var newProductList = [];
            var isDirty = false;

            var curRow, curId, curData;

            for (var i=0; i < productRows.length; i++) {
                curRow = $(productRows).get(i);
                curId = $(curRow).attr('data-path');
                curData = undefined;

                for (var z=0; z < segmentModel.products.length; z++) {
                    if (segmentModel.products[z].asset === curId) {
                        curData = segmentModel.products[z];
                        break;
                    }
                }

                if (!curData) {
                    curData = $.sv.buildBasicProduct(curId, $(curRow).data('jcrtitle'));
                }

                newProductList.push(curData);
            }

            if (segmentModel.products != newProductList) {
                segmentModel.products = newProductList;
                isDirty = true;
            }

            if (isDirty) {
                $(document).trigger({ type:SV_MODIFY_SEGMENT, "id":segId, "segment":segmentModel });
            }
        }

        /**
         *
         * @param begin
         * @param width
         * @returns {number}
         */
        function calculateLeft(begin, width){
            var duration = $(SV_ASSET_PREVIEW).data(SV_S7DURATION);
            var perc = ((begin/(duration * 1000)));
            var left = (width * perc);
            return left;
        }

        /**
         *
         * @param position
         * @returns {*}
         */
        function calculateTime(position){
            var millis = calculateSeekFromLeft(position);
            var ctime = getRoundedSeconds(millis, 1);
            return formatSeconds(ctime);
        }

        /**
         *
         * @param millis
         * @param n
         * @returns {number}
         */
        function getRoundedSeconds(millis, n){
            var ctime = (Math.round(millis/n) * n)/1000;
            return ctime;
        }

        /**
         *
         * @param wid
         * @param cont
         * @param label
         * @param autoSelect
         */
        function createSegmentBody(wid, cont, label, autoSelect){
            var elm = $(SV_DIV);
            var target = $(SV_CONTENT);
            $(elm).addClass(SV_TIMELINESEGMENTBODY);
            var prodContent = $(SV_DIV);
            var prodHeader = $(SV_DIV);
            elm.append(prodContent);
            elm.append(prodHeader);
            var lblelm = $(SV_DIV).append(label);
            $(lblelm).addClass(SV_SEGMENT_TIME_LABEL);
            $(elm).append(lblelm);
            $(prodContent).addClass(SV_TIMELINE_PRODUCT_BODY_CL);
            $(prodContent).addClass(SV_TIMELINE_PRODUCT_BODY_LIST_CL);
            $(prodHeader).addClass(SV_TIMELINE_PRODUCT_HEADER_CL);

            cont.append(elm);

	    var segmentTitle = $(cont).attr("title");
            //adding desired attributes to make it as a toggle button
            $(lblelm).attr({"role":"button","aria-pressed":"false","tabindex":"0","aria-label":segmentTitle});

            /* Event handler for the click on the newly created segment */
            $(elm).on(SV_CLICK, function(e, doNotSeek){

                var id = $($(this).parent().get(0)).attr("id");
                id = $($(this).parent().get(0)).data("pos");

                $(document).trigger({"type": SV_EVENT_SEGMENT_SELECTED, "target":this, "id":id});
                //moved this logic to here to determine if we are auto creating segment from user +
                //or the segments when parsing segment data from JCR
                //if we auto create in normal click mode, you would seek to beginning but if we auto
                //create we don't want to see
                if (!doNotSeek){
                    var seek = $(SELECTED_TIMELINE_DIV).data(SV_BEGIN);
                    if(videoPlayer && seek >= 0){
                        videoPlayer.seek(seek);
                    }
                }
            });

            //pre-select newly created segment
            if (autoSelect){
                $(elm).trigger(SV_CLICK, true);
            }
        }

        /**
         *
         * @param cont
         * @returns {*|HTMLElement}
         */
        function createDragHandles(cont){

            var elm = $(SV_DIV);
            var target = $(SV_DRAG_CONTENT);
            $(elm).addClass(SV_TIMELINEHEADER_CL);
            target.append(elm);
            var dottarget = $(SV_TIMELINEHEADER);
            var elm = $(SV_DIV);
            var elmdot = $(SV_DIV);
            elm.append(elmdot);

            $(elm).data(SV_DRAG_TYPE, SV_DRAG_BEGIN);
            $(target).append(elm);
            var elm2 = $(SV_DIV);
            var elmdot2 = $(SV_DIV);
            elm2.append(elmdot2);

            $(elm2).data(SV_DRAG_TYPE, SV_DRAG_END);
            $(target).append(elm2);

            $(elm).addClass(SV_SEGMENT_CIRCLE);
            $(elm).addClass(SV_SEGMENT_CIRCLE_BEGIN);
            elmdot.addClass("arrow-down-begin");

            $(elm2).addClass(SV_SEGMENT_CIRCLE);
            $(elm2).addClass(SV_SEGMENT_CIRCLE_END);
            elmdot2.addClass("arrow-down-end");

            //on drag

            $(elm2).draggable({
                axis:"x",
                drag:onDragElm,
                stop: onDragStop
            });

            //we cannot drag the first one for now
            $(elm).draggable({
                axis:"x",
                drag:onDragElm,
                stop: onDragStop
            });

            $(elm).mousedown(function(){
                $(this).draggable("option", "containment", calculateContainment());
                $(elmdot2).removeClass("selected");
                $(elmdot).addClass("selected");
            });

            $(elm2).mousedown(function(){
                $(this).draggable("option", "containment", calculateContainment());
                $(elmdot).removeClass("selected");
                $(elmdot2).addClass("selected");

            });
            //on click
            $(elm2).click( function(){
                if (elmdot.hasClass("selected")){
                    elmdot.removeClass("selected");
                }
                $(elmdot2).addClass("selected");
                var seg = $(SELECTED_TIMELINE_DIV);
                var end = $(seg).data(SV_END);
                var curTime = getCurrentPlaybackTime();
                if (end != curTime){
                    videoPlayer.seek(end);
                }
            });
            $(elm).click( function(){
                if (elmdot2.hasClass("selected")){
                    elmdot2.removeClass("selected");
                }
                $(elmdot).addClass("selected");
                var seg = $(SELECTED_TIMELINE_DIV);
                var begin = $(seg).data(SV_BEGIN);
                var curTime = getCurrentPlaybackTime();
                if (begin != curTime){
                    videoPlayer.seek(begin);
                }
            });
            return target;
        }

        /**
         *
         * @returns {number[]}
         */
        function calculateContainment(){
            //if no selected div, just return bogus containment
            if (!SELECTED_TIMELINE_DIV) return [0,0,0,0];
            var prevSeg, nextSeg, prevRt, nextLft;
            var wid = $(SV_TIMELINE).width();
            var segId = getCurrentSegmentId();

            segId = parseInt($(SELECTED_TIMELINE_DIV).attr("id"));

            prevSeg = segments[(segId - 1)];
            nextSeg = segments[(segId + 1)];
            var drgWid = getDragWidth() * .5;

            if (prevSeg ? prevRt = ((wid - getScrollLeft()) - parseInt($(prevSeg).css(SV_RIGHT)) + drgWid) : prevRt = 0 );
            //if there isn't a next segment, basically you can drag until the end of the duration in pixels based on
            //timeline resolution
            if (nextSeg ? nextLft = (parseInt($(nextSeg).css(SV_LEFT)) - getScrollLeft()) : nextLft = (getMaxWidth() - getScrollLeft()) );

            return [(prevRt + drgWid), 10, (nextLft + drgWid), 0];
        }

        /**
         *
         * @returns {*}
         */
        function getCurrentSegmentBeginTime(){
            return $(SELECTED_TIMELINE_DIV).data(SV_BEGIN);
        }

        /**
         *
         * @returns {*}
         */
        function getCurrentSegmentEndTime(){
            return $(SELECTED_TIMELINE_DIV).data(SV_END);
        }

        /**
         *
         * @returns {*}
         */
        function getCurrentSegmentId(){
            try{
                var segId = parseInt($(SELECTED_TIMELINE_DIV).data().pos);
                if (segId) return segId;
            }catch(e){
                return 0;
            }
            return 0;
        }

        /**
         *
         * @param e
         * @param ui
         * @returns {*}
         */
        function onDragElm(e, ui){
            if ($(e.target).data(SV_DRAG_TYPE) == SV_DRAG_BEGIN){
                return doDragBegin(e, ui);
            }else{
                return doDragEnd(e, ui);
            }
        }

        /**
         *
         * @returns {number}
         */
        function calculateOneSecond(){
            var wid = getMaxWidth();
            var duration = $(SV_ASSET_PREVIEW).data(SV_S7DURATION);
            var fac = (wid/duration);
            return fac;
        }

        /**
         *
         * @returns {*}
         */
        function getDragWidth(){
            try{
                var wid = parseInt($(".sv-segmenthandle-circle-begin").width() * .5);
                return wid;
            }catch(e){
                return 10;
            }
            return 10;
        }

        /**
         *
         * @param left
         * @returns {number}
         */
        function calculateSeekFromLeft(left){
            var wid = getMaxWidth();
            var perc = (left / wid);
            var duration = $(SV_ASSET_PREVIEW).data(SV_S7DURATION);
            //for this width, what is time based on the DIV width using same calculation as layout of divs
            var seek = (perc * duration) * 1000;
            var c = ((seek+1) / 500) * 500;
            return c;
        }

        /**
         *
         * @param e
         * @param ui
         */
        function onDragStop(e, ui){

            var divLft = parseInt($(SELECTED_TIMELINE_DIV).css(SV_LEFT));
            var lft = parseInt($(e.target).css(SV_LEFT)) + getDragWidth();
            var duration = getCurrentDuration();
            var seek = calculateSeekFromLeft(lft);
            var twid 		= $(SV_TIMELINE).width();
            var right 		= (twid - lft);

            if (isNaN(seek)) return;

            var calcSecondWidth = (_defMaxSecondWidth/getCurrentResolution());

            var begin = Math.floor(getCurrentSegmentBeginTime());
            var end = Math.floor(getCurrentSegmentEndTime());
            var prevSeg, nextSeg;
            var segId = getCurrentSegmentId();

            prevSeg = segments[(segId - 1)];
            nextSeg = segments[(segId + 1)];

            var segment = $.sv.getSegmentByID(segId);
            var validAmt = true;
            var hasSeg = true;
            var knownSeek = seek;

            if ($(e.target).data(SV_DRAG_TYPE) == SV_DRAG_END){
                validAmt = validDrag(true, lft);
                if (nextSeg){
                    knownSeek = $(nextSeg).data(SV_BEGIN);
                }else{
                    hasSeg = false;
                }
            }else{
                validAmt = validDrag(false, right);
                if (prevSeg){
                    knownSeek = $(prevSeg).data(SV_END);
                }else{
                    hasSeg = false;
                }
            }
            //if the target overlaps an adjacent segment on left/right - use that segments timestamp to create event
            //borders of time (only for cases when segment needs to be close)
            if (!validAmt && hasSeg){
                seek = knownSeek;
            }
            //just in case a drag action causes to go past 0
            if(seek < 0) seek = 0;

            if ($(e.target).data(SV_DRAG_TYPE) == SV_DRAG_BEGIN){
                $(SELECTED_TIMELINE_DIV).data(SV_BEGIN, seek);
                segment.t0 = seek;
            }else{
                $(SELECTED_TIMELINE_DIV).data(SV_END, seek);
                segment.t1 = seek;
            }

            //set the segments time
            var ptime = (segment.t1 - segment.t0);
            $(SELECTED_TIMELINE_DIV).data(SV_TIME, ptime);

            $(document).trigger({ type:SV_MODIFY_SEGMENT, "id":segId, "segment":segment });

            if (seek){
                videoPlayer.seek(seek);
            }
        }

        /**
         * check the position of adjacent segments
         * stop dragging when at threshold
         * @param direction
         * @param amt
         * @returns {boolean}
         */
        function validDrag(direction, amt){
            //just do a sanity check
            if (!SELECTED_TIMELINE_DIV) return false;
            var prevSeg, nextSeg;
            var segId = getCurrentSegmentId();

            segId = parseInt($(SELECTED_TIMELINE_DIV).attr("id"));

            prevSeg = segments[(segId - 1)];
            nextSeg = segments[(segId + 1)];
            //determine which metric to examine
            var thisLeft, thisRight, isInLBounds, isInRBounds;

            thisLeft = parseInt($(SELECTED_TIMELINE_DIV).css(SV_LEFT));
            thisRight = parseInt($(SELECTED_TIMELINE_DIV).css(SV_RIGHT));

            isInLBounds = ((amt) > thisLeft);
            isInRBounds = ((amt) > thisRight);

            if(direction){
                if (!isInLBounds) return false;
                if (nextSeg){
                    var nxt = parseInt($(nextSeg).css(SV_LEFT));
                    return (amt <= nxt);
                }else{
                    var nxt = getMaxWidth();
                    return amt <= nxt;
                }
            }else{
                if (!isInRBounds) return false;
                if (prevSeg){
                    var rght = parseInt($(prevSeg).css(SV_RIGHT));
                    return (amt <= rght);
                }
            }
            return true;
        }
        /**
         *
         * @param e
         * @param ui
         */
        function doDragEnd(e, ui){

            var parent 	= $(SV_TIMELINEHEADER);
            var lft 	= parseInt($(e.target).css(SV_LEFT)) + getDragWidth();
            var wid 	= $(SV_TIMELINE).width();

            if (validDrag(true, lft)){
                var calctime = calculateSeekFromLeft(lft);
                $(parent).css(SV_RIGHT, (wid - lft));
                $(SELECTED_TIMELINE_DIV).css(SV_RIGHT, (wid - lft));
                var time = calculateTime(lft);
                formatDragLabel(time, true);
            }
        }

        /**
         *
         * @param e
         * @param ui
         */
        function doDragBegin(e, ui){

            var parent 		= $(SV_TIMELINEHEADER);
            var lft 		= parseInt($(e.target).css(SV_LEFT)) + getDragWidth();
            var twid 		= $(SV_TIMELINE).width();
            var right 		= (twid - lft);

            if (validDrag(false, right)){
                var calctime = calculateSeekFromLeft(lft);
                $(parent).css(SV_LEFT, lft);
                $(SELECTED_TIMELINE_DIV).css(SV_LEFT, lft);
                var time = calculateTime(lft);
                formatDragLabel(time, false);
            }
        }

        /**
         *
         * @param time
         * @param leftside
         */
        function formatDragLabel(time, leftside){

            var curLabel = $(SELECTED_TIMELINE_DIV).find(".sv-segmenttimelabel").text();
            if (curLabel){
                var parts = curLabel.split("-");
                var lbl = curLabel;
                if (parts.length > 0){
                    var v1 = parts[0];
                    var v2 = parts[1];
                    if (!leftside){
                        lbl = time + "-" + v2;
                    }else{
                        lbl = v1 + "-" + time;
                    }
                }
                $(SELECTED_TIMELINE_DIV).find(".sv-segmenttimelabel").html(lbl);
            }
        }
        /*
         *	format the output for the timeline labels
         */
        function formatSeconds(seconds){
            var date = new Date(1970,0,1);
            date.setSeconds(seconds);
            return date.toTimeString().replace(/.*(\d{0}\d{2}:\d{2}).*/, "$1");
        }
        /**
         *
         * @returns {number}
         */
        function getCurrentPlaybackTime(){
            return (isNaN(videoPlayer.getCurrentTime())) ? 0 : videoPlayer.getCurrentTime();
        }
        /**
         * Set an timeline segment to selected state if elm is defined, otherwise deselect all segments
         * @param elm The timeline segment to select, set to null to deselect all segments
         */
        function toggleSelect(elm){
            if (elm){
                $(elm).parent().data("selected", true);
                $(elm).parent().addClass("selected");
                $(elm).find(".sv-segmenttimelabel").addClass("selected");
		$(elm).find(".sv-segmenttimelabel").attr("aria-pressed","true");
            }else{
                $(SV_TIMELINE_SEGMENT_CONTAINER_SELECTED).each(function() {
                    $(this).removeClass("selected");
                    $(this).find(".sv-segmenttimelabel").removeClass("selected");
                    $(this).data("selected", false);
		    $(this).find(".sv-segmenttimelabel").attr("aria-pressed","false");

                });
            }
        }
        /**
         *
         * @returns {*}
         */
        function getCurrentSegmentStartTime(){
            try{
                if ($.sv.getCurrentState().length > 0){
                    var begin = $.sv.getSegmentByID(segments.length - 1).t1;
                    return begin;
                }
                return 0;
            }catch(e){
                return 0;
            }
        }
        /**
         *
         * @returns {*}
         */
        function getTranslatedSegmentId(){
            var seg = $.sv.getCurrentState();
            for (var i = 0; i < seg.length; i++){
                if (seg[i] == null){
                    return i;
                }
            }
            return $.sv.getSegmentCount();
        }
        /**
         * addNewSegment is the click handler for the Add Segment button
         *
         */
        function addNewSegment() {

            if (videoPlayer){
                videoPlayer.pause();
            }

            $(SV_ASSET_PREVIEW).data("inNewSegment", true);

            //do a validity check to see if we can add (like we are adding to area already);
            var begin = Math.floor(getCurrentSegmentStartTime());
            var end = Math.floor(getCurrentPlaybackTime());
            if (begin == end) return;

            var seg = $.sv.buildSegment(begin, end, []);
            var id = getTranslatedSegmentId();

            $(document).trigger({ type:SV_MODIFY_SEGMENT, "id":id, "segment":seg });
            //must do this first
            createTimelineSegment(begin, end, id, id, true);

            $(SV_BTN_ADDSEGMENT).prop(SV_DISABLED_PROPERTY, true);
            //fix for CQ-55186
            toggleDeleteButtonToSegment();
        }
        /**
         * Add a segment to the array of selected segments
         * @param segment
         */
        function addSelectedSegment(segment){
            //add segments for multi select here
            var idx = selectedTimelineSegments.indexOf(segment);
            //if there isn't an index, then add the segment - this
            //list is only for later calculating the begin and end time for
            //the merged segment (which will be the first time slots segment)
            if (idx < 0) {
                selectedTimelineSegments.push(segment);
            }
        }
        /**
         * Remove a segment from the array of selected segments.  Remove all segments if segment is null.
         * @param segment The segment to remove.  Set to null to remove all segments.
         */
        function removeSelectedSegment(segment) {
            //remove segments for multi select here
            if (segment) {
                var idx = selectedTimelineSegments.indexOf(segment);
                if (idx >= 0) {
                    selectedTimelineSegments.splice(idx, 1);
                }
            } else {
                selectedTimelineSegments.splice(0, selectedTimelineSegments.length);
            }
        }

        function isValidSequence(){

            //sort ascending numerically by 'begin' time of segment
            function sortDescending(a,b) {
                return $(a).data().begin - $(b).data().begin;
            }
            selectedTimelineSegments.sort(sortDescending);

            //check that this is a valid merge. i.e. the segments are all adjacent to each other
            //for instance, if you have 5 segments in the timeline and the user selects segment
            //1,3,4 this would not be a valid merge. this logic should be moved to a handler
            //on the button to disable in this case to make it invalid and not an option
            var validSequence = true;
            for (var i = 0; i < selectedTimelineSegments.length; i++){
                var pos = parseInt($(selectedTimelineSegments[i]).attr("id"));
                //just see if there is a 'next' one
                if (selectedTimelineSegments[i + 1]){
                    var check =  parseInt($(selectedTimelineSegments[i + 1]).attr("id"));
                    if (check != (pos + 1) ){
                        validSequence = false;
                    }
                }
            }
            return validSequence;
        }
        /**
         * mergeTimelineSegments just iterates over the segment list, creates a single segment of all
         * the current selected segments, updates the data and also validates the button state
         */
        function mergeTimelineSegments(){
            //if the selected timeline div's are in sequence, don't attempt a merge
            if (!isValidSequence()){
                return;
            }
            //get the first and last elements of sorted array
            var pos1 = selectedTimelineSegments.shift();
            var pos2 = selectedTimelineSegments.pop();
            //now, just update the first segments end time
            //now we actually merge the segments
            $.sv.mergeSegments($(pos1).data().pos, $(pos2).data().pos);
            //and rebuild the UI
            rebuildAll();
        }
        /**
         * EVENT HANDLERS HERE
         *
         * this will rebuild the whole timeline each time the browser window resizes
         */
        $(window).resize( function(e){
            rebuildAll();
        });
        //CQ-88275 - added to fix 'save' button not enabled
        $(document).on(SV_EVENT_SEGMENT_DATA_CHANGED, function(e){
            if ($.sv.hasPendingData()){
                $(SV_BTN_SAVE).prop(SV_DISABLED_PROPERTY, false);
            }
        });
        /**
         *  sv_segment_selected is the handler for the individual timeline rows
         *
         */
        $(document).on(SV_EVENT_SEGMENT_SELECTED, function(e){
            e.stopPropagation();

            var localSeg = $(e.target).parent().get(0);
            var alreadySelected = localSeg && $(localSeg).data("selected");

            /*
            Scenarios for segment selection:
            1) Only one segment selected
             click on the same selected segment - deselect the clicked segment
            2) Multiple segments selected
             click on one of the selected segment - only the clicked segment remain selected.
            3) None or some segment selected
               click on any segment - select the clicked segment in addition to any previous selection
             */

            // number of selected segments
            var numSelected = selectedTimelineSegments.length;

            if (alreadySelected) {
                if (numSelected == 1) {
                    // case 1: Only one segment selected, click on selected segment to deselect
                    // remove all segment selection
                    toggleSelect(null);
                    removeSelectedSegment(null);
                    SELECTED_TIMELINE_DIV = null;

                    //clear the previous drag area's div's
                    clearDragArea();

                    //toggle state of actions in UI
                    toggleMenuBarItems(true);
                    $(document).trigger( SV_EVENT_SEGMENT_UNSELECTED );
                    return;
                } else {
                    // case 2: Multiple segment selected, click on selected segment to select only the clicked segment
                    toggleSelect(null);
                    removeSelectedSegment(null);
                }
            }

            // case 2 & 3: select the clicked segment
            // select the clicked segment
            //clear the previous drag area's div's
            selectSegment(localSeg, true);

            if (selectedTimelineSegments.length != 1) {
                $(document).trigger( SV_EVENT_MULTI_SEGMENT_SELECTED );
            }
        });

        /**
         * Select a segment and handle all relevant UI elements including drag area and buttons in the timeline menu bar
         * @param segment The segment to select
         */
        function selectSegment(segment, toggleDeleteSegment) {
            var segmentBody = $(segment).find(SV_PERIOD + SV_TIMELINESEGMENTBODY);

            clearDragArea();
            //only enable if last segment
            toggleSelect(segmentBody);
            //set selected segment to parent
            SELECTED_TIMELINE_DIV = segment;
            //create a list of selected segments for the merge
            addSelectedSegment(segment);
            //toggle state of actions in UI
            toggleMenuBarItems(toggleDeleteSegment);

            //set up the drag handles and resize the drag area when only one segment has been selected
            if (selectedTimelineSegments.length == 1) {
                createDragHandles(segmentBody);
                //reposition the little drag handles at the ends of the segment created
                //we only ever have one of these active
                adjustDragArea(segmentBody);
            }
        }

        /**
         * this is the handler for the slider label/entry field for timeline duration
         * which then proxies to onResolutionChange
         */
        $(SV_TIMELINE_RESOLUTION_LABEL).on("focusout", function(e){
            onResolutionChange(e);
        });
        /**
         * this is the enter key handler for the slider label/entry field for timeline duration
         * that triggers the focus out on the label
         */
        $(SV_TIMELINE_RESOLUTION_LABEL).keyup(function(e){
            if (e.which == 13){
                $(SV_TIMELINE_RESOLUTION_LABEL).trigger({type:"focusout", target:this});
            }
        });
        /**
         *
         */
        $(SV_BTN_SPLIT).on(SV_CLICK, function(){
            var id = getCurrentSegmentId();
            $.sv.splitSegment(id);
            rebuildAll();
            //rebuild after having the data split
        });
        /**
         *
         */
        $(SV_BTN_MERGE).on(SV_CLICK, function(){
            mergeTimelineSegments();
        });
        /**
         *
         */
        $(document).on(SV_RESOLUTION_CHANGE, function(e){
            calculatePercentOfChange(e.resolution);
            rebuildAll();
        })
        /**
         *
         */
        $(document).on(SV_VIDEO_CURRENT_TIME_EVENT, function(e, data){
            updateStatus(e.s7event.data);
        })

        /**
         * Toggle the play/pause button state dependent on the state of the video playback capability.
         * @param state Video playback capability state
         */
        function togglePlayPauseButton(state) {
            var hasPlay = state.hasCapability(s7viewers.s7sdk.VideoCapabilityState.PLAY) ||
                state.hasCapability(s7viewers.s7sdk.VideoCapabilityState.REPLAY);
            var hasPause = state.hasCapability(s7viewers.s7sdk.VideoCapabilityState.PAUSE);
            if (hasPlay){
                $(SV_BTN_PLAY).attr("selected", true);
                $(SV_BTN_PAUSE).attr("selected", false);
            }else if (hasPause){
                $(SV_BTN_PAUSE).attr("selected", true);
                $(SV_BTN_PLAY).attr("selected", false);
            }
        }

        /**
         * Toggle the video play pause button upon video playback capability status change event.
         */
        $(document).on(SV_VIDEO_STATUS_EVENT, function(e){
            togglePlayPauseButton(e.s7event.state);
        });

        /**
         *
         */
        $(document).on(SV_VIDEO_PLAYER_READY, function(e, viewer){

            videoPlayer = viewer.getComponent("videoPlayer");
            var videoScrubber = viewer.getComponent("videoScrubber");
            var halfWidth = $(SV_VIDEO_EDITOR_SCRUBBER_TIME).width() / 2;  // half the width of the video time

            /**
             * Position the VideoTime component associated with the scrubber knob.  This
             * component will move along with the knob within the width of the viewer.
             * @param position Normalized position of the knob.
             */
            function positionVideoTime(position) {
                // viewer will center the video time component internally
                var viewerWidth = $(SV_ASSET_PREVIEW).width();
                var left = Math.min(Math.max(halfWidth, position * viewerWidth), viewerWidth - halfWidth);
                $(SV_VIDEO_EDITOR_SCRUBBER_TIME).css("left", left + "px");
            }

            videoScrubber.addEventListener(s7viewers.s7sdk.event.SliderEvent.NOTF_SLIDER_DOWN, function(e){
                $(SV_VIDEO_EDITOR_TIME).hide();
                positionVideoTime(e.s7event.position);
            });
            videoScrubber.addEventListener(s7viewers.s7sdk.event.SliderEvent.NOTF_SLIDER_MOVE, function(e){
                positionVideoTime(e.s7event.position);
            });
            videoScrubber.addEventListener(s7viewers.s7sdk.event.SliderEvent.NOTF_SLIDER_UP, function(){
                $(SV_VIDEO_EDITOR_TIME).show();
            });
        })
        /**
         *
         */
        $(document).on(SV_DATA_READY, function(e){
            buildSegments(e.segments);
            updateViewerPreset(e.viewerpreset);
        })
        /**
         *
         */
        $(BTN_UNDO).on("click", function() {
            removeTimelinePlaybackMarker();
            $(document).trigger(SV_TIMELINE_SELECTED);
            if ($(ASSET_LIST_MASONRY_ITEM_SELECTOR).length > 0) {
                $(ASSET_LIST_OVERLAY_ID).addClass("show");
            }
            $(document).trigger(SV_UNDO_CLICKED);
        })
        /**
         *
         */
        $(BTN_REDO).on("click", function() {
            $(document).trigger(SV_REDO_CLICKED);
        })
        /**
         *
         */
        $(SV_BTN_SAVE).click( function() {
            $.sv.userInitiatedAction = true;
            submitChanges();
        })
        /**
         *
         */
        $(SV_BTN_DELETE).click( function() {
            deleteAction();
        })
        // Preview button to trigger preset selection dialog for preview
        /**
         *
         */
        $(SV_BTN_PREVIEW).on(SV_CLICK, function(e) {
            if (videoPlayer) {
                // pause video
                videoPlayer.pause();
            }
            preview(curPresetData);
        });

        /**
         * Handler for click event the play/pause button. <br>
         * Note that in Firefox, the click event on the individual play and pause buttons are not triggered. <br>
         * It has been observed inconsistently that after repetitively adding and removing segments, the play/pause
         * button become out-of-sync with the video playback capability state.  The following code will explicitly
         * set the button to the correct state and either play or pause the video accordingly.
         *
         */
        $(SV_BTN_PLAYPAUSE).on(SV_CLICK, function() {
            if (!videoPlayer) {
                return;
            }

            var state = videoPlayer.getCapabilityState();
            var hasPlay = state.hasCapability(s7viewers.s7sdk.VideoCapabilityState.PLAY) ||
                state.hasCapability(s7viewers.s7sdk.VideoCapabilityState.REPLAY);
            var hasPause = state.hasCapability(s7viewers.s7sdk.VideoCapabilityState.PAUSE);

            if (hasPlay) {
                videoPlayer.play();
            } else if (hasPause) {
                videoPlayer.pause();
            }
        });

        /**
         * Handler for the click on the Cancel button of the Editor.  The confirmation dialog will to displayed if
         * there is pending changes.  The confirmation dialog is programmed to navigate to the Asset Listing page
         * if the user click OK to discard.
         */
        $(SV_BTN_CANCEL).click( function(e) {
            e.preventDefault();

            // default to return to assets page regardless where it navigated from (document.referrer)
            // to be consistent with other set builders
            var prevUrl = BASE_REDIRECT_SUFFIX;
            var assetPath = $(ASSET_INFO_ID).data('path');
            if (assetPath) {
                // obtain parent folder
                var index = assetPath.lastIndexOf('/');
                if (index > 1) {
                    prevUrl = assetPath.substr(0, index);
                }
            }
            prevUrl = BASE_REDIRECT_URL + prevUrl;
            if ($.sv.hasPendingData()) {
                $(SV_CONFIRMATION).data('href', prevUrl);
                document.querySelector(SV_CONFIRMATION).show();
            }
            else {
                window.location.href = prevUrl;
            }
        });

        /**
         * Handler for the OK button on the Confirmation dialog invoked when user clicked Cancel on the Editor with
         * pending changes.  This function will discard pending changes and navigate to the Asset Listing page.
         */
        $(SV_CONFIRMATION_OK).click( function(){
            $.sv.userInitiatedAction = true;
            var href = $(SV_CONFIRMATION).data('href');
            window.location.href = href;
        });

        /**
         Upon preset list data ready event, retain the list of presets data.
         */
        $(document).on(SV_PRESET_DATA_READY, function(e) {

            var presets = e.presets;

            $(document).data(DATA_PRESET_LIST_KEY, presets);
            // use default preset only if preference has not been saved/restored
            var presetUri = $(document).data(DATA_PRESET_METADATA_KEY);

            // check if preset is valid
            var presetData = findPresetData(presetUri);
            if (!presetData) {
                presetData = e.defaultPreset;
            }

            applyPresetData(presetData);
        });

        /**
         * Upon preset selected event, retain the current preset and display on the header bar.
         */

        $(document).on(SV_PRESET_SELECTED, function(e) {
            // TODO: program to close upon click on any items
            $(SV_SELECTPRESET).hide();
            if (e.preset) {
                // save refer for preview
                curPresetData = e.preset;
                // save preset selection for saving to JCR
                $(document).data(DATA_PRESET_METADATA_KEY, curPresetData.uri);
                // Update preset name to menu bar
                displayPresetName(curPresetData.id);
            }
        });

        /**
         * Handler for the event triggered when preset preview is ready.  The intention is to resize the preview
         * dialog for optimal aspect ratio, yet observing the explicitly specified dimensions in the CSS if any.
         */
        $(document).on(SV_PRESET_PREVIEW_READY, function(e) {
            // Preview size adjustment is a tricky task as we are trying to impose some max-width and
            // max-height restrictions from design stage and yet try to preserve the width and height
            // in pixels or percentage if they were included in the CSS defined by user.
            // As the viewer intelligently tries to adjust responsively to the hosting <div> size according
            // to its width, a work-around is needed as a combination of both CSS styles and coding in the
            // initComplete handler.  Additional styles applied in this function must be removed before
            // the next preview such that the next preview with a different preset will function correctly.
            // For relative size from preset (e.g. width:50%, height:50%), override viewer width and height to
            // 100% retain size after initial resizing of the viewer's outer container

            var $divAsset = $(SV_ASSET_PRESET_PREVIEW);
            var outerContainer = document.querySelector(SV_PREVIEW_VIEWER);
            var outerWidth = outerContainer.offsetWidth;
            var outerHeight = outerContainer.offsetHeight;
            var container = e.viewer.getComponent("container");
            var assetWidth = $divAsset.width();
            var assetHeight = $divAsset.height();
            var headerHeight = document.querySelector(SV_PREVIEW_HEADER).offsetHeight;

            if (outerWidth > container.getWidth()) {
                outerContainer.style.width = container.getWidth() + "px";

                // check if viewer has relative size
                if (assetWidth > $divAsset.width()) {
                    $divAsset.css("width", "100%");
                }
            }

            if (outerHeight > container.getHeight()) {
                outerContainer.style.height = container.getHeight() + "px";

                // check if viewer has relative size
                if (assetHeight > $divAsset.height()) {
                    $divAsset.css("height", "100%");
                }
            }

            var $div = $(SV_PREVIEW_DIALOG);
            if ($div.width() != assetWidth) {
                $div.width(assetWidth);
            }
            if ($div.height() != assetHeight + headerHeight) {
                $div.height("height", assetHeight + headerHeight);
            }

            // center the dialog
            $(SV_PREVIEW + " coral-dialog-content").css("overflow","visible");
            $div.css("margin", "auto");

            document.querySelector(SV_PREVIEW).show();
        });
        /**
         * Create a new segment.  Deselect previous segment select to ensure only newly created segment will be
         * the only selected segment.
         */
        $(SV_BTN_ADDSEGMENT).click( function() {
            // deselect previously selected segments
            toggleSelect(null);
            removeSelectedSegment(null);

            addNewSegment();
        });
        /**
         *
         */
        $(document).on(SV_VIDEO_SEEK_EVENT, function(e){
            updateStatus(e.s7event.data);
        });
        /**
         * Label the Delete button with "Delete Product" upon the event triggered by selecting a product
         * in a segment.
         */
        $(document).on(SV_EVENT_TIMELINE_ASSET_SELECTED, function(e) {
            $(SV_BTN_DELETE).prop(SV_DISABLED_PROPERTY, false);
            $(SV_BTN_DELETE)[0].label.textContent = Granite.I18n.get("Delete Product");
            // deselect all segments
            toggleSelect(null);
            removeSelectedSegment(null);
            SELECTED_TIMELINE_DIV = null;
            prevSelectedRowURL = e.assetUrl;
            // select only the current segment
            var segmentId = e.segmentId;
            var $segment = $(SV_TIMELINE_SEGMENT_CONTAINER + "[id='" + segmentId + "']");
            var segmentBody = $segment.find(SV_PERIOD + SV_TIMELINESEGMENTBODY);
            selectSegment($segment.get(0), false);
        });
        /**
         *
         */
        $(document).on('sv-timeline-asset-deselected', function(e) {
            prevSelectedRowURL = "";
            toggleDeleteButtonToSegment();
        });
        /**
         *
         */
        $(document).on(SV_HISTORY_POSITION_CHANGE, function(e) {
            $(SV_CONTENT + " " + SV_TIMELINE_SEGMENT_CONTAINER).remove();
            clearDragArea();
            segments = [];
            disableAllButtons();
            selectedTimelineSegments = [];
            buildSegments($.sv.getCurrentState());
        });

        $(".actionRadioButton").attr("aria-labelledby","actionType");
        $("#btn-undo").parent().parent().attr("aria-label",Granite.I18n.get('Action Toolbar'));      
        $(".sv-wizard-left").attr({"aria-label":Granite.I18n.get('Create Interactive Video'),"role": "main"});
        $(".sv-wizard-right").attr({"aria-label":Granite.I18n.get('Assets Selection Panel'),"role": "region"});
        $(".sv-timelinecontrols").attr({"aria-label": Granite.I18n.get('Timeline Segment'),"role": "region"});
	
	$(SV_BTN_SELECTPRESET).attr({"aria-expanded":"false","aria-haspopup":"true"});

        $(SV_BTN_SELECTPRESET).click(function(){
       	  $(SV_BTN_SELECTPRESET + SV_PRESET_POPOVER).attr("role","menu").removeAttr("aria-live");
	  $("#viewer-preset-data").find("a[coral-list-item]").attr("role","menuitem");
        });
    })
}(document, Granite.$));
