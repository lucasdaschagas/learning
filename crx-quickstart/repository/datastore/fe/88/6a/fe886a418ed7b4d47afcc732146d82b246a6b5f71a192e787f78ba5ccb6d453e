/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2012 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 **************************************************************************/

/**
 * @class CUI.rte.DomCleanup
 * This class implements a DOM-based cleanup module to ensure that the input can be
 * processed and the output is suitable for persisting it (the actual HTML is generated by
 * the component's {@link CUI.rte.HtmlSerializer}, which applies additional rules to
 * cleanup the generated HTML).
 * @constructor
 * Creates a new DomCleanup.
 * @param {Object} config The kernel's configuration
 */
/* global Class: true */
/* jshint strict: false */
(function (CUI) {
  //'use strict';
  CUI.rte.DomCleanup = new Class({

    toString: 'DomCleanup',

    /**
     * @cfg {String[]} tagsToRemove
     * List of tags to be removed
     */
    tagsToRemove: null,

    /**
     * Rules for preprocessing pasted content. Only valid if {@link #prepareHtmlPaste} is
     * used. Format is defined at {@link CUI.rte.plugins.EditToolsPlugin#htmlPasteRules}
     * @private
     * @type Object
     */
    pasteRules: null,

    /**
     * The editor kernel we're working on
     * @private
     * @type CUI.rte.EditorKernel
     */
    editorKernel: null,

    /**
     * The edit context we're working in
     * @private
     * @type CUI.rte.EditContext
     */
    context: null,

    /**
     * The current HTML rules
     * @private
     * @type CUI.rte.HtmlRules
     */
    htmlRules: null,

    /**
     * Processing mode; as defined by the constants of this class.
     * @private
     * @type Number
     */
    processingMode: null,

    /**
     * Array of DOM elements to be removed after traversing the DOM tree
     * @private
     * @type HTMLElement[]
     */
    elementsToRemove: null,

    /**
     * Array of sub tree roots to be removed
     * @private
     * @type HTMLElement[]
     */
    subTreesToRemove: null,

    /**
     * Array of DOM elements to be changed after traversing the DOM tree. Each array
     * element has a domToChange property that determines the element to be changed, and
     * a changedDom property that defines the changed element.
     * @private
     * @type Object[]
     */
    elementsToChange: null,

    /**
     * Array of DOM elements to be inserted after traversing the DOM tree. Each array
     * element has a domToInsert property that determines the element to be inserted, a
     * parentDom property that defines the parent element it gets appended to, and an
     * (optional) refDom property that determines the sibling element the new element gets
     * inserted before
     */
    elementsToInsert: null,

    /**
     * Array of empty editing blocks that have to be "fixed for editing" on IE
     */
    emptyBlocksIE: null,


    construct: function (config) {
      CUI.rte.Utils.apply(this, config);
    },


    // -- Helpers --------------------------------------------------------------------------

    /**
     * <p>Marks the specified DOM element for being removed.</p>
     * <p>Using this method prevents that the same DOM element is added multiple times
     * to the list of elements to be removed.</p>
     * @param {HTMLElement} dom The DOM element to be removed
     */
    markForRemoval: function (dom) {
      if (!CUI.rte.Common.arrayContains(this.elementsToRemove, dom)) {
        this.elementsToRemove.push(dom);
      }
    },

    /**
     * Marks the sub tree that starts at the specified DOM element for being deleted. The
     * specified element will get deleted as well.
     * @param {HTMLElement} root The root element of the sub tree to be marked for removal
     */
    markSubTreeForRemoval: function (root) {
      this.subTreesToRemove.push(root);
    },

    /**
     * Marks the specified DOM element for be inserted according the specified rules.
     * @param {HTMLElement} dom The element to be inserted
     * @param {HTMLElement} parentDom The parent element
     * @param {HTMLElement} siblingRef (optional) The element the new element is inserted
     *        before; if not specified, the DOM element will be appended
     */
    markForInsertion: function (dom, parentDom, siblingRef) {
      this.elementsToInsert.push({
        'domToInsert': dom,
        'parentDom': parentDom,
        'refDom': siblingRef
      });
    },

    /**
     * <p>Checks if we are doing any preprocessing.</p>
     * <p>This method returns true for "default" preprocessing, but also for paste
     * preprocessing.</p>
     * @return {Boolean} True if any kind of preprocessing is currently executed
     */
    isPreProcessing: function () {
      var dcu = CUI.rte.DomCleanup;
      return (this.processingMode === dcu.PASTE_PREPARE) || (this.processingMode === dcu.PRE);
    },

    /**
     * Flattens the specified DOM element by creating paragraphs from the specified
     * container structures and removing nested structures of the specified type.
     * @param {HTMLElement} dom The DOM element to be flattened
     * @param {String|String[]} tagsToFlatten Defines the tag or tags that contain content
     *        to be flattened; for example: "li" for list items
     * @param {String|String[]} nestingTags Defines the tag or tags that mark nested
     *        striucture; for example: "table" for nested tables
     * @return {HTMLElement} The first flattened element (changed container element)
     */
    flattenNestedStructure: function (dom, tagsToFlatten, nestingTags) {
      var com = CUI.rte.Common;
      var continueDom = null;
      var parentRef = dom.parentNode;
      var insertRef = dom.nextSibling;
      var replacementTag = this.pasteRules.fallbackBlockTag || 'p';
      var nodesToFlatten = com.getTags(dom, tagsToFlatten);
      var nodeCnt = nodesToFlatten.length;
      for (var n = 0; n < nodeCnt; n++) {
        var domToFlatten = nodesToFlatten[n];
        var flattenedDom = this.context.createElement(replacementTag);
        if (continueDom === null || continueDom === undefined) {
          continueDom = flattenedDom;
        }
        com.insertBefore(parentRef, flattenedDom, insertRef);
        // move children - skip nested containers (nested content elements are already
        // included in nodesToFlatten)
        var children = domToFlatten.childNodes;
        while (children.length > 0) {
          var childToMove = children[0];
          if (!com.isTag(childToMove, nestingTags)) {
            flattenedDom.appendChild(childToMove);
          }
        }
      }
      dom.parentNode.removeChild(dom);
      return continueDom;
    },


    // -- Processing methods ---------------------------------------------------------------

    /**
     * <p>Checks if the specified DOM element marks the root of a valid sub tree in the DOM.
     * </p>
     * <p>If the method returns false, the entire sub tree gets removed, including the
     * specified DOM element.</p>
     * <p>If the method returns false, ancestor elements or sub trees can still be
     * declared invalid.</p>
     * @param {HTMLElement} dom The DOM element to check
     * @return {Boolean} True if the sub tree starting at the specified element is
     *         considered valid
     */
    isValidSubTree: function (dom) {
      var com = CUI.rte.Common;
      var isValid = true;
      // handle temporary elements first
      var tempAttrib = com.getAttribute(dom, com.TEMP_EL_ATTRIB, true);
      if (tempAttrib) {
        var splitAttrib = tempAttrib.split(':');
        var keepChildren = com.arrayContains(splitAttrib, 'keepChildren');
        var emptyOnly = com.arrayContains(splitAttrib, 'emptyOnly');
        if (!keepChildren) {
          if (emptyOnly) {
            // check for emptiness has to be executed recursively
            var checkEmpty = function (dom) {
              if (dom.nodeType === 3) {
                return false;
              }
              var childCnt = dom.childNodes.length;
              if (childCnt === 0) {
                return true;
              }
              for (var c = 0; c < childCnt; c++) {
                var child = dom.childNodes[c];
                var tempAttrib = com.getAttribute(dom, com.TEMP_EL_ATTRIB,
                  true);
                if (!tempAttrib) {
                  return false;
                }
                var splitAttrib = tempAttrib.split(':');
                if (com.arrayContains(splitAttrib, 'emptyOnly')) {
                  if (!checkEmpty(child)) {
                    return false;
                  }
                } else {
                  return false;
                }
              }
              return true;
            };
            if (checkEmpty(dom)) {
              isValid = false;
            } else {
              com.removeAttribute(dom, com.TEMP_EL_ATTRIB);
            }
          } else {
            isValid = false;
          }
        }
      }
      return isValid;
    },

    /**
     * <p>Checks if the specified DOM element is valid according to current rules.</p>
     * <p>Note that - contrary to {@link #isValidSubTree} - this method only removes
     * the specified element (if false is returned) and leaves the ancestor elements intact.
     * </p>
     * @param {HTMLElement} dom The DOM element to check
     * @return {Boolean} True if the DOM element is considered valid
     */
    isValidElement: function (dom) {
      var com = CUI.rte.Common;
      var tagName = dom.tagName.toLowerCase();
      // ignore namespaced tags
      var namespace = com.getNamespace(dom);
      if (namespace !== null && namespace !== undefined) {
        return false;
      }
      // IE issue: orphaned empty tags are not ignored, instead IE creates invalid DOM
      // elements from them, so we need to remove them
      if ((dom.nodeType === 1) && com.strStartsWith(dom.tagName, '/')) {
        return false;
      }
      // ignore blacklisted tags
      if (this.tagsToRemove) {
        if (com.arrayContains(this.tagsToRemove, tagName)) {
          return false;
        }
      }
      // ignore elements with "_rtetemp" attribute
      if (com.isTag(dom, 'span') && com.isAttribDefined(dom, '_rtetemp')) {
        return false;
      }
      // ignore temporary elements that keep child nodes
      var tempAttrib = com.getAttribute(dom, com.TEMP_EL_ATTRIB, true);
      if (tempAttrib) {
        var splitAttrib = tempAttrib.split(':');
        var keepChildren = com.arrayContains(splitAttrib, 'keepChildren');
        if (keepChildren) {
          return false;
        }
      }
      return true;
    },

    /**
     * <p>Change linefeeds in preformatted sections into "br" tags - although this is
     * no correct HTML, browsers tend to be more stable with br tags (and selection handling
     * is much easier) while editing.</p>
     */
    handlePreformattedSection: function (dom) {
      var context = this.context;
      var com = CUI.rte.Common;
      if (this.isPreProcessing()) {
        if (com.isTag(dom, 'pre')) {
          var recurse = function (toProcess) {
            var parentNode = toProcess.parentNode;
            if (toProcess.nodeType === 3) {
              var nodeText = toProcess.nodeValue;
              nodeText = nodeText.replace(/\r\n/g, '\n');
              nodeText = nodeText.replace(/\r/g, '\n');
              var pos;
              do {
                pos = nodeText.indexOf('\n');
                if (pos >= 0) {
                  if (pos > 0) {
                    parentNode.insertBefore(context.createTextNode(
                      nodeText.substring(0, pos)), toProcess);
                  }
                  parentNode.insertBefore(context.createElement('br'),
                    toProcess);
                  nodeText = nodeText.substring(pos + 1, nodeText.length);
                }
              } while (pos >= 0);
              if (nodeText.length === 0) {
                parentNode.removeChild(toProcess);
              } else {
                toProcess.nodeValue = nodeText;
              }
            } else if (toProcess.nodeType === 1) {
              var childCnt = toProcess.childNodes.length;
              for (var c = childCnt - 1; c >= 0; c--) {
                recurse(toProcess.childNodes[c]);
              }
            }
          };
          recurse(dom);
          // remove trailing br (if there is one), as it is implied by the closing
          // pre tag
          var lastTextChild = com.getLastTextChild(dom, true, false);
          if (com.isTag(lastTextChild, 'br')) {
            var predesc = com.getPreviousCharacterNode(context, lastTextChild,
              com.EDITBLOCK_TAGS);
            if (com.isTag(predesc, 'br')) {
              if (com.ua.isGecko || com.ua.isWebKit || com.ua.isIEBRPlaceholder) {
                com.setAttribute(lastTextChild, com.BR_TEMP_ATTRIB, 'brEOB');
              } else if (com.ua.isIE) {
                lastTextChild.parentNode.removeChild(lastTextChild);
                CUI.rte.DomProcessor.fixEmptyLinefeedIE(context, predesc);
              }
            } else {
              lastTextChild.parentNode.removeChild(lastTextChild);
            }
          }
        }
      } else {
        // change "\n"'s into "br"s inside "pre" blocks, as browsers tend to be more
        // stable when linefeeds are still represented as "br" while editing
        // (counterpart is in handlePreformattedSection)
        if (com.isTag(dom, 'br') && com.getTagInPath(this.context, dom, 'pre')) {
          this.elementsToChange.push({
            'domToChange': dom,
            'changedDom': this.context.createTextNode('\n')
          });
        }
      }
    },

    /**
     * <p>Handles empty lines at the end of blocks for the browsers that require it
     * (currently WebKit and Gecko).</p>
     * <p>Additional "br" tags get removed on reverse cleanup again (see isValidElement).
     * </p>
     * @param {HTMLElement} dom The
     */
    handleEmptyLinesAtEOB: function (dom) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var brReplacement;
      if (this.isPreProcessing()) {
        var text = com.getNodeText(dom);
        if ((text === dpr.NBSP) && dpr.isBlockEnd(this.context, dom)) {
          if (com.ua.isWebKit || com.ua.isGecko || com.ua.isIEBRPlaceholder) {
            // Gecko/WebKit: replace &nbsp;s that are placeholders for empty lines
            // at the end of a block by appropriately marked additional <br>s
            brReplacement = this.context.createElement('br');
            com.setAttribute(brReplacement, com.BR_TEMP_ATTRIB, 'brEOB');
            this.elementsToChange.push({
              'domToChange': dom,
              'changedDom': brReplacement
            });
          } else if (com.ua.isIE) {
            // IE: remove &nbsp;s that are placeholders for empty blocks
            var prevNode = com.getPreviousCharacterNode(this.context, dom,
              com.EDITBLOCK_TAGS);
            if (com.isTag(prevNode, 'br')) {
              // placeholder for empty line at the end of an empty block
              this.markForRemoval(dom);
              dpr.fixEmptyLinefeedIE(this.context, prevNode);
            } else if (!prevNode) {
              this.markForRemoval(dom);
              var block = dpr.getEditBlock(this.context, dom);
              this.emptyBlocksIE.push(block);
            }
          }
        }
      } else {
        if (com.ua.isGecko || com.ua.isWebKit || com.ua.isIEBRPlaceholder) {
          // Gecko/Webkit: Remove unnecessary <br> nodes; replace them by &nbsp;s
          // if they are placeholders for empty lines at the end of a block;
          // "br"s in "pre" areas are handled in handlePreformattedSection()
          if (com.isTag(dom, 'br') && !com.getTagInPath(this.context, dom, 'pre')) {
            var editBlock = com.getTagInPath(this.context, dom, com.EDITBLOCK_TAGS);
            var isEmptyBlock =
              editBlock && (com.getCharacterNodes(editBlock).length === 1);
            if (isEmptyBlock) {
              this.markForRemoval(dom);
            } else {
              var isMarkedDirty = com.isAttribDefined(dom, com.BR_TEMP_ATTRIB) ||
                com.hasAttributes(dom, {'type': '_moz'});
              if (isMarkedDirty && dpr.isBlockEnd(this.context, dom)) {
                this.elementsToChange.push({
                  'domToChange': dom,
                  'changedDom': this.context.createTextNode(dpr.NBSP)
                });
              }
            }
          }
        } else if (com.ua.isIE) {
          // IE: Add &nbsp; if required
          if (com.isTag(dom, 'br') && dpr.isBlockEnd(this.context, dom)) {
            var nbsp = this.context.createTextNode(dpr.NBSP);
            this.markForInsertion(nbsp, dom.parentNode);
          }
        }
      }
    },

    /**
     * Enforces HTML rules on the specified DOM element.
     * @param {HTMLElement} dom The DOM element to apply rules to
     * @return {Boolean} True if the DOM element was marked for removal
     */
    applyHtmlRules: function (dom) {
      // todo maybe we should move an extended version of this method to HtmlRules for common use?
      var com = CUI.rte.Common;
      // adjust tag names to more appropriate (regarding editing) tag names if
      // necessary
      var tagName = dom.tagName.toLowerCase();
      var changedTagName = (this.isPreProcessing() ?
        this.htmlRules.docType.adjustToRaw(tagName)
        : this.htmlRules.docType.adjustToDocType(tagName));
      var changedDom, idAttrib, classAttrib;
      if (changedTagName !== null && changedTagName !== undefined) {
        if (changedTagName.length > 0) {
          changedDom = this.context.createElement(changedTagName);
          idAttrib = com.getAttribute(dom, 'id', true);
          classAttrib = com.getAttribute(dom, 'class', true);
          if (idAttrib) {
            com.setAttribute(changedDom, 'id', idAttrib);
          }
          if (classAttrib) {
            com.setAttribute(changedDom, 'class', classAttrib);
          }
          this.elementsToChange.push({
            'domToChange': dom,
            'changedDom': changedDom
          });
        } else { //#37049 - remove blacklisted tags
          this.elementsToRemove.push(dom);
          return true;
        }
        return false;
      }
      if (this.isPreProcessing()) {
        // handle links (add attributes as specified by rules, remove links with invalid
        // HREFs)
        if (com.isTag(dom, 'a')) {
          var href = com.getAttribute(dom, 'href');
          if (href) {
            if (this.htmlRules.links.validateHref(href)) {
              this.htmlRules.links.applyToObject(dom);
              return false;
            } else {
              this.markForRemoval(dom);
              return true;
            }
          }
        }
      }
      return false;
    },

    /**
     * <p>Handles alignment for the specified DOM element.</p>
     * <p>It is ensured that for several block tags the "style" attribute is used rather
     * than the "align" attribute (due to editing restrictions of several browsers).</p>
     * @param {HTMLElement} dom The DOM element to process
     */
    handleAlignment: function (dom) {
      var com = CUI.rte.Common;
      // currently, we only do this for div/p tags
      var tagsToHandle = ['p', 'div'];
      if (com.isTag(dom, tagsToHandle)) {
        if (this.isPreProcessing()) {
          var alignAttrib = com.getAttribute(dom, 'align', true);
          if (alignAttrib) {
            com.removeAttribute(dom, 'align');
            dom.style.textAlign = alignAttrib;
          }
        }
      }
    },

    /**
     * <p>Handles "a" elements.</p>
     * <p>For named anchors, this means that a suitable CSS class is applied or removed.
     * Additionally, the DOM will be changed to meet editing requirements if necessary.</p>
     * <p>For links, a RTE-specific property is added that holds the original HREF. On
     * postprocessing, this RTE-specific property is moved to the HREF attribute again.</p>
     * <p>You can specify any DOM element, as the element is checked before it is
     * actually processed.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleAnchor: function (dom) {
      var com = CUI.rte.Common;
      var dcu = CUI.rte.DomCleanup;
      var idAttrib, nameAttrib;
      if (com.isTag(dom, 'a')) {
        // using id attribute since html5 dosen't supports name attribute anymore
        idAttrib = com.getAttribute(dom, 'id', true);
        nameAttrib = com.getAttribute(dom, 'name', true);
        var hrefAttrib = CUI.rte.HtmlRules.Links.getLinkHref(dom);
        var linkPlugin = this.editorKernel.registeredPlugins.links;
        var anchorEditingStyle;
        if (linkPlugin) {
          anchorEditingStyle = linkPlugin.getConfig().anchorEditingStyle;
        }
        if (hrefAttrib) {
          if (this.processingMode === dcu.PASTE_PREPARE) {
            var helperAttrib = com.getAttribute(dom, com.HREF_ATTRIB);
            if (!helperAttrib) {
              com.setAttribute(dom, com.HREF_ATTRIB, hrefAttrib);
            }
          }
        } else if (idAttrib || nameAttrib) {
          if (this.isPreProcessing()) {
            // change <a id="bla">text</a> to <a id="bla"></a>text
            var children = dom.childNodes;
            var parentDom = dom.parentNode;
            var insertRef = dom.nextSibling;
            while (children.length > 0) {
              com.insertBefore(parentDom, children[0], insertRef);
            }
            var imgReplacement = this.context.createElement('img');
            com.setAttribute(imgReplacement, 'src',
              CUI.rte.Utils.getBlankImageUrl());
            // If both id and name exist, id should be preferred as name attribute for a tag is obsolete in HTML5
            // Name and id can co-exist, but should have the same value (since HTML 4).
            // We are not removing name attribute to maintain backwards compatibility considering custom css could be applied on it
            if (idAttrib) {
              // see https://www.w3.org/TR/html5/obsolete.html#obsolete-but-conforming-features
              com.setAttribute(imgReplacement, com.A_ID_REPLACEMENT_ATTRIB,
                idAttrib);
              // Set NAME_REPLACEMENT_ATTRIB (legacy) on 'img' tag equal to the value of idAttrib (since id takes precendence if both exist),
              // to maintain BC but ONLY IF name attribute was present on 'a' tag
              if (nameAttrib) {
                com.setAttribute(imgReplacement, com.A_NAME_REPLACEMENT_ATTRIB,
                  idAttrib);
              }
            } else {
              com.setAttribute(imgReplacement, com.A_ID_REPLACEMENT_ATTRIB,
                nameAttrib);
              com.setAttribute(imgReplacement, com.A_NAME_REPLACEMENT_ATTRIB,
                nameAttrib);
            }
            if (anchorEditingStyle) {
              com.setAttribute(imgReplacement, 'style', anchorEditingStyle);
            } else {
              com.addClass(imgReplacement, CUI.rte.Theme.ANCHOR_CLASS);
            }
            this.elementsToChange.push({
              'domToChange': dom,
              'changedDom': imgReplacement
            });
          } else if (this.processingMode === dcu.POST) {
            if (anchorEditingStyle) {
              com.removeAttribute(dom, 'style');
            } else {
              com.removeClass(dom, CUI.rte.Theme.ANCHOR_CLASS);
            }
          }
        }
      } else if (com.isTag(dom, 'img') &&
        com.isAttribDefined(dom, com.A_ID_REPLACEMENT_ATTRIB)) {
        if (!this.isPreProcessing()) {
          var anchorDom = this.context.createElement('a');
          idAttrib = com.getAttribute(dom, com.A_ID_REPLACEMENT_ATTRIB);
          nameAttrib = com.getAttribute(dom, com.A_NAME_REPLACEMENT_ATTRIB);
          if (nameAttrib){
            // Name and id can co-exist, but should have the same value
            com.setAttribute(anchorDom, 'name', idAttrib);
          }
    		  com.setAttribute(anchorDom, 'id', idAttrib);
          this.elementsToChange.push({
            'domToChange': dom,
            'changedDom': anchorDom
          });
        }
      }
    },

    /**
     * <p>Handles images.</p>
     * <p>Here, the SRC-attribute is doubled for editing, as browser do nasty things with
     * it.</p>
     * <p>You can specify any DOM element, as the element is checked before it is
     * actually processed.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleImage: function (dom) {
      var com = CUI.rte.Common;
      var dcu = CUI.rte.DomCleanup;
      var hr = CUI.rte.HtmlRules;
      var hpr = CUI.rte.HtmlProcessor;
      if (com.isTag(dom, 'img')) {
        var urlType = CUI.rte.Utils.URL_IMAGE;
        var srcAttrib;
        if (this.processingMode === dcu.PRE) {
          srcAttrib = com.getAttribute(dom, com.SRC_ATTRIB, true);
          srcAttrib = (srcAttrib ? srcAttrib : com.getAttribute(dom, 'src', true));
          com.setAttribute(dom, 'src', CUI.rte.Utils.processUrl(srcAttrib, urlType));
        }
        if (this.processingMode === dcu.PASTE_PREPARE) {
          srcAttrib = com.getAttribute(dom, 'src', true);
          if (srcAttrib) {
            var helperAttrib = com.getAttribute(dom, com.SRC_ATTRIB, true);
            if (!helperAttrib) {
              com.setAttribute(dom, com.SRC_ATTRIB,
                hr.removePrefixForInternalLinks(srcAttrib, urlType));
            }
          }
        }
        if (this.processingMode === dcu.POST) {
          // image width/height might be provided as style attribute (IE!), so
          // we need to normalize this before serializing
          var style = com.getAttribute(dom, 'style');
          if (style) {
            var styleDef = hpr.parseStyleDef(style);
            if (styleDef.width) {
              com.setAttribute(dom, 'width', parseInt(styleDef.width, 10));
              delete styleDef.width;
            }
            if (styleDef.height) {
              com.setAttribute(dom, 'height', parseInt(styleDef.height, 10));
              delete styleDef.height;
            }
            var styleAttr = hpr.createStyleAttrib(styleDef);
            if (styleAttr) {
              com.setAttribute(dom, 'style', styleAttr);
            } else {
              com.removeAttribute(dom, 'style');
            }
          }
        }
      }
    },

    /**
     * <p>Handles tables.</p>
     * <p>In this case, table without a border get a class added that makes the border
     * temporarily visible for editing.</p>
     * <p>You can specify any DOM element, as the element is checked before it is
     * actually processed.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleTable: function (dom) {
      var com = CUI.rte.Common;
      var dcu = CUI.rte.DomCleanup;
      if (com.isTag(dom, 'table')) {
        var borderAttrib = com.getAttribute(dom, 'border', true);
        var hasBorder = false;
        if (borderAttrib) {
          try {
            hasBorder = (parseInt(borderAttrib, 10) > 0);
          } catch (e) {
            // ignore, as we can't do anything about it
          }
        }
        if (!hasBorder) {
          if (this.isPreProcessing()) {
            com.addClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
          } else if (this.processingMode === dcu.POST) {
            com.removeClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
          }
        }
        this.handleCellSpacingAttribute(dom);
      } else if (com.isTag(dom, ['td', 'th'])) {
        if (this.processingMode === dcu.POST) {
          com.removeClass(dom, CUI.rte.Theme.TABLESELECTION_CLASS);
          if (com.isTag(dom, 'th') && com.getAttribute(dom, 'hiddenheader')) {
            var divToAdd = this.context.createElement('div');
            com.setAttribute(divToAdd, 'hiddenheader', 'true');
            com.removeAttribute(dom, 'hiddenheader');
            var tablePlugin = this.editorKernel.registeredPlugins.table;
            if (tablePlugin) {
              var hiddenHeaderConfig = tablePlugin.getHiddenHeaderConfig();
              if (hiddenHeaderConfig.hiddenHeaderClassName) {
                com.addClass(divToAdd, hiddenHeaderConfig.hiddenHeaderClassName);
              } else if (hiddenHeaderConfig.hiddenHeaderStyle) {
                com.setAttribute(divToAdd, 'style', hiddenHeaderConfig.hiddenHeaderStyle);
              }
              if (hiddenHeaderConfig.hiddenHeaderEditingCSS) {
                com.removeClass(dom, hiddenHeaderConfig.hiddenHeaderEditingCSS);
              } else {
                var stylesToRemove = [];
                var editingStyle = hiddenHeaderConfig.hiddenHeaderEditingStyle;
                editingStyle = editingStyle.trim();
                var attributes = editingStyle.split(';');
                for (var i = 0; i < attributes.length; i++) {
                  var propNameValue = attributes[i].split(':');
                  if (propNameValue.length === 2) {
                    var propName = propNameValue[0].trim();
                    if (propName.length) {
                      stylesToRemove.push(propName);
                    }
                  }
                }
                com.removeInlineStyles(dom, stylesToRemove);
              }
            }
            while(dom.firstChild) {
              divToAdd.appendChild(dom.firstChild);
            }
            dom.appendChild((divToAdd));
          }
        } else if (this.processingMode === dcu.PRE) {
          var tblPlugin = this.editorKernel.registeredPlugins.table;
          if (tblPlugin) {
            var hiddenHeaderConfiguration = tblPlugin.getHiddenHeaderConfig();
            if (hiddenHeaderConfiguration && dom.childNodes.length === 1 && hiddenHeaderConfiguration.hiddenHeaderClassName && dom.firstChild.className === hiddenHeaderConfiguration.hiddenHeaderClassName) {
              dom.classList.add('cq-RichText-hiddenHeader--editing');
              com.setAttribute(dom, 'hiddenheader', 'true');
              var innerChildData = dom.firstChild.firstChild;
              dom.removeChild(dom.firstChild);
              dom.appendChild(innerChildData);
            }
          }
        }
      }
    },

    /**
     * @private
     */
    handleCellSpacingAttribute: function (dom) {
      return;
    },

    /**
     * <p>Handles lists.</p>
     * <p>It is ensured that nested lists are correctly structured.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleList: function (dom) {
      var com = CUI.rte.Common;
      var lut = CUI.rte.ListUtils;
      if (com.isTag(dom, com.LIST_TAGS)) {
        if (lut.isTopLevelList(this.context, dom)) {
          var listProcessor = new CUI.rte.ListRepresentation();
          listProcessor.fromItem(this.context, dom);
          listProcessor.ensureHierarchy(this.context);
        }
      }
    },

    /**
     * <p>Handles style information in the style attribute of span elements.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleSpanStyles: function (dom) {
      var com = CUI.rte.Common;
      if (this.isPreProcessing()) {
        if (com.isTag(dom, 'span')) {
          var changedDom, changeDef;
          if (dom.style.fontWeight === 'bold') {
            changedDom = this.context.createElement('b');
            changeDef = {
              'domToChange': dom,
              'changedDom': changedDom
            };
          }
          if (dom.style.fontStyle === 'italic') {
            var italicDom = this.context.createElement('i');
            if (changedDom) {
              changedDom.appendChild(italicDom);
              changeDef.childDom = italicDom;
            } else {
              changedDom = italicDom;
              changeDef = {
                'domToChange': dom,
                'changedDom': changedDom
              };
            }
          }
          if (dom.style.textDecoration === 'underline') {
            var underlineDom = this.context.createElement('u');
            if (changedDom) {
              if (changeDef.childDom) {
                changeDef.childDom.appendChild(underlineDom);
              } else {
                changedDom.appendChild(underlineDom);
              }
              changeDef.childDom = underlineDom;
            } else {
              changedDom = underlineDom;
              changeDef = {
                'domToChange': dom,
                'changedDom': changedDom
              };
            }
          }
          if (changeDef) {
            this.elementsToChange.push(changeDef);
          }
        }
      }
    },

    handleDiv: function (dom) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      if (this.isPreProcessing()) {
        if (com.isTag(dom, 'div') && com.getAttribute(dom, 'hiddenheader') === 'true') {
          var tablePlugin = this.editorKernel.registeredPlugins.table;
          if (tablePlugin) {
            var hiddenHeaderConfig = tablePlugin.getHiddenHeaderConfig();
            if (hiddenHeaderConfig.hiddenHeaderEditingCSS) {
              com.addClass(dom.parentNode, hiddenHeaderConfig.hiddenHeaderEditingCSS);
            } else {
              com.addInlineStyles(dom.parentNode, hiddenHeaderConfig.hiddenHeaderEditingStyle);
            }
          }
          com.setAttribute(dom.parentNode, 'hiddenheader', 'true');
          dpr.removeWithoutChildren(dom);
        }
      }

    },

    handleFont: function (dom) {
      var com = CUI.rte.Common;
      if (!this.isPreProcessing()) {
        // remove empty font tags (workaround for Chrome issue with fonts)
        if (com.isTag(dom, 'font')) {
          if (!com.hasTextChild(dom, true)) {
            this.elementsToRemove.push(dom);
          }
        }
      }
    },

    /**
     * This method handles several specific tags.
     * @param {HTMLElement} dom The DOM element
     */
    handleSpecificTags: function (dom) {
      this.handleAlignment(dom);
      this.handleAnchor(dom);
      this.handleImage(dom);
      this.handleTable(dom);
      this.handleSpanStyles(dom);
      this.handleDiv(dom);
      this.handleList(dom);
      this.handlePreformattedSection(dom);
      this.handleFont(dom);

      //executes any pluggued processor
      var processors = CUI.rte.DomCleanup.pluggableDomProcessors;
      if (processors !== null) {
        for (var i = 0; i < processors.length; i++) {
          var processor = processors[i];
          if (processor) {
            processor.call(this, dom);
          }
        }
      }
    },

    /**
     * This method handles empty content.
     * @param {HTMLElement} rootDom The root DOM
     */
    handleEmptyContent: function (rootDom) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var dcu = CUI.rte.DomCleanup;
      if (this.processingMode === dcu.PRE) {
        if (rootDom.childNodes.length === 0) {
          var placeholder = dpr.createEmptyLinePlaceholder(this.context, true,
            this.htmlRules.blockHandling.defaultEditBlockType);
          rootDom.appendChild(placeholder);
        } else if (rootDom.childNodes.length === 1) {
          // newer Firefox versions automatically change an empty string set as
          // innerHTML into a single <br> node (which is corrected into <p><br></p>
          // by handleContainerRules
          var blockNode = rootDom.childNodes[0];
          var textNodes = com.getCharacterNodes(blockNode);
          if ((textNodes.length === 1) && com.isTag(textNodes[0], 'br')) {
            com.setAttribute(textNodes[0], com.BR_TEMP_ATTRIB, 'brEOB');
          }
        }
      } else if (this.processingMode === dcu.POST) {
        if (rootDom.childNodes.length === 1) {
          var singleChild = rootDom.childNodes[0];
          if (com.isTag(singleChild, com.EDITBLOCK_TAGS)) {
            if (dpr.isEmptyLineBlock(singleChild)) {
              rootDom.removeChild(singleChild);
            }
          }
        }
      }
    },


    /**
     * Handles container-related HTML rules, such as removing the block around a single
     * content block if configured accordingly.
     * @param {HTMLElement} rootDom The root DOM
     */
    handleContainerRules: function (rootDom) {
      var com = CUI.rte.Common;
      var dpr = CUI.rte.DomProcessor;
      var dcu = CUI.rte.DomCleanup;
      var blockRules = this.htmlRules.blockHandling;
      var tableRules = this.htmlRules.tableHandling;
      var defaultEditBlock = blockRules.defaultEditBlockType;
      var blockRepTag = blockRules.singleParagraphContainerReplacement;
      if (this.processingMode === dcu.PRE) {
        dpr.ensureBlockContent(this.context, defaultEditBlock, null, false, false);
        dpr.adjustTables(this.context, tableRules);
        var fixIECnt = this.emptyBlocksIE.length;
        for (var i = 0; i < fixIECnt; i++) {
          dpr.fixEmptyEditingBlockIE(this.context, this.emptyBlocksIE[i]);
        }
      } else if (this.processingMode === dcu.POST) {
        if (blockRules.removeSingleParagraphContainer) {
          var rootElCnt = rootDom.childNodes.length;
          if (rootElCnt === 1) {
            var blockDom = rootDom.childNodes[0];
            if (com.isTag(blockDom, defaultEditBlock)) {
              var bStyle = blockDom.style;
              var blockClass = com.getAttribute(blockDom, 'class', true);
              if (blockClass || bStyle.textAlign || bStyle.marginLeft) {
                // change tag, as there are properties to keep on the single
                // block
                if (defaultEditBlock !== blockRepTag) {
                  var newBlockDom = this.context.createElement(blockRepTag);
                  if (blockClass) {
                    com.setAttribute(newBlockDom, 'class', blockClass);
                  }
                  if (bStyle.textAlign) {
                    newBlockDom.style.textAlign = bStyle.textAlign;
                  }
                  if (bStyle.marginLeft) {
                    newBlockDom.style.marginLeft = bStyle.marginLeft;
                  }
                  com.replaceNode(blockDom, newBlockDom);
                }
              } else {
                // nothing to keep, so we'll simply remove the single block
                dpr.removeWithoutChildren(blockDom);
              }
            }
          }
        }
      }
    },


    // -- Additional paste processing ------------------------------------------------------

    /**
     * Checks if the specified element is allowed for tags and marks it for removal if not.
     * @param {HTMLElement} dom The element to check
     * @return {HTMLElement} The element or null if the element has been marked for removal
     */
    checkAllowedForPaste: function (dom) {
      var com = CUI.rte.Common;
      var markForRemoval = true;
      // tags that are always allowed
      var defaultAllowedTags = ['br'];
      // tags that are considered "basic tags"
      var basicTags = {
        'b': 'bold',
        'i': 'italic',
        'u': 'underline',
        'a': 'anchor',
        'img': 'image',
        'sub': 'subscript',
        'sup': 'superscript',
        's':'strikethrough'
      };
      var basicTagDef = null;
      if (this.pasteRules.allowBasics) {
        var tagNameLC = dom.tagName.toLowerCase();
        if (basicTags.hasOwnProperty(tagNameLC)) {
          basicTagDef = basicTags[tagNameLC];
        }
      }
      if (this.pasteRules.table) {
        if ((this.pasteRules.table.allow) ||
          (this.pasteRules.table.ignoreMode === 'paragraph')) {
          defaultAllowedTags.push('table');
          defaultAllowedTags.push('tbody');
          defaultAllowedTags.push('tr');
          defaultAllowedTags.push('td');
          defaultAllowedTags.push('th');
        }
      }
      if (this.pasteRules.list) {
        if ((this.pasteRules.list.allow) ||
          (this.pasteRules.list.ignoreMode === 'paragraph')) {
          defaultAllowedTags.push('ul');
          defaultAllowedTags.push('ol');
          defaultAllowedTags.push('li');
        }
      }
      if (basicTagDef !== null && basicTagDef !== undefined) {
        markForRemoval = (this.pasteRules.allowBasics[basicTagDef] !== true);
      } else if (com.isTag(dom, defaultAllowedTags)) {
        markForRemoval = false;
      } else if (com.isTag(dom, com.BLOCK_TAGS)) {
        // block tags are handled differently
        markForRemoval = false;
      } else if (com.isTag(dom, 'span') && (com.parseCSS(dom).length > 0)) { // exception for span if it has css classes assigned
        markForRemoval = false;
      }
      if (markForRemoval) {
        this.elementsToRemove.push(dom);
        return null;
      }
      return dom;
    },

    /**
     * Applies table-specific paste-rules.
     * @param {HTMLElement} dom The table's DOM element
     * @return {HTMLElement} The DOM element to continue processing with
     */
    handleTablesOnPaste: function (dom) {
      var com = CUI.rte.Common;
      var tableRules = this.pasteRules.table;
      if (tableRules.allow) {
        return dom;
      }
      if (tableRules.ignoreMode === 'remove') {
        // delete child nodes directly to avoid unnecessary processing, and mark
        // table itself for removal
        com.removeAllChildren(dom);
        this.markForRemoval(dom);
        return dom;
      }
      return this.flattenNestedStructure(dom, com.TABLE_CELLS, 'table');
    },

    /**
     * Applies list-specific paste-rules.
     * @param {HTMLElement} dom The table's DOM element
     * @return {HTMLElement} The DOM element to continue processing with
     */
    handleListsOnPaste: function (dom) {
      var com = CUI.rte.Common;
      var listRules = this.pasteRules.list;
      if (listRules.allow) {
        return dom;
      }
      if (listRules.ignoreMode === 'remove') {
        // delete child nodes directly to avoid unnecessary processing, and mark
        // list itself for removal
        com.removeAllChildren(dom);
        this.markForRemoval(dom);
        return dom;
      }
      return this.flattenNestedStructure(dom, 'li', com.LIST_TAGS);
    },

    /**
     * Checks if the specified DOM element is a block tag and changes it according to the
     * paste rules if necessary.
     * @param {HTMLElement} dom The DOM element
     */
    handleBlockTagsOnPaste: function (dom) {
      var com = CUI.rte.Common;
      if (com.isTag(dom, com.BLOCK_TAGS)) {
        var tagNameLC = dom.tagName.toLowerCase();
        // tables and lists must be handled specifically if a rule is available
        if (com.isTag(dom, 'table') && this.pasteRules.table) {
          return this.handleTablesOnPaste(dom);
        }
        if (com.isTag(dom, com.LIST_TAGS) && this.pasteRules.list) {
          return this.handleListsOnPaste(dom);
        }
        var mustChange = true;
        if (this.pasteRules.allowBlockTags) {
          mustChange = !com.arrayContains(this.pasteRules.allowBlockTags, tagNameLC);
        }
        if (mustChange) {
          var fallbackTag = this.pasteRules.fallbackBlockTag || 'p';
          var changedDom = this.context.createElement(fallbackTag);
          this.elementsToChange.push({
            'domToChange': dom,
            'changedDom': changedDom
          });
        }
      }
    },

    /**
     * Handles "class" attributes of elements due to the paste rules defined.
     * @param {HTMLElement} dom The DOM element
     */
    handleCssClassesOnPaste: function (dom) {
      var com = CUI.rte.Common;
      var cssMode = (this.pasteRules.cssMode || 'remove');
      var cssClasses = com.parseCSS(dom);
      if (cssClasses && (cssClasses.length > 0)) {
        switch (cssMode) {
        case 'remove':
          com.removeAttribute(dom, 'class');
          break;
        case 'whitelist':
          var allowedClasses = this.pasteRules.allowedCssNames || [];

          // get allowed classes from plugin
          if (this.editorKernel.registeredPlugins.styles) {
            var stylesFromPlugin = this.editorKernel.registeredPlugins.styles.getStyles() || [];

            for (var i = 0; i < stylesFromPlugin.length; i++) {
              allowedClasses.push(stylesFromPlugin[i].cssName);
            }
          }

          var classCnt = cssClasses.length;
          for (var c = 0; c < classCnt; c++) {
            var classToCheck = cssClasses[c];
            if (!com.arrayContains(allowedClasses, classToCheck)) {
              com.removeClass(dom, classToCheck);
            }
          }
          break;
        }
      }
    },

    /**
     * Compiles a RegExp object from the specified parameter if it is a String.
     * @param {String|RegExp} regex The potential regular expression
     */
    manageRegEx: function (regex) {
      var length;
      // do it in a separate method to avoid potential leak
      if (typeof(regex) === 'string') {
        length = regex.length;
        if (regex.charAt('0') === '/' && regex.charAt(length - 1) === '/') {
          return new RegExp(regex.substring(0, length - 1));
        }
      }
      return regex;
    },

    /**
     * Executes several security checks on the specified DOM element according to the
     * defined paste rules.
     * @param {HTMLElement} dom The DOM element
     * @return {HTMLElement} The DOM element or null if the element has been marked for
     *         removal
     */
    handleSecurity: function (dom) {
      var com = CUI.rte.Common;
      // execute link verification
      if (com.isTag(dom, 'a')) {
        var hrefAttrib = com.getAttribute(dom, 'href', true);
        if (hrefAttrib && this.pasteRules.linkRemoveRegEx) {
          var regex = this.manageRegEx(this.pasteRules.linkRemoveRegEx);
          if (regex) {
            if (hrefAttrib.search(regex) >= 0) {
              this.markForRemoval(dom);
              return null;
            }
          }
        }
      }
      return dom;
    },

    /**
     * Removes attributes that are not allowed.
     * @param {HTMLElement} dom The DOM element
     */
    handleAttributes: function (dom) {
      var com = CUI.rte.Common;
      var attribs = com.getAttributeNames(dom);
      var globalAllowed = null;
      var tagAllowed = null;
      var tagNameLC = dom.tagName.toLowerCase();
      if (this.pasteRules.allowedAttributes) {
        globalAllowed = this.pasteRules.allowedAttributes['*'];
        tagAllowed = this.pasteRules.allowedAttributes[tagNameLC];
      }
      var attribCnt = attribs.length;
      for (var a = 0; a < attribCnt; a++) {
        var attribName = attribs[a];
        var isAllowed = false;
        if (globalAllowed && com.arrayContains(globalAllowed, attribName)) {
          isAllowed = true;
        }
        if (tagAllowed && com.arrayContains(tagAllowed, attribName)) {
          isAllowed = true;
        }
        if (!isAllowed) {
          com.removeAttribute(dom, attribName);
        }
      }
    },

    /**
     * <p>This method handles the preprocessing for pasted HTML content.</p>
     * <p>It may be called in any processing mode.</p>
     * @param {HTMLElement} dom The DOM element to be processed
     * @return {HTMLElement} The DOM element to continue processing with
     */
    handlePasteProcessing: function (dom) {
      var dcu = CUI.rte.DomCleanup;
      var originalDom = dom;
      if ((this.mode = dcu.PASTE_PREPARE) && (this.pasteRules !== null && this.pasteRules !== undefined)) {
        if (dom) {
          dom = this.handleSecurity(dom);
        }
        if (dom) {
          this.handleBlockTagsOnPaste(dom);
          this.handleCssClassesOnPaste(dom);
          this.handleAttributes(dom);
        }
        dom = this.checkAllowedForPaste(dom);
      }
      // continue with original DOM if element has been marked for removal
      return dom || originalDom;
    },


    // -- Processing -----------------------------------------------------------------------

    /**
     * Optimize the tree (executes operations that can't be efficiently processed
     * in the event-driven manner the DomCleanup else works).
     * @param {HTMLElement} root The root element
     */
    optimizeTree: function (root) {

      var com = CUI.rte.Common;

      function optimizeNode(dom, joinableTags) {
        if (com.isTag(dom, joinableTags) && !(com.isSurroundingDomJapaneseWordWrap(dom.tagName.toLowerCase(), {class: dom.getAttribute('class')}))) {
          //Combine consecutive same tag from <span>aaa</span><span>bbb</span> to <span>aaabbb</span>
          var isDone = false;
          do {
            var nextDom = dom.nextSibling;
            if (nextDom) {
              if (com.equals(dom, nextDom)) {
                com.moveChildren(nextDom, dom, 0, true);
                nextDom.parentNode.removeChild(nextDom);
              } else {
                isDone = true;
              }
            } else {
              isDone = true;
            }
          } while (!isDone);
        }
        if (dom.nodeType === 1) {
          for (var c = 0; c < dom.childNodes.length; c++) {
            optimizeNode(dom.childNodes[c], joinableTags);
          }
        }
      }

      if (!this.isPreProcessing()) {
        var optimizable = [
          'b', 'i', 'u', 'big', 'small', 'strong', 'em', 'sub', 'sup', 'span'
        ];
        optimizeNode(root, optimizable);
      }
    },

    /**
     * Handles generic HTML for the specified sub-tree recursively.
     * @param {HTMLElement} dom Root element of the sub-tree
     * @param {Boolean} isRoot True if we are at the root node of the entire traversal
     */
    traverse: function (dom, isRoot) {
      var ignoreRecursion = false;
      if (!isRoot) {
        if (dom.nodeType === 1) {
          if (!this.isValidSubTree(dom)) {
            this.markSubTreeForRemoval(dom);
            ignoreRecursion = true;
          } else if (!this.isValidElement(dom)) {
            this.markForRemoval(dom);
          } else {
            // paste processing works as a "pre-filter"
            dom = this.handlePasteProcessing(dom);
            var isRemoved = false;
            if (this.htmlRules) {
              isRemoved = this.applyHtmlRules(dom);
            }
            if (!isRemoved) {
              this.handleSpecificTags(dom);
            }
          }
        }
        this.handleEmptyLinesAtEOB(dom);
      }
      if (!ignoreRecursion) {
        var children = dom.childNodes;
        for (var c = 0; c < children.length; c++) {
          this.traverse(children[c], false);
        }
      }
    },

    /**
     * Removes elements that were marked for removal while traversing the DOM tree.
     */
    removeElements: function () {
      var dpr = CUI.rte.DomProcessor;
      var removeCnt = this.elementsToRemove.length;
      for (var r = 0; r < removeCnt; r++) {
        dpr.removeWithoutChildren(this.elementsToRemove[r]);
      }
      this.elementsToRemove.length = 0;
      removeCnt = this.subTreesToRemove.length;
      for (r = 0; r < removeCnt; r++) {
        var toRemove = this.subTreesToRemove[r];
        if (toRemove.parentNode) {
          toRemove.parentNode.removeChild(toRemove);
        }
      }
      this.subTreesToRemove.length = 0;
    },

    /**
     * Replaces elements that were marked accordingly while traversing the DOM tree.
     */
    replaceElements: function () {
      var com = CUI.rte.Common;
      var replaceCnt = this.elementsToChange.length;
      for (var r = 0; r < replaceCnt; r++) {
        var changeDef = this.elementsToChange[r];
        var toChange = changeDef.domToChange;
        com.replaceNode(toChange, changeDef.changedDom, changeDef.childDom);
        // if element was marked for removal, we'll have to remove it from that list
        // as we'd otherwise provoke an exception
        for (var rm = 0; rm < this.elementsToRemove.length; rm++) {
          if (this.elementsToRemove[rm] === toChange) {
            this.elementsToRemove.splice(rm, 1);
            break;
          }
        }
      }
    },

    /**
     * Inserts the elements that were marked accordingly while traversing the DOM tree.
     */
    insertElements: function () {
      var insertCnt = this.elementsToInsert.length;
      for (var i = 0; i < insertCnt; i++) {
        var changeDef = this.elementsToInsert[i];
        var toInsert = changeDef.domToInsert;
        var parentDom = changeDef.parentDom;
        var siblingRef = changeDef.refDom;
        if (siblingRef) {
          parentDom.insertBefore(toInsert, siblingRef);
        } else {
          parentDom.appendChild(toInsert);
        }
      }
    },


    // -- "Interface"/Implementation -------------------------------------------------------

    /**
     * Executes the DOM cleanup (used by each of the processing methods).
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root element to begin cleanup with
     * @private
     */
    execute: function (editorKernel, rootDom) {
      // init
      this.editorKernel = editorKernel;
      this.context = editorKernel.getEditContext();
      this.htmlRules = editorKernel.getHtmlRules();

      function clear(array) {
        if (array) {
          array.length = 0;
          return array;
        }
        return [];
      }

      this.elementsToRemove = clear(this.elementsToRemove);
      this.subTreesToRemove = clear(this.subTreesToRemove);
      this.elementsToChange = clear(this.elementsToChange);
      this.elementsToInsert = clear(this.elementsToInsert);
      this.emptyBlocksIE = clear(this.emptyBlocksIE);

      // actually execute
      this.traverse(rootDom, true);
      this.insertElements();
      this.replaceElements();
      this.removeElements();
      this.optimizeTree(rootDom);
      this.handleContainerRules(rootDom);
      this.handleEmptyContent(rootDom);
    },

    /**
     * Executes DOM-based preprocessing on the specified root node.
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root node
     */
    preprocess: function (editorKernel, rootDom) {
      this.processingMode = CUI.rte.DomCleanup.PRE;
      this.execute(editorKernel, rootDom);
    },

    /**
     * Executes DOM-based postprocessing on the specified root node.
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root node
     */
    postprocess: function (editorKernel, rootDom) {
      this.processingMode = CUI.rte.DomCleanup.POST;
      this.execute(editorKernel, rootDom);
    },

    /**
     * Executes DOM-based preprocessing of HTML content that was pasted from a potentially
     * unknown source.
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root node
     * @param {Object} pasteRules The rules to be applied for pasted content
     */
    prepareHtmlPaste: function (editorKernel, rootDom, pasteRules) {
      this.processingMode = CUI.rte.DomCleanup.PASTE_PREPARE;
      this.pasteRules = pasteRules;
      this.execute(editorKernel, rootDom);
    }

  });


  /**
   * Mode: Preprocessing (= persisted to editable state)
   */
  CUI.rte.DomCleanup.PRE = 0;

  /**
   * Mode: Postprocessing (= edited to a pesistable state)
   */
  CUI.rte.DomCleanup.POST = 1;

  /**
   * Mode: Preprocessing of HTML content pasted from anywhere
   */
  CUI.rte.DomCleanup.PASTE_PREPARE = 2;

  /**
   * Array of pluggable dom processors, pushed by plugins to manage specific tags.
   * A processor should be of the form function (dom)
   */
  CUI.rte.DomCleanup.pluggableDomProcessors = null;

  /**
   * <p>Adds a dom processor that will be called at dom pre & post processing, allowing
   * plugins to add their own DOM manipulation</p>
   */
  CUI.rte.DomCleanup.addDomProcessor = function (processor) {
    var dcu = CUI.rte.DomCleanup;
    if (dcu.pluggableDomProcessors === null) {
      dcu.pluggableDomProcessors = [];
    }
    dcu.pluggableDomProcessors.push(processor);
  };
}(window.CUI));
