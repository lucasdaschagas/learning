/*************************************************************************
 *
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2014 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 *
 **************************************************************************/

(function(window, document, exportName, undefined) {
    'use strict';

/**
 * @param {Object} obj
 * @param {String} property
 * @param {String} value
 * @memberof Sistine.Util
 */
function prefixStyleValue(obj, property, value) {
    var styleName = value.split(/\s+/g)[0];
    var prefixedStyleName = Sistine.Util.prefixStyleName(obj, styleName);

    if (prefixedStyleName !== styleName) {
        var prefix = prefixedStyleName.match(/[A-Z]?[^A-Z]*/g).slice(0, -1)[0];
        return '-' + prefix + '-' + value;
    }

    return value;
}

/**
 * Applies the prefixed version of a set of styles to an element. If any
 * property is a CSS transition, then the optional callback will be called
 * when the transition completes.
 *
 * @param {HTMLElement} element
 * @param {Object} props
 * @param {Function} [callback]
 * @param {*} [thisVal]
 * @memberof Sistine.Util
 */
function applyPrefixedCssProps(element, props, callback, thisVal) {
    var isTransition = _.contains(_.keys(props), 'transition') && !_.isUndefined(props.transition);

    if (!_.isUndefined(callback) && isTransition) {
        var listener = function(ev) {
            if (listener) {
                callback.apply(thisVal, ev);
                element.removeEventListener('webkitTransitionEnd', listener);
                element.removeEventListener('transitionend', listener);
                listener = null;
            }
        };
        // TODO: Support more than webkit here
        element.addEventListener('webkitTransitionEnd', listener);
        element.addEventListener('transitionend', listener);
    }

    // The use of setTimeout and window.getComputedStyle here is a "hack" to 
    // ensure that any applied transition actually runs on elements that were 
    // recently added, but the browser hasn't yet had a chance to run a 
    // render cycle. setTimeout applies to Chrome, window.getComputedStyle is
    // the hack that works on Safari and WebKit.
    if (isTransition) {
        window.getComputedStyle(element, null).getPropertyValue('-webkit-transform');
        setTimeout(function() {
            var modified = false;

            _.each(props, function(value, name) {
                if (applyPrefixedCss(element, name, value)) {
                    modified = true;
                }
            });

            if (!modified && !_.isUndefined(callback)) {
                var duration = props.transition.split(/\s+/)[1];
                setTimeout(function() {
                    callback.apply(thisVal);
                }, parseDuration(duration));
            }
        }, 0);
    }
    else {
        _.each(props, function(value, name) {
            applyPrefixedCss(element, name, value);
        });

        if (!_.isUndefined(callback)) {
            callback.apply(thisVal);
        }
    }
}

/**
 * Applies the prefixed version of a given style name to an element.
 *
 * @param {HTMLElement} element
 * @param {String} styleName
 * @param {*} value
 * @memberof Sistine.Util
 */
function applyPrefixedCss(element, styleName, value) {
    if (_.isUndefined(value) || value.length === 0) {
        return false;
    }

    var style = element.style;
    var prefixedStyle = Sistine.Util.prefixStyleName(style, styleName);

    // Transitions must also have their values prefixed accordingly
    if (styleName === 'transition') {
        value = prefixStyleValue(style, styleName, value);
    }

    style[prefixedStyle] = value;
}

/**
 * Given a series of functions as arguments, apply each function in sequence.
 *
 * @memberof Sistine.Util
 */
function sequentiallyApply(thisVal /*, functions */) {
    var args = arguments;
    return function() {
        for (var i = 1, len = args.length; i < len; i++) {
            var func = args[i];
            func.apply(thisVal);
        }
    };
}

/**
 * Given a duration as a string commonly used in CSS transition expressions
 * (such as 0.2s or 200ms) return the equivalent float value in milliseconds.
 *
 * @param {String} duration
 * @returns {Number} The duration as a floating point value in millseconds.
 * @memberof Sistine.Util
 */
function parseDuration(duration) {
    var parsed = duration.match(/^([0-9]+\.?[0-9]*|\.[0-9]+)(ms|s)$/);

    if (!parsed || parsed.length !== 3) {
        return 0;
    }

    var num = parseFloat(parsed[1]);
    var unit = parsed[2];

    if (unit === 's') {
        return num * 1000;
    }
    else if (unit === 'ms') {
        return num;
    }

    return 0;
}

/**
 * Cross-browser compatible method for getting the inner dimensions of the
 * window.
 *
 * @returns {Array} The width and height of the inner window dimensions as a
 * two-element array.
 * @memberof Sistine.Util
 */
function getWindowDimensions() {
    var windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
    var windowHeight = window.innerHeight|| document.documentElement.clientHeight || document.body.clientHeight;

    return [windowWidth, windowHeight];
}

/**
 * @memberof Sistine.Animation
 */
var LINEAR = 'linear';

/**
 * @memberof Sistine.Animation
 */
var EASE = 'ease';

/**
 * @memberof Sistine.Animation
 */
var EASE_OUT = 'ease-out';

/**
 * @memberof Sistine.Animation
 */
var EASE_IN = 'ease-in';

/**
 * @memberof Sistine.Animation
 */
var EASE_IN_OUT = 'ease-in-out';

/**
 * The target frames per second for all animations.
 *
 * @constant
 * @type {Number}
 * @default
 * @memberof Sistine.Animator
 */
var FPS = 60;

function Animator() {
    this._animationId = null;
    this._runningAnimations = {};
    this._nextAnimationKey = 0;
}

Animator.prototype = {
    /**
     * @param {HTMLElement} element
     * @param {Number} x
     * @param {Number} y
     * @param {Number} duration
     * @param {String} easing
     */
    move: function(element, x, y, duration, easing, callback, thisVal) {
        this.transform(element, makeTranslation(x, y), duration, easing, callback, thisVal);
    },

    /**
     * @param {HTMLElement} element
     * @param {Number} xScale
     * @param {Number} yScale
     * @param {Number} duration
     * @param {String} easing
     * @param {Function} callback
     * @param {*} thisVal
     */
    scale: function(element, xScale, yScale, duration, easing, callback, thisVal) {
        this.transform(element, makeScale(xScale, yScale), duration, easing, callback, thisVal);
    },

    /**
     * @param {HTMLElement} element
     * @param {Number} velocity
     * @param {Number} friction
     * @param {Number} multiplier
     * @param {Number} stopSpeed
     * @param {Object} elasticity
     * @param {Number} maxSpeed
     * @param {Rect} [boundingBox]
     * @param {Function} [callback]
     * @param {*} [thisVal]
     */
    toss: function(element, velocity, friction, multiplier, stopSpeed, elasticity, maxSpeed, boundingBox, callback, thisVal) {
        // Create a default bounding box if none is specified
        if (!boundingBox) {
            var windowDims = getWindowDimensions();
            var rect = element.getBoundingClientRect();
            boundingBox = {
                top: rect.height * 0.5,
                left: rect.width * 0.5,
                width: windowDims[0] - rect.width,
                height: windowDims[1] - rect.height
            };
        }

        // Velocity is assumed to be px/s, so convert to FPS
        var maxS = maxSpeed/FPS;
        var vel = [Math.min(maxS, Math.max(-maxS, (velocity[0] * multiplier)/FPS)), 
                   Math.min(maxS, Math.max(-maxS, (velocity[1] * multiplier)/FPS))];
        var cof = 1 - friction;
        var minX = boundingBox.left;
        var minY = boundingBox.top;
        var maxX = boundingBox.left + boundingBox.width;
        var maxY = boundingBox.top + boundingBox.height;

        var step = function(element) {
            var rect = element.getBoundingClientRect();
            var pos = [rect.left + rect.width * 0.5, rect.top + rect.height * 0.5];
            pos[0] = Math.min(Math.max(minX, pos[0] + vel[0]), maxX);
            pos[1] = Math.min(Math.max(minY, pos[1] + vel[1]), maxY);

            this.move(element, pos[0], pos[1]);

            if (pos[0] <= minX) {
                vel[0] *= -elasticity.left;
            }
            else if (pos[0] >= maxX) {
                vel[0] *= -elasticity.right;
            }

            if (pos[1] <= minY) {
                vel[1] *= -elasticity.top;
            }
            else if (pos[1] >= maxY) {
                vel[1] *= -elasticity.bottom;
            }

            vel[0] *= cof;
            vel[1] *= cof;

            if (Math.abs(vel[0]) > stopSpeed || Math.abs(vel[1]) > stopSpeed) {
                return true;
            }
            else {
                Sistine.Util.applyIfExists(callback, thisVal)();
                return false;
            }
        };

        this._schedule(element, step);
    },

    transform: function(element, transform, duration, easing, callback, thisVal) {
        if (_.isUndefined(element) || _.isUndefined(transform) || !transform || transform.length === 0) {
            return;
        }

        duration = duration || 0;
        easing = easing || LINEAR;

        if (duration === 0) {
            applyPrefixedCss(element, 'transform', transform);
            Sistine.Util.applyIfExists(callback, thisVal)();
        }
        else {
            // TODO: Generalize beyond webkit
            var listener = function() {
                if (listener) {
                    element.removeEventListener('webkitTransitionEnd', listener);
                    element.removeEventListener('transitionend', listener);
                    listener = null;

                    deleteTransition(element);
                    Sistine.Util.applyIfExists(callback, thisVal)();
                }
            };
            element.addEventListener('webkitTransitionEnd', listener);
            element.addEventListener('transitionend', listener);

            // The use of setTimeout and window.getComputedStyle here is a "hack" to 
            // ensure that any applied transition actually runs on elements that were 
            // recently added, but the browser hasn't yet had a chance to run a 
            // render cycle. setTimeout applies to Chrome, window.getComputedStyle is
            // the hack that works on Safari and WebKit.
            window.getComputedStyle(element, null).getPropertyValue('-webkit-transform');
            setTimeout(function() {
                var oldTransform = getTransform(element);
                applyPrefixedCss(element, 'transition', makeTransition('transform', duration, easing));
                applyPrefixedCss(element, 'transform', transform);

                // Sometimes the old transform will be same as new transform,
                // but we still want to wait for the duration of the transition
                // in this case. This second "hack" uses a second setTimeout
                // to get around the browser behavior where the transition end
                // event will not fire in this case.
                if (oldTransform === getTransform(element)) {
                    setTimeout(function() {
                        deleteTransition(element);
                        Sistine.Util.applyIfExists(callback, thisVal)();
                    }, duration);
                }
            }, 0);
        }
    },

    cancel: function(element) {
        var key = element.getAttribute('data-animationkey');
        
        if (!key) {
            return;
        }

        delete this._runningAnimations[key];

        if (_.isEmpty(this._runningAnimations) && this._animationId !== null) {
            cancelAnimationFrame(this._animationId);
            this._animationId = null;
        }
    },

    _schedule: function(element, step) {
        // Stop any running animations already on the element
        this.cancel(element);

        var key = this._nextAnimationKey++;
        element.dataset.animationkey = key;
        this._runningAnimations[key] = {
            element: element,
            step: step
        };

        if (this._animationId === null) {
            this._runLoop();
        }
    },

    _loop: function(timestamp) {
        var keys = _.keys(this._runningAnimations);
        for (var i = 0, len = keys.length; i < len; i++) {
            var key = keys[i];
            var element = this._runningAnimations[key].element;
            var step = this._runningAnimations[key].step;
            if (!step.call(this, element)) {
                this.cancel(element);
            }
        }

        if (this._animationId !== null) {
            this._runLoop();
        }
    },

    _runLoop: function() {
        var self = this;
        this._animationId = requestAnimationFrame(function(timestamp) {
            self._loop.call(self, timestamp);
        });
    }
};

/**
 * @memberof Sistine.Animation
 */
function makeTranslation(x, y) {
    if (_.isUndefined(x) || _.isUndefined(y)) {
        return null;
    }

    return 'translate3d(' + x + 'px, ' + y + 'px, 0px)';
}

/**
 * @memberof Sistine.Animation
 */
function makeScale(x, y) {
    if (_.isUndefined(x) || _.isUndefined(y)) {
        return null;
    }

    return 'scale3d(' + x + ', ' + y + ', 1.0)';
}

/**
 * @memberof Sistine.Animation
 */
function makeTransition(prop, duration, easing) {
    return prop + ' ' + duration + 's ' + easing;
}

/**
 * @memberOf Sistine.Animation
 */
function makeTransformOrigin(x, y) {
    return (x * 100) + '% ' + (y * 100) + '% 0';
}

/**
 * @memberof Sistine.Animation
 */
function extractTranslation(transform) {
    var regex = /(translate(3d)?\(([0-9]|.|,|\s|px)+\))/;
    var match = transform.match(regex);
    if (match && match.length > 0) {
        return {
            transform: transform.replace(regex, '').trim(),
            translation: match[0]
        };
    }
}

/**
 * @memberof Sistine.Animation
 */
function extractScale(transform) {
    var regex = /(scale(3d)?\(([0-9]|.|,|\s|px)+\))/;
    var match = transform.match(regex);
    if (match && match.length > 0) {
        return {
            transform: transform.replace(regex, '').trim(),
            translation: match[0]
        };
    }
}

/******************************************************************************
 *
 * Private (hidden) functions
 *
 *****************************************************************************/

function deleteTransition(element) {
    var style = element.style;
    style[Sistine.Util.prefixStyleName(style, 'transition')] = '';
}

function getTransform(element) {
    var style = element.style;
    return style[Sistine.Util.prefixStyleName(style, 'transform')];
}

/**
 * Singleton instance of ```Animator```.
 *
 * @memberof Sistine
 */
Sistine.Animator = new Animator();

/**
 * Used for specifying a drag type of 'none.' Any recipient receiving a drop
 * of this type is expected to ignore it.
 *
 * @constant
 * @type {Number}
 * @default
 * @memberof Sistine.Drag
 */
var DRAG_NONE = 0;

/**
 * Used for specifying a drag type of 'move.' When the drag type is set to move
 * the payload data is NOT copied by the drag manager.
 *
 * @constant
 * @type {Number}
 * @default
 * @memberof Sistine.Drag
 */
var DRAG_MOVE = 1;

/**
 * Used for specifying a drag type of 'copy.' When the drag type is set to
 * copy, payload data is copied by the drag manager instead of referenced.
 *
 * @constant
 * @type {Number}
 * @default
 * @memberof Sistine.Drag
 */
var DRAG_COPY = 2;

/**
 * Used to specify a drag type of 'all.' All can be either a drag move or
 * a drag copy.
 *
 * @constant
 * @type {Number}
 * @default 3
 * @memberof Sistine.Drag
 */
var DRAG_ALL = DRAG_MOVE | DRAG_COPY; // jshint ignore:line

/**
 * @constant
 * @type {Number}
 * @default
 * @memberof Sistine.Drag
 */
var TOSS_NONE = 0;

/**
 * @constant
 * @type {Number}
 * @default
 * @memberof Sistine.Drag
 */
var TOSS_WITHIN = 1;

/**
 * @constant
 * @type {Number}
 * @default
 * @memberof Sistine.Drag
 */
var TOSS_AWAY = 2;

/**
 * @constant
 * @type {Number}
 * @default 3
 * @memberof Sistine.Drag
 */
var TOSS_ALL = TOSS_WITHIN | TOSS_AWAY; // jshint ignore:line

/**
 * @constant
 * @type {Number}
 * @default
 * @memberof Sistine.Drag
 */
var AXIS_Y = 1;

/**
 * @constant
 * @type {Number}
 * @default
 * @memberof Sistine.Drag
 */
var AXIS_X = 2;

/**
 * @constant
 * @type {Number}
 * @default 3
 * @memberof Sistine.Drag
 */
var AXIS_ANY = AXIS_Y | AXIS_X; // jshint ignore:line

/*
 * Static for keeping universally unique drag IDs using simple incremental
 * system.
 */
var NEXT_DRAG_ID = 0;

/**
 * DragData is the primary data model for a single drag instance. 
 * This object contains relevant drag information  as well as methods that the user
 * can call to affect how drags behave when they are dropped or canceled.
 *
 * Typically this object is created by a Manager instance rather than directly
 * by a user of the library. The object is then provided to users of the library
 * as an attribute of drag the various drag events emitted by the Manager.
 *
 * @constructor
 * @param {Object} options
 *     @param {Draggable} options.draggable
 *     @param {Object} options.payload
 *     @param {Array} options.pointerIds
 *     @param {HTMLElement[]} options.dropzones
 *     @param {HTMLElement} options.overElement
 *     @param {Object} [options.timeoutOptions]
 *         @param {Number} [options.timeoutOptions.timeout]
 *         @param {String} [options.timeoutOptions.ease]
 *         @param {Number} [options.timeoutOptions.duration]
 *     @param {Number} options.dragAction
 *     @param {Object} options.eventNames
 *     @param {Object} [options.tossOptions]
 *         @param {Number} [options.tossOptions.tossAction]
 *         @param {Number} [options.tossOptions.threshold]
 *         @param {Number} [options.tossOptions.friction]
 *         @param {Number} [options.tossOptions.multiplier]
 *         @param {Number} [options.tossOptions.stopSpeed]
 *     @param {Object} [options.userData]
 */
function DragData(options) {
    options = options || {};
    var pointerIds = options.pointerIds || [];

    this.draggable = options.draggable;
    this.dragId = NEXT_DRAG_ID++;
    this.dragAction = options.dragAction;
    this.tossOptions = options.tossOptions;
    this.userData = options.userData;
    this.timeoutOptions = options.timeoutOptions;
    this.lockAxis = options.lockAxis;

    // Private fields also sometimes manipulated by the Manager
    // Think of the Manager as a 'friend' of the DragData class
    this._pointerIds = pointerIds;
    this._masterPointerId = pointerIds && pointerIds.length > 0 ? pointerIds[0] : -1;
    this._eventNames = options.eventNames;

    if (this.dragAction === DRAG_COPY) {
        this.payload = _.extend({}, options.payload);
    }
    else {
        this.payload = options.payload;
    }

    this.reset(options.dropzones);
}

// Public fields made available as getter/setter
Sistine.Util.createSimpleMutators(DragData.prototype, [
    'draggable',
    'dragId',
    'payload', 
    'timeoutOptions',
    'dropzones',
    'overElement',
    'userData',
    'dragAction',
    'lockAxis',
    'tossOptions'
]);

DragData.prototype = {
    /**
     * Returns true if the current state of the DragData object allows for
     * dropping. This state will be true if the drag that the DragData represents
     * is over a dropzone that has set the drop action to 
     *
     * @returns {Boolean} True if the current state of the DragData object
     * allows for dropping.
     */
    dropIsAllowed: function() {
        return this.dropAction !== DRAG_NONE &&
               (this.dragAction & this.dropAction) === this.dragAction; // jshint ignore:line
    },

    /**
     * Returns true if, given the last known velocity of the drag, the speed
     * is great enough that it breaks the toss threshold and tossing is allowed.
     *
     * @param {Array} velocity A velocity vector as a 2-element array.
     * @returns {Boolean} True if a within-screen toss is allowed for the given
     * velocity.
     */
    tossIsAllowed: function(velocity) {
        var tossOptions = this.tossOptions;
        return (tossOptions.tossAction > 0) && // jshint ignore:line
            (Math.abs(velocity[0]) >= tossOptions.threshold ||
             Math.abs(velocity[1]) >= tossOptions.threshold);
    },

    /**
     * Returns the bounding box for any toss associated with this drag. The
     * bounding box will vary depending on what toss actions are allowed for
     * the drag. For instance, if ```TOSS_AWAY``` is enabled, then the bounding
     * box will allow for tosses off screen in the Y-axis.
     *
     * @returns {Rect} The bounding box.
     */
    tossBoundingBox: function() {
        var boundingBox;
        var rect = this.draggable.element.getBoundingClientRect();
        var windowDims = getWindowDimensions();

        if (this.tossOptions.tossAction === TOSS_ALL || this.tossOptions.tossAction === TOSS_AWAY) {
            boundingBox = {
                top: -rect.height * 0.5,
                left: rect.width * 0.5,
                width: windowDims[0] - rect.width,
                height: windowDims[1] + rect.height
            };
        }
        else if (this.tossOptions.tossAction === TOSS_WITHIN) {
            boundingBox = {
                top: rect.height * 0.5,
                left: rect.width * 0.5,
                width: windowDims[0] - rect.width,
                height: windowDims[1] - rect.height
            };
        }
        else {
            boundingBox = {
                top: 0,
                left: 0,
                width: 0,
                height: 0
            };
        }

        return boundingBox;
    },

    /**
     * Resets the drop options. This is primarily
     * called by the Manager when an element leaves a dropzone and all
     * previously set drop options are no longer valid.
     *
     * @param {HTMLElement[]} [dropzones] The array of dropzones (as HTMLElements) that
     * this drag is currently over.
     * @param {HTMLElement} [overElement] The element that this Draggable
     * is currently hovering over. This may be different than the dropzones (i.e.
     * the dropzone may have child nodes).
     */
    reset: function(dropzones, overElement) {
        this.setDropOptions(DRAG_NONE, {});

        this.dropzones = dropzones ? dropzones : [];
        this.overElement = overElement ? overElement : null;
    },

    /**
     * Typically called by receivers of drag events to set the preferred options
     * for when a drag is dropped. When the DragData is provided to receivers
     * of drag events as an attribute of the event, the receiver can call this
     * function on the DragData directly.
     *
     * @param {Number} dropAction The supported drag action for when this drag
     * is dropped. If the action provided does not match the one initially
     * provided when the drag started, then the drag will cancel when released.
     * @param {Object} [animationOptions]
     *     @param {HTMLElement|TextRectangle} [animationOptions.matchRect]
     *     @param {Number} [animationOptions.duration]
     *     @param {Function} [animationOptions.callback]
     *     @param {*} [animationOptions.thisVal]
     */
    setDropOptions: function(dropAction, animationOptions) {
        this.dropAction = dropAction;

        if (animationOptions && this.draggable) {
            this.draggable.setDropAnimation(animationOptions);
        }
    },

    /**
     * Typically called after beginning a drag to set the options for when
     * the given drag is cancelled (i.e. the cancel animation). 
     * This may also be called at any time by receivers of drag events to 
     * change the behavior of a drag cancel at any time.
     *
     * @param {Object} [animationOptions]
     *     @param {HTMLElement|TextRectangle} [animationOptions.matchRect]
     *     @param {Number} [animationOptions.duration]
     *     @param {Function} [animationOptions.callback]
     *     @param {*} [animationOptions.thisVal]
     */
    setCancelOptions: function(animationOptions) {
        if (animationOptions) {
            this.draggable.setCancelAnimation(animationOptions);
        }
    },

    /**
     * Starts a timeout on the drag.
     *
     * @param {Number} [duration] The duration of the timeout. If none is
     * specified then the timeout will use the DragData's timeoutOptions.timeout
     * as passed to the constructor. If the duration is set to 0, then
     * the timeout request is ignored.
     */
    startTimeout: function(duration) {
        this.stopTimeout();

        // Ignore 0 duration
        if (duration <= 0) {
            return;
        }

        var d = duration || this.timeoutOptions.timeout;
        var self = this;
        this._timeoutId = setTimeout(function() {
            var draggable = self.draggable;
            var pos = self.draggable.position();
            var windowDims = getWindowDimensions();
            self.draggable.stopToss();
            self.stopTimeout();
            self.draggable.fall(self.timeoutOptions.duration, self.timeoutOptions.ease, self._handleTimeoutExpired, self);
        }, d || 0);
    },

    /**
     * Stops any running timeout timers.
     */
    stopTimeout: function() {
        if (this._timeoutId) {
            clearTimeout(this._timeoutId);
            delete this._timeoutId;
        }
    },

    /*
     * Event handler for timeouts.
     */
    _handleTimeoutExpired: function() {
        dispatchEvent(this._eventNames.dragTimeout, this.draggable.element, this.payload);
        this.draggable.remove();
    }
};


/*
 * The default animation duration (in seconds) for all animations performed on 
 * Draggable objects.
 */
var DEFAULT_DURATION = 0.2;

/**
 * The Draggable object is used internally by the Manager to represent
 * a displayed draggable element (aka drag proxy) on the screen. Typically,
 * users of the library do not create their own Draggable instances. Rather,
 * the Manager will generate one as part of the call to ```Manager.beginDrag```
 * and insert the user-provided dragging proxy into the Draggable element.
 *
 * @constructor
 * @param {HTMLElement} element The HTML element that represents the draggable
 * object. This is the element that will be dragged around on screen by the
 * user's pointer and is typically provided by the user as the ```proxy```
 * option in the ```Manager.beginDrag``` method.
 * @param {Object} [options] A set of options that should be applied to the
 * draggable.
 *     @param {String} [options.className] The CSS class name(s) to add to the
 *     Draggable when it is created.
 *     @param {Object} [options.cssProps] Any CSS properties (key/value pairs)
 *     that should be added to the Draggable when it is created.
 *     @param {Object} [options.show] A set of options to apply when the
 *     Draggable begins dragging (i.e. when we first show the Draggable).
 *         @param {String} [options.show.className] The class name to apply
 *         to the Draggable when dragging begins.
 *         @param {String} [options.show.transform]
 *         @param {Number} [options.show.duration]
 *         @param {String} [options.show.easing]
 *     @param {Object} [options.drop] A set of options to apply when the
 *     Draggable is dropped.
 *         @param {String} [options.drop.className] The class name to apply
 *         to the Draggble when dropping. Useful for applying pre-defined drop
 *         animations.
 *         @param {String} [options.drop.transform]
 *         @param {Number} [options.drop.duration]
 *         @param {String} [options.drop.easing]
 *     @param {Object} [options.cancel] A set of options to apply to the
 *     Draggable when dragging is canceled (due to dropping on an invalid
 *     drop zone).
 *         @param {String} [options.cancel.className]
 *         @param {String} [options.cancel.transform]
 *         @param {Number} [options.cancel.duration]
 *         @param {String} [options.cancel.easing]
 */
function Draggable(element, options) {
    this.options = Sistine.Util.deepDefaults(options || {}, this.defaults);
    this.element = element;
    this._wrapper = generateWrapper(element, options);
    this._originalElementRect = {};

    applyPrefixedCssProps(this.element, this.options.cssProps);
    applyPrefixedCssProps(this._wrapper, this.options.cssProps);
}

Draggable.prototype = {
    /**
     * A dictionary of default properties for new Draggable instances. The 
     * following properties are used unless overridden as options in the 
     * Draggable's constructor.
     *
     * @prop {String} defaults.className The class name to apply to all Draggables,
     * regardless of their current state (dragging, dropping, cancelling, etc.).
     * Defaults to 'draggable'.
     * @prop {Object} defaults.cssProps The collection of CSS properties that
     * should be applied to all Draggables when they are created.
     * @prop {Object} defaults.show
     * @prop {Object} defaults.drop
     * @prop {Object} defaults.cancel
     */
    defaults: {
        className: 'draggable',

        cssProps: {
            cursor: 'default'
        },

        show: {
            className: 'showing',
            transform: makeScale(1.5, 1.5),
            duration: DEFAULT_DURATION,
            easing: EASE_OUT
        },

        drop: {
            className: 'dropping',
            transform: makeScale(1.0, 1.0),
            duration: DEFAULT_DURATION,
            easing: EASE_OUT
        },

        cancel: {
            className: 'canceling',
            transform: makeScale(0, 0),
            duration: DEFAULT_DURATION,
            easing: EASE_OUT
        },

        translationOrigin: [0.5, 0.5]
    },

    /**
     * Performs a toss animation of the draggable.
     *
     * @param {Number} velocity
     * @param {Number} friction
     * @param {Number} multiplier
     * @param {Number} stopSpeed
     * @param {Number} elasticity
     * @param {Number} maxSpeed
     * @param {Rect} [boundingBox]
     * @param {Function} [callback]
     * @param {*} [thisVal]
     */
    toss: function(velocity, friction, multiplier, stopSpeed, elasticity, maxSpeed, boundingBox, callback, thisVal) {
        Sistine.Animator.toss(this._wrapper, velocity, friction, multiplier, stopSpeed, elasticity, maxSpeed, boundingBox, callback, thisVal);
        return this;
    },

    /**
     * Cancels any running toss animations.
     */
    stopToss: function() {
        Sistine.Animator.cancel(this._wrapper);
    },

    /**
     * Animates the draggable as if it were falling off the screen due to 
     * gravity.
     *
     * @param {Number} duration
     * @param {String} easing
     * @param {Function} callback
     * @param {*} thisVal
     */
    fall: function(duration, easing, callback, thisVal) {
        var pos = this.position();
        var windowDims = getWindowDimensions();
        var rect = this.element.getBoundingClientRect();
        Sistine.Animator.move(this._wrapper, pos[0], windowDims[1] + (rect.height * 0.5), duration, easing, callback, thisVal);
    },

    /**
     * Moves the Draggable to the given x, y coordinates using CSS translation.
     *
     * @param {Number} x
     * @param {Number} y
     * @param {Number} duration
     * @param {String} easing
     * @param {Function} callback
     * @param {*} thisVal
     * @returns {Draggable} Returns the Draggable.
     */
    move: function(x, y, duration, easing, callback, thisVal) {
        var offset = this._translationOffset;
        Sistine.Animator.move(this._wrapper, x + offset[0], y + offset[1], duration, easing, callback, thisVal);
        return this;
    },

    /**
     * Appends the Draggable to a parent element, typically the document body.
     *
     * @param {HTMLElement} parentElement The parent element to which the
     * Draggable should be appended.
     * @returns {Draggable} Returns the Draggable.
     */
    append: function(parentElement) {
        if (this._wrapper.parentElement !== parentElement) {
            this.remove();

            parentElement.appendChild(this._wrapper);

            // Ensure the center of the element is aligned with the center of
            // the wrapper. clientWidth and clientHeight are not known until
            // the element has been appended
            var element = this.element;
            var style = element.style;

            this._originalElementRect = element.getBoundingClientRect();
            this._updateTranslationOffset();

            style.left = (-element.clientWidth * 0.5) + 'px';
            style.top = (-element.clientHeight * 0.5) + 'px';
        }

        return this;
    },

    /**
     * Removes the Draggable from its parent element.
     *
     * @returns {Draggable} Returns the ```Draggable``` instance.
     */
    remove: function() {
        var parentElement = this._wrapper.parentElement;

        if (parentElement) {
            parentElement.removeChild(this._wrapper);
        }

        return this;
    },

    /**
     * @param {Object} options
     *     @param {String} [options.transform]
     *     @param {Number} [options.duration]
     *     @param {String} [options.easing]
     *     @param {Function} [options.callback]
     *     @param {*} [options.thisVal]
     * @returns {Draggable} Returns the Draggable.
     */
    setShowAnimation: function(options) {
        this._setAnimation(this.options.show, options);

        return this;
    },

    /**
     * Sets the configuration for the draggable animation when it is dropped.
     * Typically, this is called internally by ```DragData.setDropOptions```.
     * If the Draggable is not dropped on a valid receiving dropzone, the
     * options set here will not be used.
     *
     * @param {Object} options
     *     @param {String} [options.transform]
     *     @param {Number} [options.duration]
     *     @param {String} [options.easing]
     *     @param {Function} [options.callback]
     *     @param {*} [options.thisVal]
     * @returns {Draggable} Returns the Draggable.
     */
    setDropAnimation: function(options) {
        this._setAnimation(this.options.drop, options);

        return this;
    },

    /**
     * Sets the configuration for the draggable animation when a drag is
     * cancelled. Typically, this is called internally by ```DragData.setCancelOptions```.
     * These options only take effect if the Draggable is dropped on an invalid
     * dropzone, or an area that is not a dropzone.
     *
     * @param {Object} options
     *     @param {String} [options.transform]
     *     @param {Number} [options.duration]
     *     @param {String} [options.easing]
     *     @param {Function} [options.callback]
     *     @param {*} [options.thisVal]
     * @returns {Draggable} Returns the Draggable.
     */
    setCancelAnimation: function(options) {
        this._setAnimation(this.options.cancel, options);

        return this;
    },

    /**
     * Returns the position of the Draggable as a 2-element (x, y) array.
     *
     * @returns {Array} The position of the Draggable.
     */
    position: function() {
        var rect = this._wrapper.getBoundingClientRect();
        var offset = this._translationOffset;
        return [rect.left + (rect.width * 0.5) - offset[0], rect.top + (rect.height * 0.5) - offset[1]];
    },

    /**
     * Plays the Draggable's show animation.
     *
     * @param {Function} callback
     * @param {*} thisVal
     */
    show: function(callback, thisVal) {
        this._animate(this.options.show, callback, thisVal);
        return this;
    },

    /**
     * Plays the Draggable's drop animation. This animation is based on the
     * parameters in the ```options.drop``` object that was either set in
     * the constructor or updated using ```setDropAnimation```.
     *
     * @param {Function} callback
     * @param {*} thisVal
     */
    drop: function(callback, thisVal) {
        this._animate(this.options.drop, callback, thisVal);
        return this;
    },

    /**
     * Plays the Draggable's cancel animation.
     *
     * @param {Function} callback
     * @param {*} thisVal
     */
    cancel: function(callback, thisVal) {
        this._animate(this.options.cancel, callback, thisVal);
        return this;
    },

    /*
     * @param {Object} rect
     */
    transformToMatch: function(rect) {
        var scaleX = this._originalElementRect.width > 0 ? rect.width / this._originalElementRect.width : 0;
        var scaleY = this._originalElementRect.height > 0 ? rect.height / this._originalElementRect.height : 0;
        var position = [rect.left + rect.width * 0.5, rect.top + rect.height * 0.5];

        return makeScale(scaleX, scaleY) + ' ' + makeTranslation(position[0], position[1]);
    },

    /*
     * Stores animation parameters for a pending animation for a given property.
     *
     * @param {Object} property
     * @param {Object} options
     * @see setDropAnimation
     * @see setCancelAnimation
     */
    _setAnimation: function(property, options) {
        if (!property || !options) {
            return;
        }

        property.__customAnimationOptions = options;
    },

    /*
     * Performs an animation based on the parameters in the given property.
     *
     * @param {Object} property
     * @param {Function} callback
     * @param {*} thisVal
     */
    _animate: function(property, callback, thisVal) {
        var animationOptions = _.defaults(property.__customAnimationOptions || {}, property);
        var className = animationOptions.className || '';
        var extracted = extractTranslation(animationOptions.transform);
        var translation = extracted ? extracted.translation : null;
        var transform = extracted ? extracted.transform : animationOptions.transform;
        var finalCallback = sequentiallyApply(this, 
            function(ev) {
                this._updateTranslationOffset();
                this.element.classList.remove(className);
            }, 
            Sistine.Util.applyIfExists(animationOptions.callback, animationOptions.thisVal),
            Sistine.Util.applyIfExists(callback, thisVal)
        );

        this.element.classList.add(className);
        Sistine.Animator.transform(this._wrapper, translation, animationOptions.duration, animationOptions.easing);
        Sistine.Animator.transform(this.element, transform, animationOptions.duration, animationOptions.easing, finalCallback, this);

        delete property.__customAnimationOptions;
    },

    _updateTranslationOffset: function() {
        var element = this.element;
        var origin = this.options.translationOrigin;
        var rect = element.getBoundingClientRect();
        this._translationOffset = [(rect.width * 0.5) - (rect.width * origin[0]), (rect.height * 0.5) - (rect.height * origin[1])];
    }
};

/*
 * Creates a wrapper object for a draggable element and applies appropriate
 * styles to both the wrapper and element. The wrapper is used to independently
 * move the draggable element using CSS transforms so that movement transforms
 * do not affect any transforms or other styles applied to the draggable
 * element itself.
 */
function generateWrapper(element, options) {
    options = options || {};

    var wrapper = document.createElement('div');

    // Set up the wrapper
    var style = wrapper.style;
    style.position = 'absolute';
    style.left = wrapper.style.top = 0;
    style.zIndex = 9999;
    style.overlow = 'visible';
    style.pointerEvents = 'none';
    wrapper.dataset.draggable = '';
    wrapper.draggable = false; // Intentionally disable browser-based dragging
    applyPrefixedCss(wrapper, 'transformOrigin', 'center center 0px');

    // Set up the element
    style = element.style;
    style.position = 'absolute';
    element.draggable = false;
    applyPrefixedCss(element, 'transformOrigin', 'center center 0px');
    applyPrefixedCss(element, 'transform', 'scale3d(1, 1, 1)');

    if (options.className) {
        element.classList.add(options.className);
    }

    wrapper.appendChild(element);
    return wrapper;
}

/**
 * The Manager provides the primary interface for managing all drag-and-drop
 * functionality within an application.
 *
 * @constructor
 * @param {Object} [options] All constructor options.
 *     @param {Object} [options.cssProps]
 *     @param {Object} [options.eventNames] A dictionary specifying the event
 *     names to be used when emitting drag events.
 */
function Manager(options) {
    this.options = _.defaults(options || {}, Sistine.Drag.defaults);

    // Integer for keeping track of unique drag idenitfiers using a simple
    // increment
    this._currentDragId = 0;

    // Array of all pointer IDs that are the "master" pointer for a drag. Even
    // though a drag may be controlled by a cluster of pointers, we ensure
    // that the drag has a single master pointer that it trackes.
    this._masterPointerIds = [];

    // Hash of drag info objects, keyed by the pointer ID which they are tied
    // to (because a drag can have multiple pointers, a given drag info 
    // instance may appear in this hash multiple times)
    this._dragData = {};

    // Array of floating drags. These are drags that are not associated with
    // any pointer, but are simply "floating" on the screen.
    this._floatingDragData = [];

    // _.bind is slow, particularly for mousemove performance, so we use normal
    // binding instead
    var self = this;
    this._boundHandlePointerMove = function(ev) { self._handlePointerMove.call(self, ev); };
    this._boundHandlePointerUp = function(ev) { self._handlePointerUp.call(self, ev); };
    this._boundHandlePointerDown = function(ev) { self._handlePointerDown.call(self, ev); };
    document.addEventListener('pointermove', this._boundHandlePointerMove, true);
    document.addEventListener('pointerup', this._boundHandlePointerUp, true);
    document.addEventListener('pointercancel', this._boundHandlePointerUp, true);
    document.addEventListener('pointerdown', this._boundHandlePointerDown, true);

    // Apply any default CSS properties that aid in improving drag behavior
    document.addEventListener('DOMContentLoaded', _.bind(function () {
        var body = document.getElementsByTagName('body')[0];
        applyPrefixedCssProps(body, this.options.cssProps);
    }, this));
}

Manager.prototype = {
    /**
     * Begins a drag of an object on the document body. The drag proxy for all
     * new drags will be appended to the document body at z-index 9999.
     *
     * @param {Object} [options] All options for the drag.
     *     @param {HTMLElement} [options.proxy] The HTML element that represents
     *     the drag. This will be wrapped in a Draggable for movement on the 
     *     document body while the drag is occuring.
     *     @param {*} [options.payload] The data represented by this drag. May
     *     be any arbitrary object.
     *     @param {Event|Array} [options.pointers] May be either a Pointer Event, or
     *     an array of pointer IDs.
     *     If this parameter is left out or set to null, but an initialPosition is
     *     provided, then the Manager will "float" the drag starting at the
     *     initial position provided.
     *     @param {Array} [options.initialPosition] The initial position at which
     *     the drag should appear. This should be a two-element array representing
     *     the (x, y) position at which the drag should start when showing. If
     *     not defined the drag will appear at the position of the pointer
     *     provided in the ```pointers``` parameter, if available, and (0, 0)
     *     otherwise.
     *     @param {Object} [options.timeoutOptions] Options for timeout.
     *           @param {Number} [options.timeoutOptions.timeout] The timeout in milliseconds
     *           for a floating drag to remain on the screen before it should be removed.
     *           @param {String} [options.timeoutOptions.ease] The type of animation action
     *           used to animate away a floating drag when it is removed from the screen.
     *           Use one of ```Sistine.Animate.LINEAR```, ```Sistine.Animate.EASE```,
     *           ```Sistine.Animate.EASE_IN```, ```Sistine.Animate.EASE_OUT```,
     *           or ```Sistine.Animate.EASE_IN_OUT```.
     *           @param {Number} [options.timeoutOptions.duration] The time in seconds
     *           to animate away a floating drag when it is removed from the screen.
     *     @param {Number} [options.dragAction] The drag action that should
     *     be accepted by any dropzone that is allowed to accept this drag.
     *     Use one of ```Sistine.Drag.DRAG_COPY```, ```Sistine.Drag.DRAG_MOVE```,
     *     or ```Sistine.Drag.DRAG_ALL```.
     *     @param {Object} [options.tossOptions] Options for tossing.
     *         @param {Number} [options.tossOptions.tossAction] Sets the 
     *         acceptable toss action for the drag. Use one of 
     *         ```Sistine.Drag.TOSS_ALL```, ```Sistine.Drag.TOSS_AWAY```, 
     *         ```Sistine.Drag.TOSS_WITHIN```, or ```Sistine.Drag.TOSS_NONE```.
     *         Defaults to ```Sistine.Drag.TOSS_ALL```.
     *         @param {Boolean} [options.tossOptions.autoRemove=true] Set to false
     *         if you do not want items that have been tossed away to be automatically
     *         removed from display.
     *         @param {Number} [options.tossOptions.threshold] The minimum speed
     *         threshold required to detect a toss. Defaults to 500 px/s.
     *         @param {Number} [options.tossOptions.friction] The amount of
     *         friction to apply to the toss animation. Higher numbers equal
     *         more friction. Defaults to 0.05.
     *         @param {Number} [options.tossOptions.multiplier] Any amount with 
     *         which to multiply the initial toss velocity. Defaults to 1.
     *         @param {Number} [options.tossOptions.stopSpeed] The speed at which
     *         animation of any toss should stop. Defaults to 0.01 px/s.
     *     @param {Object} [options.animationOptions] Options for the animation
     *     that plays when the drag is first shown.
     *         @param {String} [options.animationOptions.transform]
     *         @param {String} [options.animationOptions.duration]
     *         @param {String} [options.animationOptions.easing]
     *         @param {String} [options.animationOptions.callback]
     *         @param {String} [options.animationOptions.thisVal]
     *     @param {Object} [options.draggableOptions] The options that should
     *     be applied to the ```Draggable``` when it is created. For more information
     *     on the ```Draggable``` options format see the ```Draggable``` constructor
     *     documentation.
     *     @param {Number} [options.lockAxis] The axis on which this drag should
     *     be locked. Defaults to ```Sistine.Drag.AXIS_ANY```, which is
     *     equivalent to a free drag.
     *     @param {Object} [options.userData] An arbitrary object that will
     *     be attached to the ```DragData``` for this drag for later reference.
     * @returns {Object} Returns the drag info object.
     * @see DragData
     */
    beginDrag: function(options) {
        // Check for required parameters
        if (_.isUndefined(options) ||
            _.isUndefined(options.proxy) ||
            _.isUndefined(options.payload)) {
            return null;
        }

        options = Sistine.Util.deepDefaults(options || {}, this._dragDefaults);

        var pointerInfo = getPointerInfo(options);
        var pointerIds = pointerInfo.pointerIds;
        var initialPosition = pointerInfo.position;

        if (this.hasDragForPointers(pointerIds)) {
            return null;
        }

        var dropzones = dropzonesFromPoint(initialPosition[0], initialPosition[1]);
        var overElement = document.elementFromPoint(initialPosition[0], initialPosition[1]);
        var body = document.getElementsByTagName('body')[0];
        var draggable = new Draggable(options.proxy, options.draggableOptions)
            .setShowAnimation(options.animationOptions)
            .append(body)
            .move(initialPosition[0], initialPosition[1]);

        var dragData = new DragData({
            draggable: draggable,
            payload: options.payload,
            pointerIds: pointerIds,
            dropzones: dropzones,
            timeoutOptions: options.timeoutOptions,
            dragAction: options.dragAction,
            eventNames: this.options.eventNames,
            tossOptions: options.tossOptions,
            lockAxis: options.lockAxis,
            userData: options.userData
        });

        // Cancel any gestures using the pointers for this drag
        Sistine.cancelPointers(pointerIds);

        // Wait for the show animation to complete before tracking or floating
        // the drag
        draggable.show(function() {
            // If we don't pass in any pointers, that means we want the drag to be 
            // a floating drag, otherwise track as normal
            if (_.isUndefined(dragData._pointerIds) || dragData._pointerIds.length === 0) {
                this._floatDrag(dragData);
            }
            else {
                // Start tracking
                this._trackDrag(dragData);
            }
        }, this);

        return dragData;
    },

    /**
     * Immediately ends a drag with the given ```DragData.``` The Manager will
     * immediately stop tracking the drag and remove it from display.
     */
    terminateDrag: function(dragData) {
        var draggable = dragData.draggable;
        var element = draggable.element;
        var masterPointerId = dragData._masterPointerId;
        var pointerIds = dragData._pointerIds;
        var idx = _.indexOf(this._masterPointerIds, masterPointerId);
        var pointerId;

        if (idx >= 0) {
            this._masterPointerIds.splice(idx, 1);

            for (var i = 0, len = pointerIds.length; i < len; i++) {
                pointerId = pointerIds[i];
                delete this._dragData[pointerId];
            }

            dragData.stopTimeout();
            element.removeEventListener('pointerdown', this._boundHandlePointerDown);
            dispatchEvent(this.options.eventNames.dragEnd, element, dragData);
            draggable.remove();
        }
    },

    /**
     * Registers an element as a dropzone. This can also be done by simply
     * adding the 'data-dropzone' attribute to any HTML element.
     *
     * @param {HTMLElement} element
     */
    registerDropzone: function(element) {
        element.dataset.dropzone = '';
    },

    /**
     * De-registers an element as a dropzone.
     *
     * @param {HTMLElement} element
     */
    deregisterDropzone: function(element) {
        delete element.dataset.dropzone;
    },

    /**
     * Returns true if the Manager has an active drag for any of the provided
     * pointer IDs.
     *
     * @param {Array} pointerIds An array of pointer IDs.
     * @returns {Boolean} Returns true if the Manager has an active drag for
     * any of the provided pointer IDs.
     */
    hasDragForPointers: function(pointerIds) {
        for (var i = 0, len = pointerIds.length; i < len; i++) {
            if (this.hasDragForPointer(pointerIds[i])) {
                return true;
            }
        }

        return false;
    },

    /**
     * Returns true if there is currently an active drag for the given pointer
     * ID.
     *
     * @param {Number} pointerId
     * @returns {Boolean} Returns true if the Manager has an active drag for
     * the given pointer ID.
     */
    hasDragForPointer: function(pointerId) {
        return !_.isUndefined(this._dragData[pointerId]);
    },

    /**
     * Returns the ```DragData``` instance for any drag active with the given
     * pointer ID.
     *
     * @param {Number} pointerId
     * @returns {Object} The ```DragData``` for a drag associated with the
     * given pointer ID.
     */
    getDragForPointer: function(pointerId) {
        return this._dragData[pointerId];
    },

    /**
     * Given a point (x, y), return the first drag under that point. The drag
     * may either be an active drag currently being dragged by the user, or an
     * "inactive" floating drag.
     *
     * @param {Number} x The x-coordinate.
     * @param {Number} y The y-coordinate.
     * @returns {DragData}
     */
    getDragFromPoint: function(x, y) {
        var element;

        enablePointersOnAllDraggables();
        element = document.elementFromPoint(x, y);
        disablePointersOnAllDraggables();

        // Keep looping to find the parentElement that contains the data-draggable 
        // attribute, because document.elementFromPoint might return an element
        // inside a Draggable proxy rather than the proxy itself
        while (element && element.parentElement) {
            if (element.parentElement.getAttribute('data-draggable') !== null) {
                var i, len, dragData;

                // First check active drags
                for (i = 0, len = this._masterPointerIds.length; i < len; i++) {
                   dragData = this._dragData[this._masterPointerIds[i]];
                   if (dragData && dragData.draggable.element === element) {
                       return dragData;
                   }
                }

                // Then check floating drags
                for (i = 0, len = this._floatingDragData.length; i < len; i++) {
                    dragData = this._floatingDragData[i];
                    if (dragData.draggable.element === element) {
                        return dragData;
                    }
                }
            } 

            element = element.parentElement;
        }
    },

    // Private methods
    
    _handlePointerMove: function(ev) {
        var pointerId = ev.pointerId;
        var isActive = _.indexOf(this._masterPointerIds, pointerId) > -1;

        if (!isActive) {
            return;
        }

        var dragData = this.getDragForPointer(pointerId);
        var draggable = dragData.draggable;
        var position = draggable.position();
        var lockAxis = dragData.lockAxis;

        if (dragData.lockAxis === AXIS_Y) {
            draggable.move(position[0], ev.pageY);
        }
        else if (dragData.lockAxis === AXIS_X) {
            draggable.move(ev.pageX, position[1]);
        }
        else {
            draggable.move(ev.pageX, ev.pageY);
        }

        var lastDropzones = dragData.dropzones;
        var currentDropzones = dropzonesFromTarget(ev.target);
        var lostZones = _.difference(lastDropzones, currentDropzones);
        var newZones = _.difference(currentDropzones, lastDropzones);
        var sameZones = _.intersection(lastDropzones, currentDropzones);

        dragData.overElement = ev.target;

        // Notify of all drag leaves
        dispatchEvent(this.options.eventNames.dragLeave, lostZones, dragData);

        dragData.reset(currentDropzones, ev.target);

        // Notify of all drag enters and overs
        dispatchEvent(this.options.eventNames.dragEnter, newZones, dragData);
        dispatchEvent(this.options.eventNames.dragOver, sameZones, dragData);
        dispatchEvent(this.options.eventNames.dragMove, draggable.element, dragData);

        ev.stopPropagation();
    },

    _handlePointerUp: function(ev) {
        var pointerId = ev.pointerId;
        var dragData = this.getDragForPointer(pointerId);

        if (!dragData) {
            return;
        }

        var draggable = dragData.draggable;
        var pointerIds = dragData._pointerIds;
        var masterIdx = _.indexOf(this._masterPointerIds, pointerId);

        // If the user lifted a pointer identified as a master pointer, then
        // stop tracking that pointer as a master
        if (masterIdx > -1) {
            this._masterPointerIds.splice(masterIdx, 1);
            delete dragData._masterPointerId;
        }

        // Remove the pointer ID
        pointerIds.splice(_.indexOf(pointerIds, pointerId), 1);
        delete this._dragData[pointerId]; 

        if (pointerIds.length > 0) {
            // Other pointers are still on the drag, so set a new master pointer
            // ID
            this._masterPointerIds.push(pointerIds[0]);
            dragData._masterPointerId = pointerIds[0];
        }
        else {
            // No remaining pointers on the drag, so completely stop and
            // prepare for release or toss
            this._stopTrackingDrag(dragData, pointerId);
        }

        // Do not stop propagation in this case, since we don't know how
        // the drag was started, a pointerdown may have been recorded
    },

    _handlePointerDown: function(ev) {
        var pointerId = ev.pointerId;
        var dragData = this.getDragFromPoint(ev.pageX, ev.pageY);

        if (!dragData || this.getDragForPointer(pointerId)) {
            return;
        }

        // Check if this is a floating drag, and if it is, stop floating and
        // start tracking
        var floatIdx = _.indexOf(this._floatingDragData, dragData);
        if (floatIdx > -1) {
            this._floatingDragData.splice(floatIdx, 1);
            this._masterPointerIds.push(pointerId);
            dragData._masterPointerId = pointerId;
            dragData.stopTimeout();
        }

        // Add the pointer to the drag 
        dragData._pointerIds.push(pointerId);
        this._dragData[pointerId] = dragData;

        dragData.draggable.stopToss();

        ev.stopPropagation();
    },

    _floatDrag: function(dragData) {
        this._floatingDragData.push(dragData);
        dragData.startTimeout();
    },

    /*
     * Called internally to begin tracking a drag, including dispatching all
     * start events.
     */
    _trackDrag: function(dragData) {
        var draggable = dragData.draggable;
        var dropzones = dragData.dropzones;
        var eventNames = this.options.eventNames;
        var masterPointerId = dragData._masterPointerId;
        var pointerIds = dragData._pointerIds;

        // Put the drag info in the hash, keyed for every pointer ID provided
        this._masterPointerIds.push(masterPointerId);
        for (var i = 0, len = pointerIds.length; i < len; i++) {
            this._dragData[pointerIds[i]] = dragData;
        }

        dispatchEvent(eventNames.dragStart, dragData.draggable.element, dragData);
        dispatchEvent(this.options.eventNames.dragEnter, dropzones, dragData);
    },

    _stopTrackingDrag: function(dragData, lastPointerId) {
        var draggable = dragData.draggable;
        var tossVelocity = detectTossVelocity(lastPointerId);

        if (dragData.tossIsAllowed(tossVelocity)) {
            this._performToss(tossVelocity, dragData);
        }
        else {
            this._performDrop(dragData);
        }
    },

    _performToss: function(tossVelocity, dragData) {
        var tossOptions = dragData.tossOptions;
        var draggable = dragData.draggable;
        var boundingBox = dragData.tossBoundingBox();
        var dropzones = dragData.dropzones;
        var eventNames = this.options.eventNames;
        var element = draggable.element;

        dispatchEvent(eventNames.dragLeave, dropzones, dragData);
        dispatchEvent(eventNames.dragEnd, element, dragData);

        dragData.reset();

        // Constrain toss to dominant axis
        if (Math.abs(tossVelocity[0]) >= Math.abs(tossVelocity[1])) {
            tossVelocity[1] = 0;
        }
        else {
            tossVelocity[0] = 0;
        }

        draggable.toss(tossVelocity, tossOptions.friction, tossOptions.multiplier, 
                tossOptions.stopSpeed, tossOptions.elasticity, tossOptions.maxSpeed, 
                boundingBox, function() {
            // If the user has tossed the item beyond the Y-axis boundaries,
            // we assume that this is a toss away. The system will prevent this
            // from happening by restricting the boundaries if a toss away
            // is not allowed
            var pos = draggable.position();
            var windowDims = getWindowDimensions();
            
            if (pos[1] > windowDims[1] || pos[1] < 0) {
                dispatchEvent(eventNames.dragTossAway, element, dragData);

                if (tossOptions.autoRemove) {
                    draggable.remove();
                }
            }
            else {
                dispatchEvent(eventNames.dragTossWithin, element, dragData);
                dragData.startTimeout();
            }
        }, this);

        this._floatingDragData.push(dragData);
        delete dragData._masterPointerId;
        dragData._pointerIds.length = 0;
    },

    _performDrop: function(dragData) {
        var draggable = dragData.draggable;
        var eventNames = this.options.eventNames;
        var element = draggable.element;

        dragData.stopTimeout();
        element.removeEventListener('pointerdown', this._boundHandlePointerDown);
        dispatchEvent(eventNames.dragEnd, element, dragData);
        
        if (dragData.dropIsAllowed()) {
            dispatchEvent(eventNames.drop, dragData.dropzones, dragData);

            draggable.drop(function() {
                draggable.remove();
            }, this);
        }
        else {
            dispatchEvent(eventNames.dragCancel, dragData.dropzones, dragData);

            draggable.cancel(function() {
                draggable.remove();
            }, this);
        }
    },

    /*
     * Default options for new drags created with the ```beginDrag``` method.
     */
    _dragDefaults: {
        initialPosition: [0, 0],
        dragAction: DRAG_COPY,
        timeoutOptions: {
            timeout: 60000,
            ease: EASE_IN,
            duration: 0.5
        },
        tossOptions: {
            tossAction: TOSS_ALL,
            friction: 0.03,
            multiplier: 2,
            threshold: 500,
            stopSpeed: 0.5,
            autoRemove: true,
            elasticity: {
                left: 0.2,
                right: 0.2,
                top: 0,
                bottom: 0
            },
            maxSpeed: 10000
        },
        lockAxis: AXIS_ANY
    }
};

/*
 * Creates a drag event as a DOM event.
 *
 * @param {String} type The event type.
 * @param {DragData} dragData
 * @param {Object} props
 */
function createEvent(type, dragData, pointerEvent, props) {
    var ev = document.createEvent('Event'),
        p = props || {};

    ev.initEvent(type, p.bubbles ? p.bubbles : true, p.cancelable ? p.cancelable : true);
    return _.extend(ev, {
        'data': dragData || {}
    });
}

/*
 * Creates and dispatches an event as a DOM event.
 *
 * @param {String} type The event type.
 * @param {HTMLElement|HTMLElement[]} element
 * @param {DragData} dragData
 */
function dispatchEvent(type, element, dragData) {
    var ev = createEvent(type, dragData);

    if (_.isArray(element)) {
        for (var i = 0, len = element.length; i < len; i++) {
            element[i].dispatchEvent(ev);
        }
    }
    else if (element) {
        element.dispatchEvent(ev);
    }
}

/*
 * Sets pointer-events on all draggables to 'auto'.
 */
function enablePointersOnAllDraggables() {
    _(getAllDraggables()).each(function(draggable) {
        draggable.style.pointerEvents = 'auto';
    });
}

/*
 * Sets pointer-events on all draggables to 'none'.
 */
function disablePointersOnAllDraggables() {
    _(getAllDraggables()).each(function(draggable) {
        draggable.style.pointerEvents = 'none';
    });
}

function dropzonesFromPoint(x, y) {
    return dropzonesFromTarget(document.elementFromPoint(x, y));
}

function dropzonesFromTarget(element) {
    var dropzones = [];

    while (element) {
        if (element.getAttribute('data-dropzone') !== null) {
            dropzones.push(element);
        }

        element = element.parentElement;
    }

    return dropzones;
}

/*
 * Gets all draggables on the document body.
 *
 * @returns {Array} An array of all draggables (as HTMLElements) on the
 * document body.
 */
function getAllDraggables() {
    return document.querySelectorAll('[data-draggable]');
}

/*
 * Gets all dropzones on the document body.
 *
 * @returns {Array} An array of all dropzones (as HTMLElements) on the
 * document body.
 */
function getAllDropzones() {
    // Use the first pointer ID as the master pointer
    return document.querySelectorAll('[data-dropzone]');
}

/*
 * Helper method for ```beginDrag``` that determines the correct info for
 * the pointers parameter. This allows beginDrag to be behave somewhat
 * like an overloaded method where different object types provided to the
 * pointers parameter result in different behavior.
 */
function getPointerInfo(options) {
    var pointers = options.pointers;
    var pointerIds;
    var position;

    if (_.isArray(pointers)) {
        pointerIds = pointers;
        position = options.initialPosition || [0, 0];
    }
    else if (!_.isUndefined(pointers)) {
        pointerIds = [pointers.pointerId];
        position = [pointers.pageX, pointers.pageY];
    }
    else {
        pointerIds = [];
        position = options.initialPosition || [0, 0];
    }

    return {
        'pointerIds': pointerIds,
        'position': position
    };
}

/*
 * Given a particular pointer ID, gets the last velocity of that pointer
 * in px/s, or returns 0 if that pointer ID is not active.
 *
 * @param {Number} pointerId
 * @returns {Array} The pointer's last known velocity in px/s.
 */
function detectTossVelocity(pointerId) {
    var pointer = Sistine.pointerSet.get(pointerId); 
    return pointer ? pointer.lastVelocity() : [0, 0];
}

/**
 * @namespace
 */
Sistine.Drag = Sistine.Drag || {};

/**
 * @namespace
 */
Sistine.Util = Sistine.Util || {};

/**
 * @namespace
 */
Sistine.Animation = Sistine.Animation || {};

/**
 * @memberof Sistine.Drag
 *
 * @prop {Object} cssProps
 * @prop {Object} eventNames The list of default event names used by the 
 * Manager when emitting drag, toss and drop events.
 *     @prop {String} eventNames.dragStart Defaults to 'sistine-dragstart'.
 *     @prop {String} eventNames.dragEnter
 *     @prop {String} eventNames.dragLeave
 *     @prop {String} eventNames.dragEnd
 *     @prop {String} eventNames.dragOver
 *     @prop {String} eventNames.dragMove
 *     @prop {String} eventNames.drop
 *     @prop {String} eventNames.dragCancel
 *     @prop {String} eventNames.dragTimeout
 *     @prop {String} eventNames.dragTossAway
 */
Sistine.Drag.defaults = {
    cssProps: {
        userSelect: 'none',
        touchSelect: 'none',
        touchAction: 'none',
        touchCallout: 'none',
        contentZooming: 'none',
        userDrag: 'none',
        tapHighlightColor: 'rgba(0,0,0,0)'
    },

    eventNames: {
        dragStart: 'sistine-dragstart',

        dragEnter: 'sistine-dragenter',

        dragLeave: 'sistine-dragleave',

        dragEnd: 'sistine-dragend',

        dragOver: 'sistine-dragover',

        dragMove: 'sistine-dragmove',

        drop: 'sistine-drop',

        dragCancel: 'sistine-dragcancel',

        dragTimeout: 'sistine-dragtimeout',

        dragTossAway: 'sistine-tossaway',

        dragTossWithin: 'sistine-tosswithin'
    }
};

/**
 * Default singleton ```Manager``` instance. Use this for all interactions with the
 * default ```Manager```.
 *
 * @memberof Sistine
 */
Sistine.DragManager = new Manager();

_.extend(Sistine.Drag, {
    Draggable: Draggable,
    Manager: Manager,
    DragData: DragData,

    DRAG_NONE: DRAG_NONE,
    DRAG_MOVE: DRAG_MOVE,
    DRAG_COPY: DRAG_COPY,
    DRAG_ALL: DRAG_ALL,

    AXIS_X: AXIS_X,
    AXIS_Y: AXIS_Y,
    AXIS_ANY: AXIS_ANY,

    TOSS_NONE: TOSS_NONE,
    TOSS_WITHIN: TOSS_WITHIN,
    TOSS_AWAY: TOSS_AWAY,
    TOSS_ALL: TOSS_ALL
});

_.extend(Sistine.Util, {
    applyPrefixedCssProps: applyPrefixedCssProps,
    applyPrefixedCss: applyPrefixedCss,
    getWindowDimensions: getWindowDimensions,
    parseDuration: parseDuration,
    prefixStyleValue: prefixStyleValue,
    sequentiallyApply: sequentiallyApply
});

_.extend(Sistine.Animation, {
    Animator: Animator,
    makeTranslation: makeTranslation,
    makeScale: makeScale,
    makeTransition: makeTransition,
    makeTransformOrigin: makeTransformOrigin,
    extractTranslation: extractTranslation,
    extractScale: extractScale,

    LINEAR: LINEAR,
    EASE: EASE,
    EASE_OUT: EASE_OUT,
    EASE_IN: EASE_IN,
    EASE_IN_OUT: EASE_IN_OUT
});

if (typeof module !== 'undefined' && module.exports) {
    module.exports = Sistine;
}
else {
    window[exportName] = Sistine;
}

})(window, document, 'Sistine');

