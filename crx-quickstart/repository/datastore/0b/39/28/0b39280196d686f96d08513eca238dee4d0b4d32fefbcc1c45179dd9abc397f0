window["Coral"] = window["Coral"] || {};
window["Coral"]["strings"] = window["Coral"]["strings"] || {};
window["Coral"]["strings"]["coralui-component-aeon"] = {"en-US":{"h:mm a/[translation hint:momentjs time: short]":"h:mm a","MMMM, D YYYY/[translation hint:momentjs date: long]":"MMMM, D YYYY","MMM D/[translation hint:momentjs date: medium without year]":"MMM D","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd, MMM D","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd, MMMM D","NOW":"NOW","Timeline":"Timeline","Column":"Column","List":"List","Search":"Search","No Calendar Entries":"No Calendar Entries","Remove all Filters":"Remove all Filters","Cancel":"Cancel","Apply":"Apply","Today":"Today","This Week":"This Week","Next Week":"Next Week","View":"View","at/[translation hint:date and time delimiter]":"at","Settings":"Settings","Sort by":"Sort by","Start date":"Start date","End date":"End date","Group by":"Group by","Timeline and Column only":"Timeline and Column only","None":"None","Stack cards":"Stack cards","Card size":"Card size","Small":"Small","Medium":"Medium","Large":"Large"},"de-DE":{"h:mm a/[translation hint:momentjs time: short]":"HH:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D. MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D. MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd, D. MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd, D. MMMM","NOW":"JETZT","Timeline":"Zeitleiste","Column":"Spalte","List":"Liste","Search":"Suchen","No Calendar Entries":"Keine Kalendereinträge","Remove all Filters":"Alle Filter entfernen","Cancel":"Abbrechen","Apply":"Übernehmen","Today":"Heute","This Week":"Diese Woche","Next Week":"Nächste Woche","View":"Ansicht","at/[translation hint:date and time delimiter]":"zu","Settings":"Einstellungen","Sort by":"Sortieren nach","Start date":"Startdatum","End date":"Enddatum","Group by":"Gruppieren nach","Timeline and Column only":"Nur Zeitleiste und Spalte","None":"Keine","Stack cards":"Karten stapeln","Card size":"Kartengröße","Small":"Klein","Medium":"Mittel","Large":"Groß"},"fr-FR":{"h:mm a/[translation hint:momentjs time: short]":"HH:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd D MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd D MMMM","NOW":"MAINTENANT","Timeline":"Frise chronologique","Column":"Colonne","List":"Liste","Search":"Rechercher","No Calendar Entries":"Aucune entrée de calendrier","Remove all Filters":"Supprimer tous les filtres","Cancel":"Annuler","Apply":"Appliquer","Today":"Aujourd’hui","This Week":"Cette semaine","Next Week":"Semaine suivante","View":"Affichage","at/[translation hint:date and time delimiter]":"à","Settings":"Paramètres","Sort by":"Trier par","Start date":"Date de début","End date":"Date de fin","Group by":"Grouper par","Timeline and Column only":"Chronologie et colonne seulement","None":"Néant","Stack cards":"Empiler les cartes","Card size":"Taille de la carte","Small":"Petite","Medium":"Moyenne","Large":"Grande"},"it-IT":{"h:mm a/[translation hint:momentjs time: short]":"HH:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd, D MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd, D MMMM","NOW":"ORA","Timeline":"Timeline","Column":"Colonna","List":"Elenco","Search":"Ricerca","No Calendar Entries":"Nessuna voce di calendario","Remove all Filters":"Rimuovi tutti i filtri","Cancel":"Annulla","Apply":"Applica","Today":"Oggi","This Week":"Questa settimana","Next Week":"Settimana prossima","View":"Visualizza","at/[translation hint:date and time delimiter]":"a","Settings":"Impostazioni","Sort by":"Ordina per","Start date":"Data iniziale","End date":"Data finale","Group by":"Raggruppa per","Timeline and Column only":"Solo timeline e colonna","None":"Nessuno","Stack cards":"Sovrapponi carte","Card size":"Dimensione scheda","Small":"Piccolo","Medium":"Medio","Large":"Grande"},"ja-JP":{"h:mm a/[translation hint:momentjs time: short]":"HH:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"YYYY MMMM D","MMM D/[translation hint:momentjs date: medium without year]":"MMMD日","ddd, MMM D/[translation hint:momentjs date: medium without year]":"MMM D ddd","dddd, MMMM D/[translation hint:momentjs date: full without year]":"MMMM D dddd","NOW":"現在","Timeline":"タイムライン","Column":"列","List":"リスト","Search":"検索","No Calendar Entries":"カレンダーエントリがありません","Remove all Filters":"すべてのフィルターを削除","Cancel":"キャンセル","Apply":"適用","Today":"今日","This Week":"今週","Next Week":"次の週","View":"表示","at/[translation hint:date and time delimiter]":"日時 :","Settings":"設定","Sort by":"並べ替え基準","Start date":"開始日","End date":"終了日","Group by":"グループ化基準","Timeline and Column only":"タイムラインおよび列のみ","None":"なし","Stack cards":"カードを積み重ねる","Card size":"カードのサイズ","Small":"小","Medium":"中","Large":"大"},"es-ES":{"h:mm a/[translation hint:momentjs time: short]":"HH:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd, D MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd, D MMMM","NOW":"AHORA","Timeline":"Cronología","Column":"Columna","List":"Lista","Search":"Buscar","No Calendar Entries":"No hay ninguna entrada de calendario.","Remove all Filters":"Quitar todos los filtros","Cancel":"Cancelar","Apply":"Aplicar","Today":"Hoy","This Week":"Esta semana","Next Week":"Semana siguiente","View":"Ver","at/[translation hint:date and time delimiter]":"a las","Settings":"Configuración","Sort by":"Ordenar por","Start date":"Fecha de inicio","End date":"Fecha de finalización","Group by":"Agrupar por","Timeline and Column only":"Solo línea de tiempo y columna","None":"Ninguno","Stack cards":"Apilar tarjetas","Card size":"Tamaño de tarjeta","Small":"Pequeño","Medium":"Medio","Large":"Grande"},"ko-KR":{"h:mm a/[translation hint:momentjs time: short]":"a h:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"YYYY MMMM D","MMM D/[translation hint:momentjs date: medium without year]":"MMM D일","ddd, MMM D/[translation hint:momentjs date: medium without year]":"MMM D ddd","dddd, MMMM D/[translation hint:momentjs date: full without year]":"MMMM D dddd","NOW":"지금","Timeline":"타임라인","Column":"열","List":"목록","Search":"검색","No Calendar Entries":"달력 항목 없음","Remove all Filters":"모든 필터 제거","Cancel":"취소","Apply":"적용","Today":"오늘","This Week":"이번 주","Next Week":"다음 주","View":"보기","at/[translation hint:date and time delimiter]":"해당 위치","Settings":"설정","Sort by":"정렬 기준","Start date":"시작 날짜","End date":"종료 날짜","Group by":"그룹 기준","Timeline and Column only":"타임라인 및 열만 해당","None":"없음","Stack cards":"카드 쌓기","Card size":"카드 크기","Small":"작음","Medium":"보통","Large":"큼"},"zh-CN":{"h:mm a/[translation hint:momentjs time: short]":"a h:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"YYYY MMMM D","MMM D/[translation hint:momentjs date: medium without year]":"MMMD日","ddd, MMM D/[translation hint:momentjs date: medium without year]":"MMM D ddd","dddd, MMMM D/[translation hint:momentjs date: full without year]":"MMMM D dddd","NOW":"现在","Timeline":"时间轴","Column":"列","List":"列表","Search":"搜索","No Calendar Entries":"无日历条目","Remove all Filters":"删除所有过滤器","Cancel":"取消","Apply":"应用","Today":"今天","This Week":"本周","Next Week":"下周","View":"视图","at/[translation hint:date and time delimiter]":"生成时间：","Settings":"设置","Sort by":"排序方式","Start date":"开始日期","End date":"结束日期","Group by":"分组方式","Timeline and Column only":"仅限时间轴和列","None":"无","Stack cards":"堆栈卡","Card size":"卡大小","Small":"小","Medium":"中","Large":"大"},"zh-TW":{"h:mm a/[translation hint:momentjs time: short]":"a h:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"YYYY MMMM D","MMM D/[translation hint:momentjs date: medium without year]":"MMMD日","ddd, MMM D/[translation hint:momentjs date: medium without year]":"MMM D ddd","dddd, MMMM D/[translation hint:momentjs date: full without year]":"MMMM D dddd","NOW":"現在","Timeline":"時間軸","Column":"欄","List":"清單","Search":"搜尋","No Calendar Entries":"沒有行事曆項目","Remove all Filters":"移除所有篩選","Cancel":"取消","Apply":"套用","Today":"今天","This Week":"本週","Next Week":"下週","View":"檢視","at/[translation hint:date and time delimiter]":"產生時間:","Settings":"設定","Sort by":"排序方式","Start date":"開始日期","End date":"結束日期","Group by":"分組依據","Timeline and Column only":"僅限時間軸和欄","None":"無","Stack cards":"堆疊卡片","Card size":"卡片大小","Small":"小","Medium":"中","Large":"大"},"pt-BR":{"h:mm a/[translation hint:momentjs time: short]":"HH:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd, D MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd, D MMMM","NOW":"AGORA","Timeline":"Linha do tempo","Column":"Coluna","List":"Listar","Search":"Procurar","No Calendar Entries":"Não há entradas no calendário","Remove all Filters":"Remover todos os filtros","Cancel":"Cancelar","Apply":"Aplicar","Today":"Hoje","This Week":"Nesta semana","Next Week":"Próxima semana","View":"Exibir","at/[translation hint:date and time delimiter]":"às","Settings":"Configurações","Sort by":"Classificar por","Start date":"Data inicial","End date":"Data Final","Group by":"Agrupar por","Timeline and Column only":"Somente Linha do tempo e Coluna","None":"Nenhum","Stack cards":"Pilha de cartas","Card size":"Tamanho do cartão","Small":"Pequena","Medium":"Médio","Large":"Grande"},"nl-NL":{"h:mm a/[translation hint:momentjs time: short]":"HH:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd D MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd D MMMM","NOW":"NU","Timeline":"Tijdlijn","Column":"Kolom","List":"Lijst","Search":"Zoeken","No Calendar Entries":"Geen agenda-items","Remove all Filters":"Alle filters verwijderen","Cancel":"Annuleren","Apply":"Toepassen","Today":"Vandaag","This Week":"Deze week","Next Week":"Volgende week","View":"Weergeven","at/[translation hint:date and time delimiter]":"om","Settings":"Instellingen","Sort by":"Sorteren op","Start date":"Begindatum","End date":"Einddatum","Group by":"Groeperen op","Timeline and Column only":"Alleen tijdlijn en kolom","None":"Geen","Stack cards":"Kaarten stapelen","Card size":"Kaartgrootte","Small":"Klein","Medium":"Normaal","Large":"Groot"},"da-DK":{"h:mm a/[translation hint:momentjs time: short]":"H:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd, D MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd, D MMMM","NOW":"NU","Timeline":"Tidslinje","Column":"Kolonne","List":"Liste","Search":"Søg","No Calendar Entries":"Ingen notater i kalenderen","Remove all Filters":"Fjern alle filtre","Cancel":"Annuller","Apply":"Anvend","Today":"I dag","This Week":"Denne uge","Next Week":"Næste uge","View":"Vis","at/[translation hint:date and time delimiter]":"ved","Settings":"Indstillinger","Sort by":"Sorter efter","Start date":"Startdato","End date":"Slutdato","Group by":"Gruppér efter","Timeline and Column only":"Kun tidslinje og kolonne","None":"Ingen","Stack cards":"Saml kort","Card size":"Kortstørrelse","Small":"Lille","Medium":"Medium","Large":"Stor"},"fi-FI":{"h:mm a/[translation hint:momentjs time: short]":"H:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D. MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D. MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd, D. MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd, D. MMMM","NOW":"NYT","Timeline":"Aikajana","Column":"Sarake","List":"Luettelo","Search":"Hae","No Calendar Entries":"Kalenterimerkintöjä ei ole.","Remove all Filters":"Poista kaikki suodattimet","Cancel":"Peruuta","Apply":"Käytä","Today":"Tänään","This Week":"Tämä viikko","Next Week":"Ensi viikko","View":"Näytä","at/[translation hint:date and time delimiter]":"klo","Settings":"Asetukset","Sort by":"Lajitteluperuste","Start date":"Alkamispäivä","End date":"Päättymispäivä","Group by":"Ryhmittelyperuste","Timeline and Column only":"Vain aikajana ja sarake","None":"Ei mitään","Stack cards":"Pinoa kortit","Card size":"Kortin koko","Small":"Pieni","Medium":"Normaali","Large":"Suuri"},"nb-NO":{"h:mm a/[translation hint:momentjs time: short]":"H:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D. MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D. MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd, D. MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd, D. MMMM","NOW":"NÅ","Timeline":"Tidslinje","Column":"Kolonne","List":"Liste","Search":"Søk","No Calendar Entries":"Ingen oppføringer i kalenderen","Remove all Filters":"Fjern alle filtre","Cancel":"Avbryt","Apply":"Bruk","Today":"I dag","This Week":"Denne uken","Next Week":"Neste uke","View":"Vis","at/[translation hint:date and time delimiter]":"kl.","Settings":"Innstillinger","Sort by":"Sorter etter","Start date":"Startdato","End date":"Sluttdato","Group by":"Grupper etter","Timeline and Column only":"Bare tidslinje og kolonne","None":"Ingen","Stack cards":"Stable kort","Card size":"Kortstørrelse","Small":"Liten","Medium":"Middels","Large":"Stor"},"sv-SE":{"h:mm a/[translation hint:momentjs time: short]":"H:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd, D MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd, D MMMM","NOW":"NU","Timeline":"Tidslinje","Column":"Kolumn","List":"Lista","Search":"Sökning","No Calendar Entries":"Inga kalenderuppgifter","Remove all Filters":"Ta bort alla filter","Cancel":"Avbryt","Apply":"Använd","Today":"Idag","This Week":"Denna vecka","Next Week":"Nästa vecka","View":"Visa","at/[translation hint:date and time delimiter]":"at","Settings":"Inställningar","Sort by":"Sortera efter","Start date":"Startdatum","End date":"Slutdatum","Group by":"Grupper efter","Timeline and Column only":"Endast tidslinje och kolumn","None":"Ingen","Stack cards":"Stackkort","Card size":"Kortstorlek","Small":"Liten","Medium":"Mellan","Large":"Stor"},"cs-CZ":{"h:mm a/[translation hint:momentjs time: short]":"H:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D. MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D. MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd, D. MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd, D. MMMM","NOW":"TEĎ","Timeline":"Časová osa","Column":"Sloupec","List":"Seznam","Search":"Hledání","No Calendar Entries":"Nebyly nalezeny žádné položky kalendáře","Remove all Filters":"Odebrat všechny filtry","Cancel":"Zrušit","Apply":"Použít","Today":"Dnes","This Week":"Tento týden","Next Week":"Příští týden","View":"Zobrazit","at/[translation hint:date and time delimiter]":"v","Settings":"Nastavení","Sort by":"Třídit podle","Start date":"Počáteční datum","End date":"Konečné datum","Group by":"Seskupit podle","Timeline and Column only":"Časová osa a pouze sloupec","None":"Žádný","Stack cards":"Seskupit karty","Card size":"Velikost karty","Small":"Malé","Medium":"Střední","Large":"Velké"},"pl-PL":{"h:mm a/[translation hint:momentjs time: short]":"H:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd, D MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd,  D MMMM","NOW":"TERAZ","Timeline":"Oś czasu","Column":"Kolumna","List":"Lista","Search":"Szukaj","No Calendar Entries":"Brak wpisów kalendarza","Remove all Filters":"Usuń wszystkie filtry","Cancel":"Anuluj","Apply":"Zastosuj","Today":"Dzisiaj","This Week":"Ten tydzień","Next Week":"Następny tydzień","View":"Widok","at/[translation hint:date and time delimiter]":"o","Settings":"Ustawienia","Sort by":"Sortuj według","Start date":"Data początkowa","End date":"Data końcowa","Group by":"Grupuj według","Timeline and Column only":"Tylko Oś czasu i Kolumna","None":"Brak","Stack cards":"Zgrupuj karty","Card size":"Rozmiar karty","Small":"Mały","Medium":"Średnie","Large":"Duży"},"ru-RU":{"h:mm a/[translation hint:momentjs time: short]":"H:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd, D MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd, D MMMM","NOW":"СЕЙЧАС","Timeline":"Таймлайн","Column":"Столбец","List":"Список","Search":"Поиск","No Calendar Entries":"Нет записей календаря","Remove all Filters":"Удалить все фильтры","Cancel":"Отмена","Apply":"Применить","Today":"Сегодня","This Week":"На этой неделе","Next Week":"На следующей неделе","View":"Просмотр","at/[translation hint:date and time delimiter]":"в","Settings":"Настройки","Sort by":"Сортировать по","Start date":"Дата начала","End date":"Дата окончания","Group by":"Группировать по","Timeline and Column only":"Только таймлайн и столбец","None":"Нет","Stack cards":"Сложить карты в стопку","Card size":"Размер карточки","Small":"Маленький","Medium":"Средний","Large":"Большой"},"tr-TR":{"h:mm a/[translation hint:momentjs time: short]":"H:mm","MMMM, D YYYY/[translation hint:momentjs date: long]":"D MMMM YYYY","MMM D/[translation hint:momentjs date: medium without year]":"D MMM","ddd, MMM D/[translation hint:momentjs date: medium without year]":"ddd, D MMM","dddd, MMMM D/[translation hint:momentjs date: full without year]":"dddd, D MMMM","NOW":"ŞİMDİ","Timeline":"Zaman Çizelgesi","Column":"Sütun","List":"Liste","Search":"Ara","No Calendar Entries":"Takvim Girişi Yok","Remove all Filters":"Tüm Filtreleri kaldır","Cancel":"İptal","Apply":"Uygula","Today":"Bugün","This Week":"Bu Hafta","Next Week":"Gelecek hafta","View":"Görünüm","at/[translation hint:date and time delimiter]":"Konum","Settings":"Ayarlar","Sort by":"Sıralama ölçütü","Start date":"Başlangıç tarihi","End date":"Bitiş tarihi","Group by":"Gruplandırma ölçütü","Timeline and Column only":"Yalnızca Zaman Çizelgesi ve Sütun","None":"Yok","Stack cards":"Yığın kartları","Card size":"Kart boyutu","Small":"Küçük","Medium":"Orta","Large":"Büyük"}};
window["Coral"] = window["Coral"] || {};
window["Coral"]["templates"] = window["Coral"]["templates"] || {};
window["Coral"]["templates"]["Aeon"] = window["Coral"]["templates"]["Aeon"] || {};
window["Coral"]["templates"]["Aeon"]["agenda"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " aeon-Header";
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " aeon-Dates";
  var el3 = document.createTextNode("\n    ");
  el2.appendChild(el3);
  var el4 = this["startdatedisplay"] = document.createElement("aeon-daterangepicker");
  el4.setAttribute("handle", "startdatedisplay");
  el4.setAttribute("popover", "aeon-datepopover");
  el4.id = "dateRangePicker1";
  el4.className += " aeon-DateRangePicker--start";
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n    ");
  el2.appendChild(el5);
  var el6 = this["enddatedisplay"] = document.createElement("aeon-daterangepicker");
  el6.setAttribute("handle", "enddatedisplay");
  el6.setAttribute("popover", "aeon-datepopover");
  el6.id = "dateRangePicker2";
  el6.className += " aeon-DateRangePicker--end";
  el2.appendChild(el6);
  var el7 = document.createTextNode("\n  ");
  el2.appendChild(el7);
  el0.appendChild(el2);
  var el8 = document.createTextNode("\n  ");
  el0.appendChild(el8);
  var el9 = document.createElement("div");
  el9.className += " aeon-NavButtons";
  var el10 = document.createTextNode("\n    ");
  el9.appendChild(el10);
  var el11 = this["timeline"] = document.createElement("aeon-pane-button");
  el11.className += " aeon-ModeButton";
  el11.setAttribute("group", "full-exclusion");
  el11.setAttribute("pane", "aeon-content");
  el11.setAttribute("handle", "timeline");
  el11.textContent = Coral["i18n"]["get"]('Timeline');
  el9.appendChild(el11);
  var el12 = document.createTextNode("\n    ");
  el9.appendChild(el12);
  var el13 = this["column"] = document.createElement("aeon-pane-button");
  el13.className += " aeon-ModeButton";
  el13.setAttribute("group", "full-exclusion");
  el13.setAttribute("pane", "aeon-content");
  el13.setAttribute("handle", "column");
  el13.textContent = Coral["i18n"]["get"]('Column');
  el9.appendChild(el13);
  var el14 = document.createTextNode("\n    ");
  el9.appendChild(el14);
  var el15 = this["list"] = document.createElement("aeon-pane-button");
  el15.className += " aeon-ModeButton";
  el15.setAttribute("group", "full-exclusion");
  el15.setAttribute("pane", "aeon-content");
  el15.setAttribute("handle", "list");
  el15.textContent = Coral["i18n"]["get"]('List');
  el9.appendChild(el15);
  var el16 = document.createTextNode("\n  ");
  el9.appendChild(el16);
  el0.appendChild(el9);
  var el17 = document.createTextNode("\n  ");
  el0.appendChild(el17);
  var el18 = this["headeractions"] = document.createElement("div");
  el18.setAttribute("handle", "headeractions");
  el18.className += " aeon-Actions";
  var el19 = document.createTextNode("\n    ");
  el18.appendChild(el19);
  var el20 = this["filterbutton"] = document.createElement("aeon-pane-button");
  el20.setAttribute("handle", "filterbutton");
  el20.className += " aeon-Action aeon-Action--filter";
  el20.setAttribute("group", "full-exclusion");
  el20.setAttribute("pane", "aeon-userfilters");
  var el21 = document.createElement("coral-icon");
  el21.setAttribute("icon", "filter");
  el21.setAttribute("size", "XS");
  el20.appendChild(el21);
  el18.appendChild(el20);
  var el22 = document.createTextNode("\n    ");
  el18.appendChild(el22);
  var el23 = this["searchbutton"] = document.createElement("aeon-pane-button");
  el23.setAttribute("handle", "searchbutton");
  el23.className += " aeon-Action";
  el23.setAttribute("group", "full-exclusion");
  el23.setAttribute("pane", "[handle='searchpane']");
  el23.setAttribute("toggleable", "true");
  var el24 = document.createElement("coral-icon");
  el24.setAttribute("icon", "search");
  el24.setAttribute("size", "XS");
  el23.appendChild(el24);
  el18.appendChild(el23);
  var el25 = document.createTextNode("\n    ");
  el18.appendChild(el25);
  var el26 = this["settingbutton"] = document.createElement("aeon-pane-button");
  el26.setAttribute("handle", "settingbutton");
  el26.className += " aeon-Action";
  el26.setAttribute("group", "full-exclusion");
  el26.setAttribute("pane", "[handle='settingspane']");
  var el27 = document.createElement("coral-icon");
  el27.setAttribute("icon", "gear");
  el27.setAttribute("size", "XS");
  el26.appendChild(el27);
  el18.appendChild(el26);
  var el28 = document.createTextNode("\n    ");
  el18.appendChild(el28);
  var el29 = this["exitbutton"] = document.createElement("aeon-pane-button");
  el29.setAttribute("handle", "exitbutton");
  el29.className += " aeon-Action";
  var el30 = document.createElement("coral-icon");
  el30.setAttribute("icon", "close");
  el30.setAttribute("size", "XS");
  el29.appendChild(el30);
  el18.appendChild(el29);
  var el31 = document.createTextNode("\n  ");
  el18.appendChild(el31);
  el0.appendChild(el18);
  var el32 = document.createTextNode("\n");
  el0.appendChild(el32);
  frag.appendChild(el0);
  var el33 = document.createTextNode("\n");
  frag.appendChild(el33);
  var el34 = this["dateselector"] = document.createElement("aeon-dateselector");
  el34.setAttribute("namespace", "date");
  el34.setAttribute("handle", "dateselector");
  frag.appendChild(el34);
  var el35 = document.createTextNode("\n");
  frag.appendChild(el35);
  var el36 = this["searchpane"] = document.createElement("aeon-searchpane");
  el36.setAttribute("handle", "searchpane");
  var el37 = document.createTextNode("\n  ");
  el36.appendChild(el37);
  var el38 = this["searchbox"] = document.createElement("input","coral-textfield");
  el38.setAttribute("type", "text");
  el38.className += " aeon-SearchBox";
  el38.setAttribute("is", "coral-textfield");
  el38.setAttribute("handle", "searchbox");
  el38.setAttribute("placeholder", Coral["i18n"]["get"]('Search'));
  el36.appendChild(el38);
  var el39 = document.createTextNode("\n");
  el36.appendChild(el39);
  frag.appendChild(el36);
  var el40 = document.createTextNode("\n");
  frag.appendChild(el40);
  var el41 = this["settingspane"] = document.createElement("aeon-settings");
  el41.setAttribute("namespace", "settings");
  el41.setAttribute("handle", "settingspane");
  frag.appendChild(el41);
  var el42 = document.createTextNode("\n");
  frag.appendChild(el42);
  var el43 = this["contentpane"] = document.createElement("aeon-content");
  el43.setAttribute("handle", "contentpane");
  var el44 = document.createTextNode("\n  ");
  el43.appendChild(el44);
  var el45 = this["dateheader"] = document.createElement("div");
  el45.className += " aeon-DateHeader";
  el45.setAttribute("handle", "dateheader");
  el43.appendChild(el45);
  var el46 = document.createTextNode("\n  ");
  el43.appendChild(el46);
  var el47 = this["content"] = document.createElement("aeon-displaycontent");
  el47.setAttribute("handle", "content");
  el43.appendChild(el47);
  var el48 = document.createTextNode("\n  ");
  el43.appendChild(el48);
  var el49 = this["placeholder"] = document.createElement("div");
  el49.className += " aeon-Placeholder";
  el49.setAttribute("handle", "placeholder");
  var el50 = document.createTextNode("\n    ");
  el49.appendChild(el50);
  var el51 = document.createElement("div");
  el51.className += " aeon-NoEntries";
  var el52 = document.createTextNode("\n      ");
  el51.appendChild(el52);
  var el53 = document.createElement("p");
  el53.textContent = Coral["i18n"]["get"]('No Calendar Entries');
  el51.appendChild(el53);
  var el54 = document.createTextNode("\n      ");
  el51.appendChild(el54);
  var el55 = this["clearfilters"] = document.createElement("a");
  el55.className += " aeon-RemoveFilters coral-Link";
  el55.setAttribute("handle", "clearfilters");
  el55.textContent = Coral["i18n"]["get"]('Remove all Filters');
  el51.appendChild(el55);
  var el56 = document.createTextNode("\n    ");
  el51.appendChild(el56);
  el49.appendChild(el51);
  var el57 = document.createTextNode("\n  ");
  el49.appendChild(el57);
  el43.appendChild(el49);
  var el58 = document.createTextNode("\n  ");
  el43.appendChild(el58);
  var el59 = this["coralwait"] = document.createElement("coral-wait");
  el59.className += " aeon-Wait";
  el59.setAttribute("handle", "coralwait");
  el59.setAttribute("centered", "");
  el43.appendChild(el59);
  var el60 = document.createTextNode("\n");
  el43.appendChild(el60);
  frag.appendChild(el43);
  var el61 = document.createTextNode("\n\n");
  frag.appendChild(el61);
  var el62 = this["datepopover"] = document.createElement("aeon-datepopover");
  el62.setAttribute("handle", "datepopover");
  el62.setAttribute("alignmy", "left top");
  el62.setAttribute("alignat", "left bottom");
  el62.setAttribute("offset", "11");
  frag.appendChild(el62);
  var el63 = document.createTextNode("\n");
  frag.appendChild(el63);
  return frag;
});

window["Coral"]["templates"]["Aeon"]["calendar"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["input"] = document.createElement("input");
  el0.setAttribute("handle", "input");
  el0.setAttribute("type", "hidden");
  el0.setAttribute("name", "");
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " aeon-Calendar-calendarHeader";
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = this["heading"] = document.createElement("div");
  el4.setAttribute("handle", "heading");
  el4.className += " coral-Heading coral-Heading--2";
  el4.id = Coral["commons"]["getUID"]();
  el4.setAttribute("role", "heading");
  el4.setAttribute("aria-live", "assertive");
  el4.setAttribute("aria-atomic", "true");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n  ");
  el2.appendChild(el5);
  var el6 = this["prev"] = document.createElement("button","coral-button");
  el6.setAttribute("type", "button");
  el6.setAttribute("handle", "prev");
  el6.className += " aeon-Calendar-prevMonth";
  el6.setAttribute("is", "coral-button");
  el6.setAttribute("variant", "minimal");
  el6.setAttribute("icon", "chevronLeft");
  el6.setAttribute("iconsize", "XS");
  el6.setAttribute("aria-label", Coral["i18n"]["get"]('Previous'));
  el6.setAttribute("title", Coral["i18n"]["get"]('Previous'));
  el2.appendChild(el6);
  var el7 = document.createTextNode("\n  ");
  el2.appendChild(el7);
  var el8 = this["next"] = document.createElement("button","coral-button");
  el8.setAttribute("type", "button");
  el8.setAttribute("handle", "next");
  el8.className += " aeon-Calendar-nextMonth";
  el8.setAttribute("is", "coral-button");
  el8.setAttribute("variant", "minimal");
  el8.setAttribute("icon", "chevronRight");
  el8.setAttribute("iconsize", "XS");
  el8.setAttribute("aria-label", Coral["i18n"]["get"]('Next'));
  el8.setAttribute("title", Coral["i18n"]["get"]('Next'));
  el2.appendChild(el8);
  var el9 = document.createTextNode("\n");
  el2.appendChild(el9);
  frag.appendChild(el2);
  var el10 = document.createTextNode("\n");
  frag.appendChild(el10);
  var el11 = this["body"] = document.createElement("div");
  el11.className += " aeon-Calendar-calendarBody";
  el11.setAttribute("handle", "body");
  el11.setAttribute("role", "grid");
  el11.setAttribute("tabindex", "0");
  el11.setAttribute("aria-readonly", "true");
  frag.appendChild(el11);
  return frag;
});

window["Coral"]["templates"]["Aeon"]["container"] = (function anonymous(data_0
/*``*/) {
  var data = data_0;
  var el0 = this["container"] = document.createElement("div");
  el0.className += " aeon-DatePicker-calendarSlidingContainer";
  el0.setAttribute("handle", "container");
  el0.setAttribute("style", "width: "+data_0["width"]+"px; height: "+data_0["height"]+"px;");
  return el0;
});

window["Coral"]["templates"]["Aeon"]["datepopover"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("aeon-datepopover-header");
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = document.createElement("aeon-datepopover-content");
  var el3 = document.createTextNode("\n    ");
  el2.appendChild(el3);
  var el4 = this["pointer"] = document.createElement("div");
  el4.className += " aeon-DatePopover-pointer";
  el4.setAttribute("handle", "pointer");
  var el5 = document.createTextNode("\n        ");
  el4.appendChild(el5);
  var el6 = document.createElement("div");
  el6.className += " inner-triangle";
  el4.appendChild(el6);
  var el7 = document.createTextNode("\n    ");
  el4.appendChild(el7);
  el2.appendChild(el4);
  var el8 = document.createTextNode("\n    ");
  el2.appendChild(el8);
  var el9 = document.createElement("div");
  el9.className += " aeon-DatePopover-container";
  var el10 = document.createTextNode("\n        ");
  el9.appendChild(el10);
  var el11 = document.createElement("div");
  el11.className += " aeon-DateSelector-calendars";
  var el12 = document.createTextNode("\n            ");
  el11.appendChild(el12);
  var el13 = this["dateselector1"] = document.createElement("aeon-calendar");
  el13.setAttribute("filter", "start");
  el13.setAttribute("handle", "dateselector1");
  el13.setAttribute("disableRightPagination", "true");
  el13.setAttribute("leftPaginationOffset", "1");
  el13.setAttribute("rightPaginationOffset", "1");
  el11.appendChild(el13);
  var el14 = document.createTextNode("\n            ");
  el11.appendChild(el14);
  var el15 = this["dateselector2"] = document.createElement("aeon-calendar");
  el15.setAttribute("filter", "end");
  el15.setAttribute("handle", "dateselector2");
  el15.setAttribute("disableLeftPagination", "true");
  el15.setAttribute("leftPaginationOffset", "1");
  el15.setAttribute("rightPaginationOffset", "1");
  el11.appendChild(el15);
  var el16 = document.createTextNode("\n            ");
  el11.appendChild(el16);
  var el17 = document.createElement("div");
  el17.className += " aeon-DateSelector-footer";
  var el18 = document.createTextNode("\n                ");
  el17.appendChild(el18);
  var el19 = this["reset"] = document.createElement("button","coral-button");
  el19.setAttribute("is", "coral-button");
  el19.setAttribute("variant", "quiet");
  el19.setAttribute("handle", "reset");
  el19.textContent = Coral["i18n"]["get"]('Cancel');
  el17.appendChild(el19);
  var el20 = document.createTextNode("\n                ");
  el17.appendChild(el20);
  var el21 = this["apply"] = document.createElement("button","coral-button");
  el21.setAttribute("is", "coral-button");
  el21.setAttribute("variant", "primary");
  el21.setAttribute("handle", "apply");
  el21.textContent = Coral["i18n"]["get"]('Apply');
  el17.appendChild(el21);
  var el22 = document.createTextNode("\n            ");
  el17.appendChild(el22);
  el11.appendChild(el17);
  var el23 = document.createTextNode("\n        ");
  el11.appendChild(el23);
  el9.appendChild(el11);
  var el24 = document.createTextNode("\n        ");
  el9.appendChild(el24);
  var el25 = document.createElement("div");
  el25.className += " aeon-DateSelector-buttons";
  var el26 = document.createTextNode("\n            ");
  el25.appendChild(el26);
  var el27 = this["today"] = document.createElement("button","coral-button");
  el27.setAttribute("is", "coral-button");
  el27.className += " aeon-DateSelector-button";
  el27.setAttribute("handle", "today");
  el27.textContent = Coral["i18n"]["get"]('Today');
  el25.appendChild(el27);
  var el28 = document.createTextNode("\n            ");
  el25.appendChild(el28);
  var el29 = this["thisweek"] = document.createElement("button","coral-button");
  el29.setAttribute("is", "coral-button");
  el29.className += " aeon-DateSelector-button";
  el29.setAttribute("handle", "thisweek");
  el29.textContent = Coral["i18n"]["get"]('This Week');
  el25.appendChild(el29);
  var el30 = document.createTextNode("\n            ");
  el25.appendChild(el30);
  var el31 = this["nextweek"] = document.createElement("button","coral-button");
  el31.setAttribute("is", "coral-button");
  el31.className += " aeon-DateSelector-button";
  el31.setAttribute("handle", "nextweek");
  el31.textContent = Coral["i18n"]["get"]('Next Week');
  el25.appendChild(el31);
  var el32 = document.createTextNode("\n        ");
  el25.appendChild(el32);
  el9.appendChild(el25);
  var el33 = document.createTextNode("\n    ");
  el9.appendChild(el33);
  el2.appendChild(el9);
  var el34 = document.createTextNode("\n");
  el2.appendChild(el34);
  frag.appendChild(el2);
  var el35 = document.createTextNode("\n");
  frag.appendChild(el35);
  return frag;
});

window["Coral"]["templates"]["Aeon"]["daterangepicker"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("span");
  el0.className += " aeon-DateRangePicker-item";
  var el1 = document.createElement("coral-icon");
  el1.setAttribute("icon", "calendar");
  el1.setAttribute("size", "S");
  el0.appendChild(el1);
  frag.appendChild(el0);
  var el2 = document.createTextNode("\n");
  frag.appendChild(el2);
  var el3 = document.createElement("span");
  el3.className += " aeon-DateRangePicker-item aeon-DateRangePicker-inputWrapper is-hidden";
  var el4 = document.createTextNode("\n  ");
  el3.appendChild(el4);
  var el5 = this["daterangeinput"] = document.createElement("input","coral-textfield");
  el5.setAttribute("is", "coral-textfield");
  el5.setAttribute("type", "text");
  el5.className += " aeon-DateRangePicker-input";
  el5.setAttribute("handle", "daterangeinput");
  el5.setAttribute("disabled", "");
  el3.appendChild(el5);
  var el6 = document.createTextNode("\n");
  el3.appendChild(el6);
  frag.appendChild(el3);
  var el7 = document.createTextNode("\n");
  frag.appendChild(el7);
  var el8 = this["daterangedisplay"] = document.createElement("span");
  el8.className += " aeon-DateRangePicker-item aeon-DateRangePicker-display";
  el8.setAttribute("handle", "daterangedisplay");
  frag.appendChild(el8);
  var el9 = document.createTextNode("\n");
  frag.appendChild(el9);
  return frag;
});

window["Coral"]["templates"]["Aeon"]["dateselector"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " aeon-DateSelector-content";
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " aeon-DateSelector-calendars";
  var el3 = document.createTextNode("\n    ");
  el2.appendChild(el3);
  var el4 = this["startdateselector"] = document.createElement("aeon-calendar");
  el4.setAttribute("filter", "start");
  el4.setAttribute("handle", "startdateselector");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n    ");
  el2.appendChild(el5);
  var el6 = this["enddateselector"] = document.createElement("aeon-calendar");
  el6.setAttribute("filter", "end");
  el6.setAttribute("handle", "enddateselector");
  el2.appendChild(el6);
  var el7 = document.createTextNode("\n    ");
  el2.appendChild(el7);
  var el8 = document.createElement("div");
  el8.className += " aeon-DateSelector-footer";
  var el9 = document.createTextNode("\n      ");
  el8.appendChild(el9);
  var el10 = this["reset"] = document.createElement("button","coral-button");
  el10.setAttribute("is", "coral-button");
  el10.setAttribute("variant", "quiet");
  el10.setAttribute("handle", "reset");
  el10.textContent = Coral["i18n"]["get"]('Cancel');
  el8.appendChild(el10);
  var el11 = document.createTextNode("\n      ");
  el8.appendChild(el11);
  var el12 = this["apply"] = document.createElement("button","coral-button");
  el12.setAttribute("is", "coral-button");
  el12.setAttribute("variant", "primary");
  el12.setAttribute("handle", "apply");
  el12.textContent = Coral["i18n"]["get"]('Apply');
  el8.appendChild(el12);
  var el13 = document.createTextNode("\n    ");
  el8.appendChild(el13);
  el2.appendChild(el8);
  var el14 = document.createTextNode("\n  ");
  el2.appendChild(el14);
  el0.appendChild(el2);
  var el15 = document.createTextNode("\n  ");
  el0.appendChild(el15);
  var el16 = document.createElement("div");
  el16.className += " aeon-DateSelector-buttons";
  var el17 = document.createTextNode("\n    ");
  el16.appendChild(el17);
  var el18 = this["today"] = document.createElement("button","coral-button");
  el18.setAttribute("is", "coral-button");
  el18.className += " aeon-DateSelector-button";
  el18.setAttribute("handle", "today");
  el18.textContent = Coral["i18n"]["get"]('Today');
  el16.appendChild(el18);
  var el19 = document.createTextNode("\n    ");
  el16.appendChild(el19);
  var el20 = this["thisweek"] = document.createElement("button","coral-button");
  el20.setAttribute("is", "coral-button");
  el20.className += " aeon-DateSelector-button";
  el20.setAttribute("handle", "thisweek");
  el20.textContent = Coral["i18n"]["get"]('This Week');
  el16.appendChild(el20);
  var el21 = document.createTextNode("\n    ");
  el16.appendChild(el21);
  var el22 = this["nextweek"] = document.createElement("button","coral-button");
  el22.setAttribute("is", "coral-button");
  el22.className += " aeon-DateSelector-button";
  el22.setAttribute("handle", "nextweek");
  el22.textContent = Coral["i18n"]["get"]('Next Week');
  el16.appendChild(el22);
  var el23 = document.createTextNode("\n  ");
  el16.appendChild(el23);
  el0.appendChild(el16);
  var el24 = document.createTextNode("\n");
  el0.appendChild(el24);
  frag.appendChild(el0);
  var el25 = document.createTextNode("\n");
  frag.appendChild(el25);
  return frag;
});

window["Coral"]["templates"]["Aeon"]["details"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " aeon-Details-leftHeader";
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = this["status"] = document.createElement("aeon-details-status");
  el2.setAttribute("handle", "status");
  el0.appendChild(el2);
  var el3 = document.createTextNode("\n  ");
  el0.appendChild(el3);
  var el4 = this["title"] = document.createElement("aeon-details-title");
  el4.setAttribute("handle", "title");
  el0.appendChild(el4);
  var el5 = document.createTextNode("\n");
  el0.appendChild(el5);
  frag.appendChild(el0);
  var el6 = document.createTextNode("\n");
  frag.appendChild(el6);
  var el7 = document.createElement("div");
  el7.className += " aeon-Details-rightHeader";
  var el8 = document.createTextNode("\n  ");
  el7.appendChild(el8);
  var el9 = this["viewbutton"] = document.createElement("a","coral-anchorbutton");
  el9.className += " aeon-Details-viewButton";
  el9.setAttribute("is", "coral-anchorbutton");
  el9.setAttribute("variant", "primary");
  el9.setAttribute("handle", "viewbutton");
  el9.textContent = Coral["i18n"]["get"]('View');
  el7.appendChild(el9);
  var el10 = document.createTextNode("\n");
  el7.appendChild(el10);
  frag.appendChild(el7);
  var el11 = document.createTextNode("\n");
  frag.appendChild(el11);
  var el12 = this["media"] = document.createElement("img");
  el12.className += " aeon-Details-media";
  el12.setAttribute("style", "display: none;");
  el12.setAttribute("handle", "media");
  frag.appendChild(el12);
  var el13 = document.createTextNode("\n");
  frag.appendChild(el13);
  var el14 = this["date"] = document.createElement("aeon-details-date");
  el14.setAttribute("handle", "date");
  var el15 = document.createTextNode("\n  ");
  el14.appendChild(el15);
  var el16 = this["datelabel"] = document.createElement("div");
  el16.className += " aeon-Details-dateLabel";
  el16.setAttribute("handle", "datelabel");
  el14.appendChild(el16);
  var el17 = document.createTextNode("\n  ");
  el14.appendChild(el17);
  var el18 = this["datetext"] = document.createElement("div");
  el18.className += " aeon-Details-dateText";
  el18.setAttribute("handle", "datetext");
  el14.appendChild(el18);
  var el19 = document.createTextNode("\n  ");
  el14.appendChild(el19);
  var el20 = document.createElement("span");
  el20.className += " aeon-Details-dateDelimiter";
  el20.textContent = " "+Coral["i18n"]["get"]('at','date and time delimiter')+" ";
  el14.appendChild(el20);
  var el21 = document.createTextNode("\n  ");
  el14.appendChild(el21);
  var el22 = this["time"] = document.createElement("div");
  el22.className += " aeon-Details-time";
  el22.setAttribute("handle", "time");
  el14.appendChild(el22);
  var el23 = document.createTextNode("\n");
  el14.appendChild(el23);
  frag.appendChild(el14);
  var el24 = document.createTextNode("\n");
  frag.appendChild(el24);
  var el25 = this["description"] = document.createElement("aeon-details-description");
  el25.setAttribute("handle", "description");
  frag.appendChild(el25);
  var el26 = document.createTextNode("\n");
  frag.appendChild(el26);
  var el27 = this["fields"] = document.createElement("aeon-details-fields");
  el27.setAttribute("handle", "fields");
  frag.appendChild(el27);
  var el28 = document.createTextNode("\n");
  frag.appendChild(el28);
  var el29 = this["actions"] = document.createElement("aeon-details-actions");
  el29.setAttribute("handle", "actions");
  frag.appendChild(el29);
  var el30 = document.createTextNode("\n");
  frag.appendChild(el30);
  return frag;
});

window["Coral"]["templates"]["Aeon"]["header"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["icon"] = document.createElement("coral-icon");
  el0.setAttribute("handle", "icon");
  el0.className += " aeon-DatePopover-typeIcon";
  el0.setAttribute("size", "S");
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = this["headerContent"] = document.createElement("div");
  el2.setAttribute("handle", "headerContent");
  el2.className += " aeon-DatePopover-title coral-Heading coral-Heading--2";
  el2.setAttribute("role", "heading");
  el2.setAttribute("aria-level", "2");
  frag.appendChild(el2);
  var el3 = document.createTextNode("\n");
  frag.appendChild(el3);
  var el4 = this["closeButton"] = document.createElement("button","coral-button");
  el4.setAttribute("handle", "closeButton");
  el4.className += " aeon-DatePopover-closeButton";
  el4.setAttribute("type", "button");
  el4.setAttribute("is", "coral-button");
  el4.setAttribute("variant", "minimal");
  el4.setAttribute("icon", "close");
  el4.setAttribute("iconsize", "XS");
  el4.setAttribute("title", Coral["i18n"]["get"]('Close'));
  el4.setAttribute("tabindex", "-1");
  el4.setAttribute("aeon-datepopover-close", "");
  frag.appendChild(el4);
  return frag;
});

window["Coral"]["templates"]["Aeon"]["navigator"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " Aeon-Navigator-buttons";
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = this["previous"] = document.createElement("button","coral-button");
  el2.setAttribute("is", "coral-button");
  el2.className += " aeon-Navigator-button-round";
  el2.setAttribute("handle", "previous");
  var el3 = document.createElement("coral-icon");
  el3.setAttribute("icon", "chevronLeft");
  el3.setAttribute("size", "XS");
  el2.appendChild(el3);
  el0.appendChild(el2);
  var el4 = document.createTextNode("\n  ");
  el0.appendChild(el4);
  var el5 = document.createElement("span");
  el0.appendChild(el5);
  var el6 = document.createTextNode("\n  ");
  el0.appendChild(el6);
  var el7 = this["next"] = document.createElement("button","coral-button");
  el7.setAttribute("is", "coral-button");
  el7.className += " aeon-Navigator-button-round";
  el7.setAttribute("handle", "next");
  var el8 = document.createElement("coral-icon");
  el8.setAttribute("icon", "chevronRight");
  el8.setAttribute("size", "XS");
  el7.appendChild(el8);
  el0.appendChild(el7);
  var el9 = document.createTextNode("\n");
  el0.appendChild(el9);
  frag.appendChild(el0);
  var el10 = document.createTextNode("\n");
  frag.appendChild(el10);
  return frag;
});

window["Coral"]["templates"]["Aeon"]["scrollbar"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = this["scrollhandle"] = document.createElement("div");
  el0.setAttribute("handle", "scrollhandle");
  el0.className += " aeon-ForcedScrollbarHandle";
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  return frag;
});

window["Coral"]["templates"]["Aeon"]["settings"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " aeon-Settings-heading";
  el0.textContent = Coral["i18n"]["get"]('Settings');
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " coral-Well";
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = document.createElement("coral-icon");
  el4.className += " aeon-Settings-sortIcon";
  el4.setAttribute("icon", "arrowUp");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n  ");
  el2.appendChild(el5);
  var el6 = document.createElement("div");
  el6.className += " aeon-Settings-header";
  el6.textContent = Coral["i18n"]["get"]('Sort by');
  el2.appendChild(el6);
  var el7 = document.createTextNode("\n  ");
  el2.appendChild(el7);
  var el8 = document.createElement("coral-select");
  el8.className += " aeon-Settings-select";
  el8.setAttribute("name", "sort");
  el8.setAttribute("disabled", "");
  var el9 = document.createTextNode("\n    ");
  el8.appendChild(el9);
  var el10 = document.createElement("coral-select-item");
  el10.textContent = "\n      "+Coral["i18n"]["get"]('Start date')+"\n    ";
  el8.appendChild(el10);
  var el11 = document.createTextNode("\n    ");
  el8.appendChild(el11);
  var el12 = document.createElement("coral-select-item");
  el12.textContent = "\n      "+Coral["i18n"]["get"]('End date')+"\n    ";
  el8.appendChild(el12);
  var el13 = document.createTextNode("\n  ");
  el8.appendChild(el13);
  el2.appendChild(el8);
  var el14 = document.createTextNode("\n");
  el2.appendChild(el14);
  frag.appendChild(el2);
  var el15 = document.createTextNode("\n");
  frag.appendChild(el15);
  var el16 = document.createElement("div");
  el16.className += " coral-Well";
  var el17 = document.createTextNode("\n  ");
  el16.appendChild(el17);
  var el18 = this["enablegroup"] = document.createElement("coral-checkbox");
  el18.setAttribute("handle", "enablegroup");
  el18.setAttribute("filter", "enablegroup");
  el18.setAttribute("value", "enabled");
  el16.appendChild(el18);
  var el19 = document.createTextNode("\n  ");
  el16.appendChild(el19);
  var el20 = document.createElement("div");
  el20.className += " aeon-Settings-header";
  var el21 = document.createTextNode(Coral["i18n"]["get"]('Group by')+"\n    ");
  el20.appendChild(el21);
  var el22 = document.createElement("span");
  el22.className += " aeon-Settings-label";
  el22.textContent = "("+Coral["i18n"]["get"]('Timeline and Column only')+")";
  el20.appendChild(el22);
  var el23 = document.createTextNode("\n  ");
  el20.appendChild(el23);
  el16.appendChild(el20);
  var el24 = document.createTextNode("\n  ");
  el16.appendChild(el24);
  var el25 = this["group"] = document.createElement("coral-select");
  el25.setAttribute("handle", "group");
  el25.setAttribute("filter", "group");
  el25.className += " aeon-Settings-select";
  el25.setAttribute("disabled", "");
  var el26 = document.createTextNode("\n    ");
  el25.appendChild(el26);
  var el27 = document.createElement("coral-select-item");
  el27.textContent = "\n      "+Coral["i18n"]["get"]('None')+"\n    ";
  el25.appendChild(el27);
  var el28 = document.createTextNode("\n  ");
  el25.appendChild(el28);
  el16.appendChild(el25);
  var el29 = document.createTextNode("\n");
  el16.appendChild(el29);
  frag.appendChild(el16);
  var el30 = document.createTextNode("\n");
  frag.appendChild(el30);
  var el31 = document.createElement("div");
  el31.className += " coral-Well";
  var el32 = document.createTextNode("\n  ");
  el31.appendChild(el32);
  var el33 = document.createElement("coral-checkbox");
  el33.setAttribute("disabled", "");
  el31.appendChild(el33);
  var el34 = document.createElement("div");
  el34.className += " aeon-Settings-header";
  el34.textContent = Coral["i18n"]["get"]('Stack cards');
  el31.appendChild(el34);
  var el35 = document.createTextNode("\n");
  el31.appendChild(el35);
  frag.appendChild(el31);
  var el36 = document.createTextNode("\n");
  frag.appendChild(el36);
  var el37 = document.createElement("div");
  el37.className += " coral-Well";
  var el38 = document.createTextNode("\n  ");
  el37.appendChild(el38);
  var el39 = document.createElement("div");
  el39.className += " aeon-Settings-header";
  el39.textContent = Coral["i18n"]["get"]('Card size');
  el37.appendChild(el39);
  var el40 = document.createTextNode("\n  ");
  el37.appendChild(el40);
  var el41 = document.createElement("div");
  el41.className += " aeon-Settings-sizeOptions";
  var el42 = document.createTextNode("\n    ");
  el41.appendChild(el42);
  var el43 = document.createElement("coral-radio");
  el43.setAttribute("name", "size");
  el43.setAttribute("value", "S");
  el43.setAttribute("filter", "size");
  var el44 = document.createTextNode("\n      ");
  el43.appendChild(el44);
  var el45 = document.createElement("coral-radio-label");
  el45.textContent = Coral["i18n"]["get"]('Small');
  el43.appendChild(el45);
  var el46 = document.createTextNode("\n    ");
  el43.appendChild(el46);
  el41.appendChild(el43);
  var el47 = document.createTextNode("\n    ");
  el41.appendChild(el47);
  var el48 = document.createElement("coral-radio");
  el48.setAttribute("name", "size");
  el48.setAttribute("value", "M");
  el48.setAttribute("filter", "size");
  var el49 = document.createTextNode("\n      ");
  el48.appendChild(el49);
  var el50 = document.createElement("coral-radio-label");
  el50.textContent = Coral["i18n"]["get"]('Medium');
  el48.appendChild(el50);
  var el51 = document.createTextNode("\n    ");
  el48.appendChild(el51);
  el41.appendChild(el48);
  var el52 = document.createTextNode("\n    ");
  el41.appendChild(el52);
  var el53 = document.createElement("coral-radio");
  el53.setAttribute("name", "size");
  el53.setAttribute("value", "L");
  el53.setAttribute("filter", "size");
  var el54 = document.createTextNode("\n      ");
  el53.appendChild(el54);
  var el55 = document.createElement("coral-radio-label");
  el55.textContent = Coral["i18n"]["get"]('Large');
  el53.appendChild(el55);
  var el56 = document.createTextNode("\n    ");
  el53.appendChild(el56);
  el41.appendChild(el53);
  var el57 = document.createTextNode("\n  ");
  el41.appendChild(el57);
  el37.appendChild(el41);
  var el58 = document.createTextNode("\n");
  el37.appendChild(el58);
  frag.appendChild(el37);
  var el59 = document.createTextNode("\n");
  frag.appendChild(el59);
  var el60 = document.createElement("div");
  el60.className += " aeon-Settings-buttons";
  var el61 = document.createTextNode("\n  ");
  el60.appendChild(el61);
  var el62 = this["reset"] = document.createElement("button","coral-button");
  el62.setAttribute("is", "coral-button");
  el62.setAttribute("variant", "quiet");
  el62.setAttribute("handle", "reset");
  el62.textContent = Coral["i18n"]["get"]('Cancel');
  el60.appendChild(el62);
  var el63 = document.createTextNode("\n  ");
  el60.appendChild(el63);
  var el64 = this["apply"] = document.createElement("button","coral-button");
  el64.setAttribute("is", "coral-button");
  el64.setAttribute("variant", "primary");
  el64.setAttribute("handle", "apply");
  el64.textContent = Coral["i18n"]["get"]('Apply');
  el60.appendChild(el64);
  var el65 = document.createTextNode("\n");
  el60.appendChild(el65);
  frag.appendChild(el60);
  var el66 = document.createTextNode("\n");
  frag.appendChild(el66);
  return frag;
});

window["Coral"]["templates"]["Aeon"]["table"] = (function anonymous(data_0
/*``*/) {
  var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
  var el0 = this["table"] = document.createElement("table");
  el0.setAttribute("handle", "table");
  el0.setAttribute("role", "presentation");
  var el1 = document.createTextNode("\n  ");
  el0.appendChild(el1);
  var el2 = document.createElement("thead");
  el2.setAttribute("role", "presentation");
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = document.createElement("tr");
  el4.setAttribute("role", "row");
  var el5 = document.createTextNode("\n    ");
  el4.appendChild(el5);
  var iterated_1 = data_0["dayNames"];
  for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
    var data_1 = data = iterated_1[i1];
    var el7 = document.createTextNode("\n      ");
    el4.appendChild(el7);
    var el8 = document.createElement("th");
    el8.setAttribute("role", "columnheader");
    el8.setAttribute("scope", "col");
    var el9 = document.createTextNode("\n        ");
    el8.appendChild(el9);
    var el10 = document.createElement("abbr");
    el10.className += " aeon-Calendar-dayOfWeek";
    el10.setAttribute("title", data_1["dayFullName"]);
    el10.textContent = data_1["dayAbbr"];
    el8.appendChild(el10);
    var el11 = document.createTextNode("\n      ");
    el8.appendChild(el11);
    el4.appendChild(el8);
    var el12 = document.createTextNode("\n    ");
    el4.appendChild(el12);
  }
  var el13 = document.createTextNode("\n  ");
  el4.appendChild(el13);
  el2.appendChild(el4);
  var el14 = document.createTextNode("\n  ");
  el2.appendChild(el14);
  el0.appendChild(el2);
  var el15 = document.createTextNode("\n  ");
  el0.appendChild(el15);
  var el16 = document.createElement("tbody");
  el16.setAttribute("role", "presentation");
  var el17 = document.createTextNode("\n  ");
  el16.appendChild(el17);
  var iterated_1 = data_0["weeks"];
  for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
    var data_1 = data = iterated_1[i1];
    var el19 = document.createTextNode("\n    ");
    el16.appendChild(el19);
    var el20 = document.createElement("tr");
    el20.setAttribute("role", "row");
    var el21 = document.createTextNode("\n      ");
    el20.appendChild(el21);
    var iterated_2 = data_1;
    for (var i2 = 0, ni2 = iterated_2.length; i2 < ni2; i2++) {
      var data_2 = data = iterated_2[i2];
      var el23 = document.createTextNode("\n        ");
      el20.appendChild(el23);
      data = data_2;
      
          var calendarTitle;
          var calendarDate = data.dateLabel + ', ' + data.formattedDate;
          if (data.isToday) {
          if (data.ariaSelected) {
          calendarTitle = Coral.i18n.get('Today, {0} selected', calendarDate, 'date');
          }
          else {
          calendarTitle = Coral.i18n.get('Today, {0}', calendarDate, 'date');
          }
          }
          else {
          if (data.ariaSelected) {
          calendarTitle = Coral.i18n.get('{0} selected', calendarDate, 'date');
          }
          else {
          calendarTitle = calendarTitle = calendarDate;
          }
          }
        
      data_2 = data;
      var el25 = document.createTextNode("\n        ");
      el20.appendChild(el25);
      var el26 = document.createElement("td");
      el26.setAttribute("role", "gridcell");
      el26.id = Coral["commons"]["getUID"]()+"-row"+i1+"-col"+i2;
      el26.className += " "+data_2["cssClass"];
      el26.setAttribute("aria-selected", data_2["ariaSelected"]);
      if (data_2["isDisabled"]) {
      el26.setAttribute("aria-disabled", "true");
      }
      if (data_2["ariaInvalid"]) {
      el26.setAttribute("aria-invalid", "true");
      }
      if (data_2["formattedDate"]) {
      el26.setAttribute("title", calendarTitle);
      }
      var el27 = document.createTextNode("\n          ");
      el26.appendChild(el27);
      if (data_2["dateAttr"]) {
        var el29 = document.createTextNode("\n            ");
        el26.appendChild(el29);
        var el30 = document.createElement("a");
        el30.setAttribute("role", "presentation");
        el30.className += " aeon-Calendar-date";
        el30.setAttribute("data-date", data_2["dateAttr"]);
        el30.textContent = data_2["dateText"];
        el26.appendChild(el30);
        var el31 = document.createTextNode("\n            ");
        el26.appendChild(el31);
      }
      else {
        var el32 = document.createTextNode("\n              ");
        el26.appendChild(el32);
        var el33 = document.createElement("span");
        el33.setAttribute("role", "presentation");
        el33.className += " aeon-Calendar-secondaryDate";
        el33.textContent = data_2["dateText"];
        el26.appendChild(el33);
        var el34 = document.createTextNode("\n          ");
        el26.appendChild(el34);
      }
      var el35 = document.createTextNode("\n        ");
      el26.appendChild(el35);
      el20.appendChild(el26);
      var el36 = document.createTextNode("\n      ");
      el20.appendChild(el36);
    }
    var el37 = document.createTextNode("\n    ");
    el20.appendChild(el37);
    el16.appendChild(el20);
    var el38 = document.createTextNode("\n  ");
    el16.appendChild(el38);
  }
  var el39 = document.createTextNode("\n  ");
  el16.appendChild(el39);
  el0.appendChild(el16);
  var el40 = document.createTextNode("\n  ");
  el0.appendChild(el40);
  var el41 = document.createElement("caption");
  el41.className += " u-coral-screenReaderOnly";
  el41.setAttribute("aria-live", "assertive");
  el41.setAttribute("aria-atomic", "true");
  el0.appendChild(el41);
  var el42 = document.createTextNode("\n");
  el0.appendChild(el42);
  return el0;
});

window["Coral"]["templates"]["Aeon"]["timelinelabel"] = (function anonymous(data_0
/*``*/) {
  var frag = document.createDocumentFragment();
  var data = data_0;
  var el0 = document.createElement("div");
  el0.className += " aeon-TimelineHeader-bar";
  frag.appendChild(el0);
  var el1 = document.createTextNode("\n");
  frag.appendChild(el1);
  var el2 = document.createElement("div");
  el2.className += " aeon-TimelineHeader-labelWrapper";
  var el3 = document.createTextNode("\n  ");
  el2.appendChild(el3);
  var el4 = this["label"] = document.createElement("div");
  el4.className += " aeon-TimelineHeader-label";
  el4.setAttribute("handle", "label");
  el2.appendChild(el4);
  var el5 = document.createTextNode("\n");
  el2.appendChild(el5);
  frag.appendChild(el2);
  var el6 = document.createTextNode("\n");
  frag.appendChild(el6);
  return frag;
});
/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';
  
  // Define Aeon namespace
  window.Aeon = window.Aeon || {};
  window.Aeon.mixin = window.Aeon.mixin || {};
}());
(function() {
  'use strict';

  var methods = {
    seedCache: function(entries, segmentCollections) {
      this._entryCache = {};

      if (!entries || entries.length === 0) {
        return;
      }

      var dayCaches = this._createDayCaches(entries);
      this._createNamedSegmentCaches(dayCaches, segmentCollections);
    },

    findCache: function(timestamp) {
      return this._entryCache && this._entryCache[timestamp];
    },

    _createDayCaches: function(entries) {
      var getStartOfDay = function(timestamp, plusDays) {
        var time = moment.unix(timestamp);
        if (plusDays) {
          time.add(plusDays, 'days');
        }

        return time.startOf('day').unix();
      };

      var startOfThisDay = getStartOfDay(entries[0].startingAt);
      var startOfNextDay = getStartOfDay(entries[0].startingAt, 1);
      for(var i = 0; i < entries.length; i += 1) {
        var entry = entries[i];
        if (entry.startingAt >= startOfNextDay) {
          startOfThisDay = getStartOfDay(entry.startingAt);
          startOfNextDay = getStartOfDay(entry.startingAt, 1);
        }
        this._entryCache[startOfThisDay] = this._entryCache[startOfThisDay] || [];
        this._entryCache[startOfThisDay].push(entry);
      }

      return $.extend({}, this._entryCache);
    },

    _createNamedSegmentCaches: function(dayCaches, segmentCollections) {
      var that = this;

      segmentCollections.each(function(name, segments) {
        segments.each(function(segment) {
          if (segment.name) {
            for (var day in dayCaches) {
              var cache = dayCaches[day];

              for (var i = 0; i < cache.length; i += 1) {
                var entry = cache[i];
                if (that._hasMatchingCriteria(entry, segment.criteria)) {
                  var key = day + '-' + segment.name;
                  that._entryCache[key] = that._entryCache[key] || [];
                  that._entryCache[key].push(entry);
                }
              }
            }
          }
        });
      });
    },

    _hasMatchingCriteria: function(entry, criteria) {
      return window.Aeon.CardAttribute.prototype._deepMatchCriteria(entry, criteria);
    }
  };

  window.Aeon.mixin.dayDelineatedEntryCache = function() {
    return function(prototype) {
      Coral.commons.augment(prototype, methods, function(objectMethod, mixinMethod) {
        return Coral.commons.callAll(mixinMethod, objectMethod);
      });
    };
  };
}());

(function() {
  'use strict';

  var methods = {
    collapse: function() {
      this._savedHeight = this.style.height;
      this.style.height = 0;
      this._stopResize();
      this._elements.draghandle.style.display = 'none';
    },

    expand: function() {
      this.style.height = this._savedHeight;
      this._stopResize();
      this._elements.draghandle.style.display = 'block';
    },

    _startResize: function() {
      this._isResizing = true;
    },

    _stopResize: function() {
      this._isResizing = false;
      this.trigger('aeon:resize:done', {});
    },

    _doResize: function(event) {
      if (this._isResizing) {
        var height = event.clientY - this.getBoundingClientRect().top;
        height = height < 0 ? 0 : height;
        this.style.height = height + 'px';

        event.preventDefault();
      }
    },

    _render: function() {
      this._elements.draghandle = document.createElement('div');
      this._elements.draghandle.classList.add('aeon-DragHandle');

      var icon = document.createElement('coral-icon');
      icon.set({
        icon: 'dragHandle'
      });

      this._elements.draghandle.appendChild(icon);

      this.appendChild(this._elements.draghandle);
    }
  };

  var events = {
    'mousedown .aeon-DragHandle': '_startResize',
    'global:mouseup': '_stopResize',
    'global:mousemove': '_doResize'
  };
  
  window.Aeon.mixin.isResizeable = function() {
    return function(prototype) {
      Coral.commons.augment(prototype, methods, function(objectMethod, mixinMethod) {
        return Coral.commons.callAll(mixinMethod, objectMethod);
      });

      prototype._events = Coral.commons.augment({}, prototype._events, events);
    };
  };
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  var FILTERS_TAG_NAME = 'aeon-userfilters';

  var AEON_SETTINGS_TAG_NAME = 'AEON-SETTINGS';
  var AEON_FILTERS_TAG_NAME = 'AEON-USERFILTERS';
  var AEON_DATESELECTOR_TAG_NAME = 'AEON-DATESELECTOR';
  var AEON_DATEPOPOVER_TAG_NAME = 'AEON-DATEPOPOVER';

  var DEFAULT_CARD_WIDTH = 180;

  var modes = {
    TIMELINE: 'timeline',
    LIST: 'list',
    COLUMN: 'column'
  };

  var defaultStatusOptions = {
    dateLabel: 'At',
    color: '#4b4b4b',
    icon: 'calendar'
  };

  var InvalidCardAttributeError = function(message) {
    this.name = 'InvalidCardAttributeError';
    this.message = message || 'CardAttribute could not be instantiated.';
    this.stack = (new Error()).stack;
  };

  var CardAttribute = function(criteria, options) {
    this._criteria = criteria;
    this._options = options;
  };

  CardAttribute.prototype.get = function() {
    return this._options;
  };

  CardAttribute.prototype.matchCriteria = function(criteria) {
    return this._deepMatchCriteria(criteria, this._criteria);
  };

  CardAttribute.prototype._deepMatchCriteria = function(candidate, criteria) {
    if (!candidate || !criteria) {
      return false;
    }

    for (var key in criteria) {
      if (Array.isArray(candidate[key]) && typeof criteria[key] === 'string') {
        var included = false;
        for(var idx = 0; idx < candidate[key].length; idx += 1) {
          if (candidate[key][idx] === criteria[key]) {
            included = true;
            break;
          }
        }

        if (!included) {
          return false;
        }
      } else if (typeof candidate[key] === 'object' && typeof criteria[key] === 'object') {
        if (!this._deepMatchCriteria(candidate[key], criteria[key])) {
          return false;
        }
      } else if (!candidate[key] || criteria[key] !== candidate[key]) {
        return false;
      }
    }
    return true;
  };

  CardAttribute.prototype.getPopulatedOptions = function(entry) {
    var populatedOptions = {};
    for (var i in this._options) {
      if (typeof this._options[i] === 'function') {
        populatedOptions[i] = this._options[i](entry);
      } else {
        populatedOptions[i] = this._options[i];
      }
    }

    return populatedOptions;
  };

  var CardStatus = function(status, options) {
    if (!(typeof status === 'string' &&
          (typeof options.icon === 'string' ||
          typeof options.image === 'string') &&
          typeof options.color === 'string' &&
          typeof options.label === 'string' &&
          typeof options.dateLabel === 'string')) {
      throw new InvalidCardAttributeError();
    }

    CardAttribute.call(this,
      {
        status: status
      },
      {
        icon: options.icon,
        image: options.image,
        color: options.color,
        label: options.label,
        dateLabel: options.dateLabel
      }
    );
  };

  var CardField = function(criteria, options) {
    if (!(typeof criteria === 'object' &&
      ((typeof options.icon === 'string' || typeof options.icon === 'function') ||
      (typeof options.image === 'string' || typeof options.image === 'function')) &&
      typeof options.content === 'string' || typeof options.content === 'function')) {
      throw new InvalidCardAttributeError();
    }

    var payload = {
      content: options.content,
      isPrimary: !!options.isPrimary
    };

    if (options.icon) {
      payload.icon = options.icon;
    } else {
      payload.image = options.image;
    }

    if (typeof options.color === 'string' || typeof options.color === 'function') {
      payload.color = options.color;
    }

    CardAttribute.call(this, criteria, payload);
  };

  var CardAction = function(criteria, options) {
    if (!(typeof criteria === 'object' &&
      typeof options.name === 'string' &&
      (typeof options.icon === 'string' || typeof options.icon === 'function') &&
      typeof options.fn === 'function')) {
      throw new InvalidCardAttributeError();
    }

    this.run = options.fn;

    CardAttribute.call(this, criteria,
      {
        name: options.name,
        icon: options.icon
      }
    );
  };

  var CardClickOverride = function(criteria, options) {
    if (!(typeof criteria === 'object' && typeof options.fn === 'function')) {
      throw new InvalidCardAttributeError();
    }

    this.run = options.fn;

    CardAttribute.call(this, criteria,
      { }
    );
  };

  CardStatus.prototype = Object.create(CardAttribute.prototype);
  CardField.prototype = Object.create(CardAttribute.prototype);
  CardAction.prototype = Object.create(CardAttribute.prototype);
  CardClickOverride.prototype = Object.create(CardAttribute.prototype);

  var CardAttributeCollection = function() {
    this._collection = [];
  };

  CardAttributeCollection.prototype.add = function(attribute) {
    this._collection.push(attribute);
  };

  CardAttributeCollection.prototype.getAttributesMatchingCriteria = function(criteria) {
    var resultSet = [];

    for (var i = 0; i < this._collection.length; i += 1) {
      if (this._collection[i].matchCriteria(criteria)) {
        resultSet.push(this._collection[i]);
      }
    }

    return resultSet;
  };

  CardAttributeCollection.prototype.findOne = function(criteria) {
    for (var i = 0; i < this._collection.length; i += 1) {
      if (this._collection[i].matchCriteria(criteria)) {
        return this._collection[i];
      }
    }
  };

  CardAttributeCollection.prototype.injectWithEach = function(entry, fn) {
    var matches = this.getAttributesMatchingCriteria(entry);
    for (var i = 0; i < matches.length; i += 1) {
      fn(matches[i].getPopulatedOptions(entry));
    }
  };

  var CardStatusCollection = function() {
    CardAttributeCollection.call(this);
  };

  var CardFieldCollection = function() {
    CardAttributeCollection.call(this);
  };

  var CardActionCollection = function() {
    CardAttributeCollection.call(this);
  };

  var CardClickOverrideCollection = function() {
    CardAttributeCollection.call(this);
  };

  CardStatusCollection.prototype = Object.create(CardAttributeCollection.prototype);
  CardFieldCollection.prototype = Object.create(CardAttributeCollection.prototype);
  CardActionCollection.prototype = Object.create(CardAttributeCollection.prototype);
  CardClickOverrideCollection.prototype = Object.create(CardAttributeCollection.prototype);

  CardStatusCollection.prototype.add = function(status, options) {
    try {
      var cardStatus = new CardStatus(status, options);
      CardAttributeCollection.prototype.add.call(this, cardStatus);
    } catch (e) {
      console.warn('Unable to register status.');
    }
  };

  CardStatusCollection.prototype.find = function(name) {
    var statuses = this.getAttributesMatchingCriteria({ status: name });
    return statuses && statuses[0]._options || defaultStatusOptions;
  };

  CardFieldCollection.prototype.add = function(criteria, options) {
    try {
      var field = new CardField(criteria, options);
      CardAttributeCollection.prototype.add.call(this, field);
    } catch (e) {
      console.warn('Unable to register field.');
    }
  };

  CardActionCollection.prototype.add = function(criteria, options) {
    try {
      var action = new CardAction(criteria, options);
      CardAttributeCollection.prototype.add.call(this, action);
    } catch (e) {
      console.warn('Unable to register action.');
    }
  };

  CardActionCollection.prototype.findByName = function(name) {
    for(var i = 0; i < this._collection.length; i += 1) {
      if (this._collection[i]._options.name === name) {
        return this._collection[i];
      }
    }
  };

  CardClickOverrideCollection.prototype.add = function(criteria, func) {
    try {
      var action = new CardClickOverride(criteria, { fn: func });
      CardAttributeCollection.prototype.add.call(this, action);
    } catch (e) {
      console.warn('Unable to register click override.');
    }
  };

  Coral.register(/** @lends Aeon.Agenda# */ {
    /**
     @class Aeon.Agenda
     @extends Coral.Component
     @classdesc An Aeon Agenda.
     @htmltag aeon-agenda
     */
    name: 'Agenda',
    namespace: window.Aeon,
    tagName: 'aeon-agenda',
    className: 'aeon-Agenda',

    properties: {
      /**
       The URL that drives the calendar display

       @type {String}
       @memberof Aeon#
       */
      url: { },

      /**
       The view mode of the calendar (Timeline, Column, List)

       @type {String}
       @memberof Aeon.Agenda#
       */
      mode: {
        default: modes.COLUMN,
        reflectAttribute: true,
        sync: function() {
          if (!this._elements[this.mode].selected) {
            this._elements[this.mode].click();
          }
          this._renderContent();
        }
      },

      /**
       The filters element for consumption in the driving AJAX request

       @type {HTMLElement}
       @memberof Aeon.Agenda#
       */
      filters: Coral.property.contentZone({
        handle: 'filterspane',
        element: FILTERS_TAG_NAME
      }),

      /**
       The calendar's start date

       @type {String}
       @memberof Aeon.Agenda#
       */
      start: {
        set: function(start) {
          this._elements.datepopover.set({
            start: start
          });
        },
        get: function() {
          return this._elements.datepopover.start;
        }
      },

      /**
       The calendar's end date

       @type {String}
       @memberof Aeon.Agenda#
       */
      end: {
        set: function(end) {
          this._elements.datepopover.set({
            end: end
          });
        },
        get: function() {
          return this._elements.datepopover.end;
        }
      },

      /**
       The size variant of the calendar entries

       @type {String}
       @memberof Aeon.Agenda#
       */
      cardSize: {
        set: function(size) {
          this._elements.settingspane.set({
            size: size
          });
        },
        get: function() {
          return this._elements.settingspane.size;
        }
      },

      /**
       The date specifier for displaying the date on Aeon cards

       @type {String}
       @memberof Aeon.Agenda#
       */
      cardDateSpecifier: {
        set: function(specifier) {
          this._cardDateSpecifier = specifier;
        },
        get: function() {
          return this._cardDateSpecifier;
        }
      },

      /**
       The set of status matchers used in calendar entry rendering

       @type {CardAttributeCollection}
       @memberof Aeon.Agenda#
       */
      statuses: {
        get: function() {
          if (!this._statuses) {
            this._statuses = new CardStatusCollection();
          }

          return this._statuses;
        },
        set: function() {}
      },

      /**
       The set of action matchers used in calendar entry rendering

       @type {CardAttributeCollection}
       @memberof Aeon.Agenda#
       */
      actions: {
        get: function() {
          if (!this._actions) {
            this._actions = new CardActionCollection();
          }

          return this._actions;
        },
        set: function() {}
      },

      /**
       The set of field matchers used in calendar entry rendering

       @type {CardAttributeCollection}
       @memberof Aeon.Agenda#
       */
      fields: {
        get: function() {
          if (!this._fields) {
            this._fields = new CardFieldCollection();
          }

          return this._fields;
        },
        set: function() {}
      },

      /**
       The set of card-click override matchers

       @type {CardAttributeCollection}
       @memberof Aeon.Agenda#
       */
      cardClickOverrides: {
        get: function() {
          if (!this._cardClickOverrides) {
            this._cardClickOverrides = new CardClickOverrideCollection();
          }

          return this._cardClickOverrides;
        },
        set: function() {}
      },

      /**
       The set of group matchers used in calendar entry rendering

       @type {GroupSetCollection}
       @memberof Aeon.Agenda#
       */
      groups: {
        get: function() {
          return this._elements.settingspane.groups;
        },
        set: function() {}
      },


      groupBy: {
        set: function(groupBy) {
          this._elements.settingspane.set({
            groupBy: groupBy
          });
        },
        get: function() {
          return this._elements.settingspane.groupBy;
        }
      },
      baseFilters: {
        set: function(filters) {
          this._baseFilters = filters;
        },
        get: function() {
          return this._baseFilters;
        }
      },

      /**
       Function that transforms Aeon component filter format to
       */
      serviceTransformer: { }
    },

    events: {
      // Handles bubbled-up actions from calendar entries
      'aeon-card:action': function(event) {
        var action = this._actions && this._actions.findByName(event.detail.action);
        if (action) {
          action.run(event.detail.payload);
        }
      },
      // View mode change
      'click .aeon-ModeButton': '_setMode',

      // Date, Settings Filter changes
      'aeon:filters:change': '_handleFilterChange',

      // Focus on search pane text field
      'aeon:pane:visible [handle="searchpane"]': '_focusSearchPane',

      'aeon:filter:close': 'selectLastMode',

      'aeon:filter:dateChange': '_setStartAndEndDisplay',

      'aeon:popover:close': '_closeDatePickers',

      'aeon:daterangepicker:inputDate': '_syncCalendars',

      'aeon:navigator:paginate': '_paginateColumns',

      'resize': '_renderColumns',

      'click [handle="clearfilters"]': '_clearFilters'
    },

    mixins: [
      window.Aeon.mixin.dayDelineatedEntryCache()
    ],

    /**
      After solution has set up the initial criteria matchers, fields, actions, statuses. Calling this method
      will initialize the calendar and make the intial AJAX request.

     */
    initialize: function() {
      if (this._componentReady && !this._initialized) {
        this._initialized = true;

        this._getCalendarXHR();
      }
    },

    selectLastMode: function(event) {
      var redrawLastMode = (event.target.tagName !== AEON_DATESELECTOR_TAG_NAME);
      if(this.mode && redrawLastMode) {
        this._elements[this.mode].click();
      }
    },

    /** @private */
    _focusSearchPane: function() {
      this._elements.searchbox.focus();
    },

    /** @private */
    _handleFilterChange: function(event) {
      var detail = event.detail;
      var tagName = event.target.tagName;

      if (tagName === AEON_SETTINGS_TAG_NAME) {
        this.cardSize = detail.settings.size && detail.settings.size[0] || this.cardSize;
        this.groupBy = detail.settings.group && detail.settings.group[0] || this.groupBy;
      }

      if (tagName === AEON_FILTERS_TAG_NAME || tagName === AEON_DATEPOPOVER_TAG_NAME) {
        this._setStartAndEndDisplay(event);

        // TODO: Filter handling
        this._getCalendarXHR();
      } else {
        this._renderContent();
      }

      this._elements[this.mode].click();
    },

    _setStartAndEndDisplay: function(event) {
      var detail = event.detail;

      if(detail.date && detail.date.start && detail.date.end) {
        this._elements.startdatedisplay.value = this.start;
        this._elements.enddatedisplay.value = this.end;
      }
    },

    /** @private */
    _setMode: function(event) {
      this.mode = event.target.attributes.handle.value;
      this.trigger('aeon:panel:mode:change', {mode: this.mode});
    },

    /** @private */
    _renderContent: function() {
      if ((this.entries && this.entries.length === 0 || this.entries === undefined) && this.entriesInitialized) {
        this._elements.placeholder.classList.remove('is-hidden');
        if (this._elements.filterspane._isEmpty()) {
          this._elements.clearfilters.classList.add('is-hidden');
        } else {
          this._elements.clearfilters.classList.remove('is-hidden');
        }
        return;
      } else {
        this._elements.placeholder.classList.add('is-hidden');
      }
      var modes = {
        column: this._renderColumns,
        list: this._renderList,
        timeline: this._renderTimeline
      };
      //Calculation of columns based on the current view
      if(this.mode === 'column'){
        this.columnCount = 0;
      }

      this._elements.dateheader.innerHTML = '';

      modes[this.mode].call(this);
    },

    /** @private */
    _renderColumns: function() {
      if(this.mode === 'column') {
        var that = this;
        var frag = document.createDocumentFragment();
        var xAxisBuckets = [];
        var numOfColumns = this._getNumOfColumns(this.clientWidth);
        var dayPointer = this.columnPointer || this.start;
        var dayCursor = moment(dayPointer);
        var header = document.createElement('aeon-gridheader');
        var navigator = document.createElement('aeon-navigator');
        var startDate = this.start;
        var endDate = this.end;
        var grids = [];

        if(numOfColumns !== this.columnCount) {
          navigator.render({
            pointer: dayPointer,
            start: startDate,
            end: endDate,
            numOfColumns: numOfColumns
          });

          //Adding the days to the header
          for (var i = 0; i < numOfColumns; i += 1) {
            var label = dayCursor.format(Coral.i18n.get('ddd, MMM D', 'momentjs date: medium without year'));
            var headerCell = document.createElement('aeon-gridheadercell');

            if(dayCursor.isAfter(startDate) && dayCursor.isBefore(endDate)) {
              headerCell.classList.add('is-selected-date');
            }
            if(dayCursor.isSame(startDate) || dayCursor.isSame(endDate)) {
              headerCell.classList.add('is-selected-date');
            }
            if (dayCursor.isSame(moment().format('YYYY-MM-DD'))) {
              headerCell.classList.add('is-start-date');
            }

            xAxisBuckets.push({
              label: label,
              dateRange: {start: dayCursor.format('YYYY-MM-DD'), end: dayCursor.add(1, 'd').format('YYYY-MM-DD')}
            });

            headerCell.set({
              content: {
                innerHTML: label
              }
            });
            header.cells.add(headerCell);
          }

          this._elements.dateheader.innerHTML = '';
          this._elements.dateheader.appendChild(header);

          frag.appendChild(navigator);
          this.cardType = 'card';

          //Rendering the grid per group
          var groupSet = this.groups && this.groups.findByName(this.groupBy) || new window.Aeon.SegmentCollection();
          groupSet.eachWithFallback(function (segment) {
            var grid = document.createElement('aeon-grid');
            var scrollContext = document.createElement('aeon-scrollcontent');
            var resizeContainer = document.createElement('div');
            resizeContainer.classList.add('aeon-ResizeContainer');
            resizeContainer.appendChild(scrollContext);

            grid.set({
              aeon: that,
              rowType: 'quiet',
              isOptimized: true,
              scrollContext: groupSet.size() === 0 ? that._elements.content : scrollContext
            });

            grid.ySegments.add(segment);
            grid.xSegments.concat(xAxisBuckets);

            var label = document.createElement('div');
            label.classList.add('aeon-Label');
            label.appendChild(document.createTextNode(segment.label));

            grids.push(grid);

            if(groupSet.size() > 0) {
              scrollContext.appendChild(grid);
              grid = resizeContainer;
              label.insertBefore(new window.Aeon.CollapseButton().set({
                target: scrollContext
              }), label.firstChild);
            }

            frag.appendChild(label);
            frag.appendChild(grid);
          });

          this._initScrollbar(frag, this._elements.content, groupSet.size());

          this._replaceContent(frag);

          grids.forEach(function(grid) {
            grid.ready();
          });

          this.columnCount = numOfColumns;
        }
      }
    },

    _paginateColumns: function(e) {
      this.columnPointer = e.detail.pointer;
      this.columnCount = 0;
      this._elements.dateheader.innerHTML = '';

      this._renderColumns();
    },

    /** @private */
    _getNumOfColumns: function(windowWidth) {
      return Math.floor(windowWidth/DEFAULT_CARD_WIDTH) - 1;
    },

    /** @private */
    _renderList: function() {
      // Always allow scrollability in list view
      this._elements.content.style.overflowY = 'scroll';
      this._elements.contentpane.style.paddingRight = '';

      //By default do Y-Axis Day bucketing
      var start = moment(this.start);
      var day = start.clone();
      var diff = moment(this.end).diff(start, 'd');
      var yAxisBuckets = [];
      var labelFormat = Coral.i18n.get('dddd, MMMM D', 'momentjs date: full without year');
      for(var i = 0; i <= diff; i += 1) {
        yAxisBuckets.push({ label: day.format(labelFormat), dateRange: { start: day.format('YYYY-MM-DD'), end: day.add(1, 'd').format('YYYY-MM-DD') } });
      }

      this.cardType = 'list';

      var grid = document.createElement('aeon-grid');
      grid.set({
        sparseY: true,
        aeon: this,
        rowType: 'timeset'
      });

      grid.ySegments.concat(yAxisBuckets);

      grid.ready();

      this._replaceContent(grid);
    },

    /** @private */
    _renderTimeline: function() {
      var that = this;
      var frag = document.createDocumentFragment();

      var dateHeader = document.createElement('aeon-timelineheader');
      dateHeader.set({
        start: this.start,
        end: this.end
      });

      this._elements.dateheader.appendChild(dateHeader);

      var groupSet = this.groups && this.groups.findByName(this.groupBy) || new window.Aeon.SegmentCollection();

      this._elements.content.unregisterCardContainersForInfiniteScroll();
      this._elements.content.unregisterCardContainersForOptimizedScroll();
      var timelines = [];

      groupSet.eachWithFallback(function(segment, idx) {
        var timeline = document.createElement('aeon-timeline');
        var scrollContext = document.createElement('aeon-scrollcontent');
        var resizeContainer = document.createElement('div');
        resizeContainer.classList.add('aeon-ResizeContainer');
        resizeContainer.appendChild(scrollContext);

        timeline.set({
          start: that.start,
          end: that.end,
          aeon: that,
          criteria: segment.criteria,
          appliedYSegment: segment.name,
          hasHeader: idx === 0,
          isOptimized: true,
          scrollContext: groupSet.size() === 0 ? that._elements.content : scrollContext
        });

        timelines.push(timeline);

        var label = document.createElement('div');
        label.classList.add('aeon-Label');
        label.appendChild(document.createTextNode(segment.label));

        if(groupSet.size() > 0) {
          scrollContext.appendChild(timeline);
          timeline = resizeContainer;
          label.insertBefore(new window.Aeon.CollapseButton().set({
            target: scrollContext
          }), label.firstChild);
        }

        frag.appendChild(label);
        frag.appendChild(timeline);
      });

      this._initScrollbar(frag, this._elements.content, groupSet.size());

      // Show colored backdrop if today's date is in the viewable range
      var start = moment(this.start).startOf('day');
      var end = moment(this.end).endOf('day');

      if(start.isBefore() && end.isAfter()) {
        var backdrop = document.createElement('div');
        backdrop.classList.add('aeon-TimelineBackdrop');

        backdrop.setAttribute('data-label', Coral.i18n.get('NOW') || 'NOW');

        backdrop.style.right = Math.max((100 + start.diff() / end.diff(start) * 100), 0) + '%';
        frag.appendChild(backdrop);
      }

      this._replaceContent(frag);

      for(var i = 0; i < timelines.length; i += 1) {
        timelines[i].ready();
        timelines[i].scrollContext.bootstrapScrollOptimization();
      }
    },

    _initScrollbar: function(frag, target, show) {
      if (navigator.platform === 'MacIntel') {
        if (show) {
          var scrollbar = new window.Aeon.ForcedScrollbar().set({
            element: target
          });
          frag.appendChild(scrollbar);
          target.style.overflowY = 'hidden';
          this._elements.contentpane.style.paddingRight = '11px';

        } else {
          target.style.overflowY = '';
          this._elements.contentpane.style.paddingRight = '';
        }
      }
    },

    /** @private */
    _replaceContent: function(node) {
      this._elements.content.innerHTML = '';
      this._elements.content.appendChild(node);
    },

    /** @private */
    _render: function() {
      this._elements.filterspane = this.querySelector(FILTERS_TAG_NAME) || document.createElement(FILTERS_TAG_NAME);

      var frag = document.createDocumentFragment();

      frag.appendChild(Coral.templates.Aeon.agenda.call(this._elements));
      frag.insertBefore(this._elements.filterspane, this._elements.datepopover);

      this._elements.contentpane.set({
        visible: true
      });

      this.appendChild(frag);

      this._initTooltips();
    },

    _initTooltips: function() {
      var that =  this;
      var createTooltip = function(content, target) {
        var tooltip = new Coral.Tooltip().set({
          variant: 'inspect',
          placement: 'bottom',
          delay: 1500,
          target: target,
          content: {
            innerHTML: Coral.i18n.get(content) || content
          }
        });

        that._elements.headeractions.appendChild(tooltip);
      };

      createTooltip('Filters', this._elements.filterbutton);
      createTooltip('Search', this._elements.searchbutton);
      createTooltip('Settings', this._elements.settingbutton);
      createTooltip('Close', this._elements.exitbutton);
    },

    /** @private */
    _sortEntries: function(entries) {
      return entries.sort(function (x, y) {
        return moment.unix(x.startingAt).isAfter(moment.unix(y.startingAt)) ? 1 : -1;
      });
    },

    /** @private */
    _getCalendarXHR: function() {
      if (!this._initialized) {
        return;
      }

      this._elements.coralwait.classList.remove('is-hidden');
      var that = this;
      var payload = this._generateFilterQuery();

      // NOTE: For the moment, we do not restrict the date range by the base filter set
      payload['timeMin'] = moment(this.start).unix();
      payload['timeMax'] = moment(this.end).endOf('day').unix();

      if (this._ajax) {
        this._ajax.abort();
      }

      this._ajax = $.ajax(this.url + '?' + $.param(payload)).success(function(data) {
        that.entries = typeof data === 'string' ? JSON.parse(data) : data;
        that.entries = that.entries && that.entries.data;
        that.entries = that._sortEntries(that.entries);
        if (typeof that.seedCache === 'function') {
          that.seedCache(that.entries, that.groups);
        }

        that.entriesInitialized = true;
        that.columnPointer = that.start;
        that._elements.coralwait.classList.add('is-hidden');
        that._renderContent();
        that.trigger('aeon:data:loaded', {payload:data});
      });
    },

    _deepMerge: function(base, extension) {
      var that = this;
      var combined = {};
      var keys = Object.keys(base).concat(Object.keys(extension));
      var usageTracker = {};

      keys.forEach(function(i) {
        if (usageTracker[i]) {
          return;
        }

        if (extension.hasOwnProperty(i) && !base.hasOwnProperty(i)) {
          combined[i] = extension[i];
        } else if (Array.isArray(extension[i]) && Array.isArray(base[i])) {
          combined[i] = [].concat(base[i], extension[i]);
        } else if (typeof extension[i] === 'object' && typeof base[i] === 'object') {
          combined[i] = that._deepMerge(base[i], extension[i]);
        } else {
          combined[i] = base[i];
        }

        usageTracker[i] = true;
      });

      return combined;
    },

    _generateFilterQuery: function() {
      var payload;
      var transformer = this.serviceTransformer || this._defaultServiceTransformer;

      if (this._elements.filterspane && this._elements.filterspane.value) {
        payload = this._deepMerge(this._baseFilters, this._elements.filterspane.value);
      } else {
        payload = this.baseFilters;
      }

      return transformer(payload);
    },

    _defaultServiceTransformer: function(payload) {
      var i;
      
      for (i in payload) {
        if (payload.hasOwnProperty(i) && Array.isArray(payload[i])) {
          payload[i] = payload[i].join(',');
        }
      }

      var formatArray = function(key, array) {
        return key + ':(' + array.map(function(val) {
            return '"' + val + '"';
          }).join(' OR ') + ')';
      };

      if (payload.metadata) {
        var metaArray = [];
        var metadata = payload.metadata;
        for (i in metadata) {
          if (metadata.hasOwnProperty(i)) {
            var metadatum = metadata[i];
            if (!Array.isArray(metadatum)) {
              metadatum = [metadatum];
            }

            if (metadatum.length > 0) {
              metaArray.push(formatArray(i, metadatum));
            }
          }
        }

        payload.metadata = metaArray.join(' AND ');
      }

      return payload;
    },

    _clearFilters: function() {
      this._elements.filterspane._clearValues();
    },

    _closeDatePickers: function(e) {
      var me = this;
      this._elements.startdatedisplay.disableInput();
      this._elements.enddatedisplay.disableInput();
      if(e && e.detail.openEndDatePicker) {
        me.focusDatePicker(me._elements.enddatedisplay);
      }
    },

    focusDatePicker: function(datePicker) {
      datePicker.onClick();
    },

    _syncCalendars: function(e) {
      this._elements.datepopover.syncCalendars(e);
    }

  });

  window.Aeon.modes = modes;
  window.Aeon.CardAttribute = CardAttribute;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  Coral.register({
    name: 'CollapseButton',
    namespace: window.Aeon,
    tagName: 'aeon-collapsebutton',
    className: 'aeon-CollapseButton',

    properties: {
      target: {
        get: function() {
          return this._target;
        },
        set: function(target) {
          this._target = target;
        }
      },
      collapsed: {
        get: function() {
          return this.target && this.target.collapsed;
        },
        set: function(collapsed) {
          if (this.target) {
            this.target.collapsed = collapsed;
            if (this.target.collapsed) {
              this.target.collapse();
              this._icon.set({
                icon: 'chevronRight'
              });
            } else {
              this.target.expand();
              this._icon.set({
                icon: 'chevronDown'
              });
            }
          }
        }
      }
    },

    events: {
      'click' : '_doToggle'
    },

    _render: function() {
      this._icon = new Coral.Icon().set({
        icon: 'chevronDown',
        size: 'XS'
      });

      this.appendChild(this._icon);
    },

    _doToggle: function() {
      this.collapsed = !this.collapsed;
    }
  });
}());

(function() {
  'use strict';

  var HEADER_HEIGHT_PX = 50;

  Coral.register({
    name: 'ForcedScrollbar',
    namespace: window.Aeon,
    tagName: 'aeon-forcedscrollbar',
    className: 'aeon-ForcedScrollbar',

    events: {
      'resize': '_setupHandle',
      'mousedown [handle="scrollhandle"]': '_startScroll',
      'global:mouseup': '_endScroll',
      'global:mousemove': '_doScroll'
    },

    properties: {
      element: {
        get: function() {
          return this._element;
        },
        set: function(el) {
          this._element = el;
          this._element.off('aeon:resize:done');
          this._element.on('aeon:resize:done', function() {
            el.querySelector('aeon-forcedscrollbar')._setupHandle();
          });
        }
      }
    },

    _render: function() {
      this.appendChild(Coral.templates.Aeon.scrollbar.call(this._elements));
      this._elements.scrollhandle.style.marginTop = HEADER_HEIGHT_PX + 'px';
    },

    _setupHandle: function() {
      var parent = this.parentNode;
      this._elements.scrollhandle.style.height = parent.clientHeight / parent.scrollHeight * 100 + '%';

      var scrollRatio = this._element.scrollTop / (this._element.scrollHeight - this._element.clientHeight);
      this._elements.scrollhandle.style.marginTop = Math.floor(scrollRatio * (this.clientHeight - this._elements.scrollhandle.clientHeight - HEADER_HEIGHT_PX) + HEADER_HEIGHT_PX) + 'px';
    },

    _startScroll: function(event) {
      this._isScrolling = true;
      this._handleToMouseOffset = event.offsetY;
      this._startY = this.getBoundingClientRect().top;
      event.preventDefault();
    },

    _endScroll: function() {
      this._isScrolling = false;
    },

    _doScroll: function(event) {
      if (this._isScrolling) {
        var scrollRatio;
        var offset = event.clientY - this._handleToMouseOffset - this._startY;
        var minOffset = HEADER_HEIGHT_PX;
        var maxOffset = this.clientHeight - this._elements.scrollhandle.clientHeight;
        offset = Math.max(offset, minOffset);
        offset = Math.min(offset, maxOffset);
        this._elements.scrollhandle.style.marginTop = offset + 'px';

        scrollRatio = (offset - minOffset) / (maxOffset - minOffset);
        this._setScrollPosition(scrollRatio);
      }
    },

    _setScrollPosition: function(scrollRatio) {
      var range = this._element.scrollHeight - this._element.clientHeight;
      this._element.scrollTop = Math.floor(range * scrollRatio);
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  var generateFieldString = function(fields) {
    var fieldStrings = [];

    for(var i = 0; i < fields.length; i += 1) {
      var field = fields[i];

      var iconString = '';
      var colorString = '';

      if (field.icon) {
        if (field.color) {
          colorString = ' style="color: ' + field.color + ';"';
        }
        iconString = '<coral-icon class="aeon-Field-icon aeon-Card-statusIcon" icon="' + field.icon + '"' + colorString + '></coral-icon>';
      } else if (field.image) {
        iconString = '<img class="aeon-Field-image" src="' + field.image + '">';
      }
      var fieldString = '<div class="aeon-Field ' + (field.isPrimary ? 'is-primary' : '') + '">' +
        iconString +
        '<div class="aeon-Field-content">' +
          field.content +
        '</div>' +
      '</div>';

      fieldStrings.push(fieldString);
    }

    return fieldStrings.join('');
  };

  var generateActionString = function(actions) {
    var actionStrings = [];

    for(var i = 0; i < actions.length; i += 1) {
      var action = actions[i];

      var actionString = '<div class="aeon-Action" value="' + action.name + '" title="' + action.name + '">' +
        '<coral-icon icon="' + action.icon + '"></coral-icon>' +
      '</div>';

      actionStrings.push(actionString);
    }

    return actionStrings.join('');
  };

  var generateImage = function(image) {
    var imageString = '';
    if (image) {
      imageString = '<div class="aeon-Card-image" style="background-image: url(\'' + image + '\');"></div>';
    }

    return imageString;
  };

  var generateStatus = function(status) {
    var statusString = '';
    if (status.icon) {
      statusString = '<coral-icon class=\'aeon-Card-statusIcon\' icon=\'' + status.icon + '\' style=\'background: ' + status.color + '\'></coral-icon>';
    } else if (status.image) {
      statusString = '<div class=\'aeon-Card-statusIcon\' style=\'background-color: ' + status.color + '; background-image: url("' + status.image + '");\'></div>';
    }

    return statusString;
  };

  var generateCard = function (options, fields, actions, renderCallback) {
    var hooks = {
      style: '',
      pre: '',
      post: ''
    };
    if (typeof renderCallback === 'function') {
      hooks = renderCallback(options);
    }

    var defaultDateFormat = Coral.i18n.get('h:mm a', 'momentjs time: short');
    var defaultDateFormatString = '[<span class="aeon-Card-dateDecoration">]' + defaultDateFormat + '[</span>]';

    var imageSubstr = generateImage(options.image);
    var statusString = generateStatus(options.status);
    var fieldString = generateFieldString(fields);
    var actionString = generateActionString(actions);

    return '<div id="' + options.id + '" class=\"aeon-Card aeon-Card--size' + options.size + ' aeon-Card--' + options.variant + ' ' + (options.image ? 'has-image' : '') + '\" style="' + hooks.style + '">' +
      hooks.pre +
      imageSubstr +
      '<div class=\"aeon-Card-content\">' +
        '<div class=\"aeon-Card-copy\">'+
          '<div class=\"aeon-Card-status\">' +
            statusString +
          '</div>' +
          '<div class=\"aeon-Card-titlebox\">' +
            '<div class=\"aeon-Card-title\">' +
              options.title.innerText +
            '</div>' +
            '<div class=\"aeon-Card-date\">' +
              '<div class=\"aeon-Card-dateLabel\">' +
                options.status.dateLabel +
              '</div> ' +
              '<div class=\"aeon-Card-dateText\">' +
                options.start.format(options.dateSpecifier || defaultDateFormatString) +
              '</div>' +
            '</div>' +
          '</div>' +
          '<div class=\"aeon-Card-description\">' +
            options.description.innerText +
          '</div>' +
        '</div>' +
        '<div class=\"aeon-Card-fields\">' +
          fieldString +
        '</div>' +
        '<div class=\"aeon-Card-actions\">' +
          actionString +
        '</div>' +
      '</div>' +
      hooks.post +
    '</div>';
  };

  window.Aeon.CardGenerator = generateCard;
  window.Aeon.FieldGenerator = generateFieldString;
  window.Aeon.ActionGenerator = generateActionString;
}());

(function() {
  'use strict';

  var MIN_BUFFER_CARD_COUNT = 10; // cards
  var MIN_CARD_LOAD_HEIGHT = 500; // px
  var MAX_CARD_LOAD_HEIGHT = 1500; // px
  var SCROLL_TRIGGER_POSITION = 75; // px;
  var APPROX_CARD_HEIGHT = 100; // px
  var CARD_LOAD_SAFETY_BUFFER = 1.5; // multiplier

  var events = {
    'scroll.infinite': '_onInfiniteScroll'
  };

  var getDistanceFromBottom = function(container) {
    var childTop = container.lastChild && container.lastChild.offsetTop || 0;
    var childHeight = container.lastChild && container.lastChild.clientHeight || 0;
    return container.clientHeight - childTop - childHeight;
  };

  var methods = {
    registerCardContainerForInfiniteScroll: function(container) {
      this._cardContainers = this._cardContainers || [];
      this._cardBuffers = this._cardBuffers || [];

      this._initSpinner();
      container.loadOffset = 0;

      this._cardContainers.push(container);
      this._createCardBuffer(container);
    },

    unregisterCardContainersForInfiniteScroll: function() {
      this._cardContainers = [];
      this._deleteCardBuffers();
      if (this._scrollSpinner) {
        this._scrollSpinner.style.display = 'block';
      }
    },

    _createCardBuffer: function(container) {
      var buffer = document.createElement('div');
      buffer.classList.add('aeon-CardBuffer');
      buffer.style.width = container.clientWidth + 'px';

      container.buffer = buffer;

      this.appendChild(buffer);
      this._cardBuffers.push(buffer);
    },

    _deleteCardBuffers: function() {
      if (this._cardBuffers) {
        for (var i = 0; i < this._cardBuffers.length; i += 1) {
          try {
            this.removeChild(this._cardBuffers[i]);
          } catch (e) {

          }
        }

        this._cardBuffers = [];
      }
    },

    _initSpinner: function() {
      if (!this._scrollSpinner) {
        this._scrollSpinner = document.createElement('coral-wait');
        this._scrollSpinner.classList.add('aeon-ScrollSpinner');
        this._scrollSpinner.set({ size: 'M' });
      }

      this.appendChild(this._scrollSpinner);
    },

    fillBuffers: function() {
      for(var i = 0; i < this._cardContainers.length; i += 1) {
        var cont = this._cardContainers[i];
        var entries = cont.entries.getAll();
        var buffer = cont.buffer;
        var bufferCardCount = Math.ceil(this.clientHeight / APPROX_CARD_HEIGHT * CARD_LOAD_SAFETY_BUFFER);
        bufferCardCount = bufferCardCount < MIN_BUFFER_CARD_COUNT ? MIN_BUFFER_CARD_COUNT : bufferCardCount;
        var loadOffset = cont.loadOffset;

        var frag = [];
        for(var j = 0; j < bufferCardCount && loadOffset < entries.length; j += 1) {
          var entry = entries[loadOffset];
          var card = cont.cards._renderCard(entry);
          frag.push(card);
          loadOffset += 1;
        }

        buffer.innerHTML = frag.join('');
      }
    },

    moveCardsToContainers: function() {
      var containerDistancesFromBottom = {};
      var cont;

      if (!this.isScrolling) {
        this.isScrolling = true;
      }

      for(var i = 0; i < this._cardContainers.length; i += 1) {
        cont = this._cardContainers[i];
        containerDistancesFromBottom[i] = getDistanceFromBottom(cont);
        if (this._onOptimizedScroll) {
          cont.cards.markVisibleFragments(this.scrollHeight - this.clientHeight, this.scrollHeight);
        }
      }

      for(i = 0; i < this._cardContainers.length; i += 1) {
        cont = this._cardContainers[i];

        var frag = document.createElement('div');
        frag.classList.add('aeon-CardFragment');

        var innerDiv = document.createElement('div');
        innerDiv.classList.add('aeon-CardFragment-inner');

        frag.appendChild(innerDiv);

        var additionalDistanceToLoad = this.clientHeight < MAX_CARD_LOAD_HEIGHT ? this.clientHeight : MAX_CARD_LOAD_HEIGHT;
        additionalDistanceToLoad = additionalDistanceToLoad > MIN_CARD_LOAD_HEIGHT ? additionalDistanceToLoad : MIN_CARD_LOAD_HEIGHT;

        var distanceToLoad = containerDistancesFromBottom[i] + additionalDistanceToLoad;
        var sumHeight = 0;
        var cardStrings = [];
        var entries = cont.entries.getAll();

        for(var j = 0; j < cont.buffer.childNodes.length && sumHeight < distanceToLoad; j += 1) {
          var card = cont.buffer.childNodes[j];
          if (card) {
            sumHeight += card.clientHeight;
            cardStrings.push(cont.cards._renderCard(entries[cont.loadOffset]));
            cont.loadOffset += 1;
          } else {
            break;
          }
        }

        innerDiv.innerHTML = cardStrings.join('');
        cont.cards.addFragment(frag);

        if (this._isDoneLoading()) {
         this._scrollSpinner.style.display = 'none';
        }

      }

      this.fillBuffers();

      this.isScrolling = false;
    },

    _isDoneLoading: function() {
      var isDoneLoading = true;
      for(var i = 0; i < this._cardContainers.length; i += 1) {
        if (this._cardContainers[i].loadOffset < this._cardContainers[i].entries.size()) {
          isDoneLoading = false;
          break;
        }
      }

      return isDoneLoading;
    },

    infiniteScrollTimeoutFunction: function (ctx) {
      ctx.moveCardsToContainers();
      ctx._isScrolling = false;
    },

    bootstrapScrollOptimization: function() {
      var that = this;

      this.fillBuffers();

      requestAnimationFrame(function() {
        that.infiniteScrollTimeoutFunction(that);
        that._bootstrapped = true;
      });
    },

    _onInfiniteScroll: function() {
      if (this._bootstrapped && !this._isScrolling) {
        var wrap = this;
        var wrapHeight = wrap.getBoundingClientRect().height;

        if (wrap.scrollHeight - SCROLL_TRIGGER_POSITION < wrapHeight + wrap.scrollTop) {
          this._isScrolling = true;

          setTimeout(this.infiniteScrollTimeoutFunction, 1000, this);
        }
      }
    }
  };
  
  window.Aeon.mixin.infiniteScrollContext = function() {
    return function(prototype) {
      Coral.commons.augment(prototype, methods, function(objectMethod, mixinMethod) {
        return Coral.commons.callAll(mixinMethod, objectMethod);
      });

      prototype._events = Coral.commons.augment({}, prototype._events, events);
    };
  };
}());

(function() {
  'use strict';

  var events = {
    'scroll.optimization': '_onOptimizedScroll',
    'aeon:resize:done': '_standAloneScrollRender'
  };

  var methods = {
    registerCardContainerForOptimizedScroll: function(container) {
      this._optimizedContainers = this._optimizedContainers || [];
      this._optimizedContainers.push(container);

      // In some implementations, hiding Aeon will result in no cards being show until scroll.
      var that = this;
      setInterval(function() {
        that._standAloneScrollRender();
      }, 500);
    },

    unregisterCardContainersForOptimizedScroll: function() {
      this._optimizedContainers = [];
    },

    optimizedScrollingFunction: function() {
      for (var i = 0; i < this._optimizedContainers.length; i += 1) {
        if (this._optimizedContainers[i].cards.size()) {
          this._optimizedContainers[i].cards.markVisibleFragments(this.scrollTop, this.scrollTop + this.clientHeight);
        }
      }

      this.isScrolling = false;
    },

    _standAloneScrollRender: function() {
      var that = this;

      if (!this.isScrolling) {
        this.isScrolling = true;
        requestAnimationFrame(function() { that.optimizedScrollingFunction(); });
      }
    },

    _onOptimizedScroll: function() {
      if (!this._lastOptimizedScrollTime || (!this.isScrolling && this._lastOptimizedScrollTime < (new Date()).getTime() - 250)) {
        var that = this;

        this._lastOptimizedScrollTime = (new Date()).getTime();
        this.isScrolling = true;

        requestAnimationFrame(function() { that.optimizedScrollingFunction(); });
      }
    }
  };
  
  window.Aeon.mixin.optimizedScrollContext = function() {
    return function(prototype) {
      Coral.commons.augment(prototype, methods, function(objectMethod, mixinMethod) {
        return Coral.commons.callAll(mixinMethod, objectMethod);
      });

      prototype._events = Coral.commons.augment({}, prototype._events, events);
    };
  };
}());

(function() {
  'use strict';

  var CardCollection = function (host) {
    this._host = host;
    this._host.$ = $(this._host);
    this._fragmentsByTop = {};
    this._fragments = [];
  };

  CardCollection.prototype.addFragment = function (fragment) {
    var top = 0;

    if (this._host.lastChild) {
      top = this._host.lastChild.offsetTop + this._host.lastChild.clientHeight;
    }

    this._fragments.push(fragment);
    this._fragmentsByTop[top] = this._fragments.indexOf(fragment);

    return this._host.appendChild(fragment);
  };

  CardCollection.prototype.size = function() {
    return this._fragments.length;
  };

  CardCollection.prototype.clear = function () {
    this._fragmentsByTop = {};
    this._fragments = [];
    this._host.$.empty();
  };

  CardCollection.prototype.setRenderCallback = function(cb) {
    this._renderCallback = cb;
  };

  CardCollection.prototype.setCardType = function(type) {
    this._cardType = type;
  };

  CardCollection.prototype._renderCard = function(entry) {
    var fields = [];
    this._host.aeon.fields.injectWithEach(entry, function(options) {
      fields.push(options);
    });

    var actions = [];
    this._host.aeon.actions.injectWithEach(entry, function(options) {
      actions.push(options);
    });


    var card = window.Aeon.CardGenerator({
      id: entry.id,
      title: {
        innerText: entry.title
      },
      description: {
        innerText: entry.description
      },
      image: entry.image,
      start: moment.unix(entry.startingAt),
      end: moment.unix(entry.endingAt),
      status: this._host.aeon.statuses.find(entry.status),
      dateSpecifier: this._host.aeon.cardDateSpecifier,
      payload: entry,
      size: this._host.aeon.cardSize,
      variant: this._cardType || this._host.aeon.cardType
    }, fields, actions, this._renderCallback);

    return card;
  };

  CardCollection.prototype.markVisibleFragments = function (startHeight, endHeight) {
    var visibleStart = this._findNearestFragment(startHeight) - 1;
    visibleStart = visibleStart < 0 ? 0 : visibleStart;

    var visibleEnd = visibleStart;

    var fragment;
    var currentPos = 0;

    do {
      fragment = this._fragments[visibleEnd];

      if (fragment) {
        currentPos = fragment.offsetTop + fragment.clientHeight;
        visibleEnd += 1;
      } else {
        break;
      }
    } while (currentPos < endHeight);

    for (var i = 0; i < this._fragments.length; i += 1) {
      fragment = this._fragments[i];
      var inner = fragment.querySelector('.aeon-CardFragment-inner');

      if (i < visibleStart || i > visibleEnd) {
        fragment.style.height = fragment.clientHeight + 'px';
        if (inner) {
          inner.style.display = 'none';
        }
      } else if (inner) {
        inner.style.display = 'block';
      }
    }
  };

  CardCollection.prototype._findNearestFragment =  function (top, tops, start, end) {
    if (typeof tops === 'undefined') {
      tops = Object.keys(this._fragmentsByTop);
      for(var i = 0; i < tops.length; i += 1) {
        tops[i] = parseInt(tops[i]);
      }

      tops = tops.sort(function(a, b) { return a - b; });
    }

    if (typeof start === 'undefined') {
      start = 0;
    }

    if (typeof end === 'undefined') {
      end = tops.length - 1;
      end = end < 0 ? 0 : end;
    }

    var middle = Math.floor((start + end) / 2);

    if (start === end) {
      return start;
    } else if (tops[middle] === top) {
      return middle;
    } else if (tops[middle] > top) {
      return this._findNearestFragment(top, tops, start, middle);
    } else {
      return this._findNearestFragment(top, tops, middle + 1, end);
    }
  };

  window.Aeon.CardCollection = CardCollection;
}());

(function() {
  'use strict';

  var InvalidSegmentError = function(message) {
    this.name = 'InvalidSegmentError';
    this.message = message || 'Segment could not be instantiated.';
    this.stack = (new Error()).stack;
  };

  var MustTakeArrayError = function(message) {
    this.name = 'MustTakeArrayError';
    this.message = message || 'Concat must take an array.';
    this.stack = (new Error()).stack;
  };

  var SegmentCollection = function(changeCallback) {
    this._segments = [];
    this._changeCallback = changeCallback;
  };

  SegmentCollection.prototype.add = function(options, silent) {
    if (!(typeof options.label === 'string' &&
      (typeof options.criteria === 'object' || typeof options.dateRange === 'object'))) {
      throw new InvalidSegmentError();
    }

    this._segments.push({
      label: options.label,
      criteria: options.criteria,
      dateRange: options.dateRange,
      name: options.name
    });

    if (!silent && typeof this._changeCallback === 'function') {
      this._changeCallback();
    }
  };

  SegmentCollection.prototype.concat = function(segments, silent) {
    if (!Array.isArray(segments)) {
      throw new MustTakeArrayError();
    }

    for (var i = 0; i < segments.length; i += 1) {
      this.add(segments[i], true);
    }

    if (!silent && typeof this._changeCallback === 'function') {
      this._changeCallback();
    }
  };

  SegmentCollection.prototype.each = function(fn) {
    for (var i = 0; i < this._segments.length; i += 1) {
      fn(this._segments[i]);
    }
  };

  SegmentCollection.prototype.eachWithFallback = function(fn) {
    if(this.size()) {
      for (var i = 0; i < this._segments.length; i += 1) {
        fn(this._segments[i], i);
      }
    } else {
      fn({
        label: '',
        criteria: { }
      }, 0);
    }
  };

  SegmentCollection.prototype.size = function() {
    return this._segments.length;
  };

  window.Aeon.SegmentCollection = SegmentCollection;
}());

(function() {
  'use strict';

  var EntryCollection = function (host) {
    this._host = host;
    this._entries = [];
    this._entriesIdHash = {};
  };

  EntryCollection.prototype.set = function (entries) {
    this._entries = entries;
    for (var i = 0; i < this._entries.length; i += 1) {
      var entry = this._entries[i];
      this._entriesIdHash[entry.id] = entry;
    }
  };

  EntryCollection.prototype.add = function (entry) {
    this._entries.push(entry);
    this._entriesIdHash[entry.id] = entry;
  };

  EntryCollection.prototype.done = function () {
    var cards = [];
    this._host.cards.clear();

    if (!this._host.isOptimized) {
      for (var i = 0; i < this._entries.length; i += 1) {
        cards.push(this._host.cards._renderCard(this._entries[i]));
      }

      var el = document.createElement('div');
      el.innerHTML = cards.join('');
      this._host.cards.addFragment(el);
    } else if (this._host.scrollContext) {
      this._host.scrollContext.registerCardContainerForInfiniteScroll(this._host);
      this._host.scrollContext.registerCardContainerForOptimizedScroll(this._host);
    }
  };

  EntryCollection.prototype.size = function () {
    return this._entries.length;
  };

  EntryCollection.prototype.getAll = function () {
    return this._entries;
  };

  EntryCollection.prototype.findById = function (id) {
    return this._entriesIdHash[id];
  };

  Coral.register({
    name: 'CardContainer',
    namespace: window.Aeon,
    tagName: 'aeon-cardcontainer',
    className: 'aeon-CardContainer',

    properties: {
      isOptimized: {
        get: function() {
          return this._isOptimized;
        },
        set: function(isOptimized) {
          this._isOptimized = isOptimized;
        }
      },

      appliedYSegment: {
        get: function() {
          return this._appliedYSegment;
        },
        set: function(appliedYSegment) {
          this._appliedYSegment = appliedYSegment;
        }
      },

      scrollContext: {
        set: function(scrollContext) {
          this._scrollContext = scrollContext;
        },
        get: function() {
          return this._scrollContext;
        }
      },

      entries: {
        get: function() {
          if(!this._entries) {
            this._entries = new EntryCollection(this, this.isOptimized);
          }

          return this._entries;
        },
        set: function() { }
      },

      cards: {
        get: function() {
          if(!this._cards) {
            this._cards = new window.Aeon.CardCollection(this);
          }

          return this._cards;
        },
        set: function() { }
      },

      criteria: {
        get: function() {
          return this._criteria;
        },
        set: function(criteria) {
          this._criteria = criteria;
        }
      },

      dateRange: {
        get: function() {
          return this._dateRange;
        },
        set: function(dateRange) {
          this._dateRange = dateRange;
        }
      },

      hasHeader: {
        get: function() {
          return this._elements.header && this._elements.header.visible;
        },
        set: function(visible) {
          if (this._elements.header) {
            this._elements.header.set({
              visible: visible
            });
          }
        }
      },

      // TODO: Revisit this in a future refactor. I don't like it.
      // This may not be the best approach for sharing data scope
      aeon: {
        get: function() {
          return this._aeon;
        },
        set: function(aeon) {
          this._aeon = aeon;
        }
      }
    },

    events: {
      'click .aeon-Card': '_showDetails',
      'click .aeon-Card .aeon-Action': '_triggerAction',
      'capture:mouseenter .aeon-Card': '_showActions',
      'capture:mouseleave .aeon-Card': '_hideActions'
    },

    _showActions: function(event) {
      if (event.target.classList.contains('aeon-Card')) {
        event.target.classList.add('is-showing-actions');
      }
    },

    _hideActions: function(event) {
      if (event.target.classList.contains('aeon-Card')) {
        event.target.classList.remove('is-showing-actions');
      }
    },

    _triggerAction: function(event) {
      event.stopPropagation();

      var card = $(event.matchedTarget).closest('.aeon-Card').get(0);
      var entry = this.entries.findById(card.id);

      this.trigger('aeon-card:action', {
        action: event.matchedTarget.attributes.value.value,
        payload: entry
      });
    },

    _showDetails: function(event) {
      var card = event.matchedTarget;

      if (!card.classList.contains('aeon-Card')) {
        return;
      }

      var entry = this.entries.findById(card.id);

      var clickOverride = this.aeon.cardClickOverrides.findOne(entry);

      if (clickOverride) {
        clickOverride.run(entry);
        return;
      }

      var fields = [];
      this.aeon.fields.injectWithEach(entry, function(options) {
        fields.push(options);
      });

      var actions = [];
      this.aeon.actions.injectWithEach(entry, function(options) {
        actions.push(options);
      });

      var dialog = new Coral.Dialog();
      dialog.classList.add('aeon-Card-details');
      dialog.on('coral-overlay:close', function() {
        dialog.parentNode.removeChild(dialog);
      });

      var dialogContent = document.createElement('coral-dialog-content');
      var details = new window.Aeon.Details();
      details.set({
        status: this.aeon.statuses.find(entry.status),
        title: {
          innerHTML: entry.title
        },
        description: {
          innerHTML: entry.description
        },
        media: entry.image,
        fields: {
          innerHTML: window.Aeon.FieldGenerator(fields)
        },
        actions: {
          innerHTML: window.Aeon.ActionGenerator(actions)
        },
        entry: entry,
        container: this,
        start: entry.startingAt,
        end: entry.endingAt,
        link: entry.link
      });

      dialogContent.appendChild(details);
      dialog.appendChild(dialogContent);
      card.appendChild(dialog);

      setTimeout(function() { dialog.show(); }, 0);
    },

    lookupEntrySet: function() {
      if (this._aeon.entries) {
        if (!this.dateRange && Object.keys(this.criteria).length === 0) {
          this.entries.set(this._aeon.entries);
          return true;
        } else if (this.dateRange && (this.appliedYSegment || Object.keys(this.criteria).length === 0)) {
          var cache = this.findEntrySet(this.dateRange.start);
          if (cache) {
            this.entries.set(cache);
            return true;
          }
        }
      }

      return false;
    },

    findEntrySet: function(start) {
      var cache;
      if (typeof this._aeon.findCache === 'function' && this._aeon.entries) {
        var key = moment(start).unix();

        if(this.appliedYSegment) {
          key += '-' + this.appliedYSegment;
        }
        cache = this._aeon.findCache(key);
      }
      return cache;
    },

    _prepareForRedraw: function() {
      if (this._elements.header) {
        this._elements.header.remove();
      }

      this.innerHTML = '';

      if (this._elements.header) {
        this.appendChild(this._elements.header);
      }
    },

    _redrawContainer: function() {

    },

    _forEachOwnedEntry: function(fn) {
      if (!(this.aeon && this.aeon.entries)) {
        return;
      }

      this._momentStart = this._momentStart || (this.dateRange && this.dateRange.start && moment(this.dateRange.start).unix());
      this._momentEnd = this._momentEnd || (this.dateRange && this.dateRange.end && moment(this.dateRange.end).unix());
      var entries = this._momentStart && this.findEntrySet(this._momentStart) || this.aeon.entries;

      for (var i = 0; i < entries.length; i += 1) {
        var entry = entries[i];

        var isAfterStart = !this._momentStart || this._momentStart <= entry.startingAt;
        var isBeforeEnd = !this._momentEnd || entry.startingAt < this._momentEnd;
        var isMatchingCriteria = !this.criteria || this._hasMatchingCriteria(entry, this.criteria);

        if (isAfterStart && isBeforeEnd && isMatchingCriteria) {
          fn(entry);
        }
      }
    },

    /** @private */
    _hasMatchingCriteria: function(entry, criteria) {
      return window.Aeon.CardAttribute.prototype._deepMatchCriteria(entry, criteria);
    }
  });

  Coral.register({
    name: 'CardContainer.Header',
    namespace: window.Aeon,
    tagName: 'aeon-cardcontainerheader',
    className: 'aeon-CardContainerHeader',
    properties: {
      visible: {
        set: function(visible) {
          this._visible = visible;
          this.$.toggleClass('is-visible', visible);
        },
        get: function() {
          return this._visible;
        }
      }
    },

    _render: function() {
      // compatibility with CoralUI
      this.$ = $(this);
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  var aeonPaneRegistry = {};
  var aeonPaneButtonRegistry = {};

  Coral.register({
    name: 'Pane',
    namespace: window.Aeon,
    tagName: 'aeon-pane',
    className: 'aeon-Pane',

    properties: {
      'visible': {
        transform: Coral.transform.boolean,
        set: function(visible) {
          this._visible = visible;
          $(this).toggleClass('is-visible', visible);

          if (visible) {
            this.trigger('aeon:pane:visible', {});
          }
        },
        get: function() {
          return this._visible;
        }
      }
    },

    close: function() {
      if (this.button && this.button.toggleable) {
        this.button.togglePane(null, false);
      }
    }
  });

  Coral.register({
    name: 'Pane.Button',
    namespace: window.Aeon,
    tagName: 'aeon-pane-button',
    className: 'aeon-PaneButton',

    properties: {
      'group': {
        reflectAttribute: true,
        transform: Coral.transform.string,
        sync: function() {
          if (this.group) {
            aeonPaneButtonRegistry[this.group] = aeonPaneButtonRegistry[this.group] || [];
            aeonPaneButtonRegistry[this.group].push(this);
          }
        }
      },
      'isActive': {
        transform: Coral.transform.boolean,
        sync: function() {
          $(this).toggleClass('is-active', this.isActive);
        }
      },
      'toggleable': {
        transform: Coral.transform.boolean
      },
      'pane': {
        reflectAttribute: true,
        set: function(pane) {
          this._boundPane = document.querySelector(pane);
          this._paneSelector = pane;

          if (this._boundPane) {
            this._boundPane.button = this;

            if (this.group) {
              aeonPaneRegistry[this.group] = aeonPaneRegistry[this.group] || [];
              aeonPaneRegistry[this.group].push(this._boundPane);
            }
          }
        },
        get: function() {
          return this._boundPane;
        }
      },
      'selected': {
        reflectAttribute: true,
        sync: function() {
          $(this).toggleClass('is-selected', this.selected);
        }
      }
    },

    events: {
      'click': 'togglePane'
    },

    togglePane: function(event, show) {
      this.selected = typeof show !== 'undefined' ? show : !(this.toggleable && this.selected);

      if(!this._boundPane && this._paneSelector) {
        this._boundPane = document.querySelector(this._paneSelector);

        if (this._boundPane) {
          this._boundPane.button = this;

          if (this.group) {
            aeonPaneRegistry[this.group] = aeonPaneRegistry[this.group] || [];
            aeonPaneRegistry[this.group].push(this._boundPane);
          }
        }
      }

      if(this._boundPane) {
        this._boundPane.visible = typeof show !== 'undefined' ? show : !(this.toggleable && this._boundPane.visible);
      }

      var i;

      if (this.group && aeonPaneRegistry[this.group]) {
        for (i = 0; i < aeonPaneRegistry[this.group].length; i += 1) {
          if (aeonPaneRegistry[this.group][i] !== this._boundPane) {
            aeonPaneRegistry[this.group][i].visible = false;
          }
        }
      }

      if (this.group && aeonPaneButtonRegistry[this.group]) {
        for (i = 0; i < aeonPaneButtonRegistry[this.group].length; i += 1) {
          if (aeonPaneButtonRegistry[this.group][i] !== this) {
            aeonPaneButtonRegistry[this.group][i].selected = false;
          }
        }
      }
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  Coral.register({
    name: 'SearchPane',
    namespace: window.Aeon,
    tagName: 'aeon-searchpane',
    className: 'aeon-SearchPane',
    extend: window.Aeon.Pane
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  Coral.register({
    name: 'Content',
    namespace: window.Aeon,
    tagName: 'aeon-content',
    className: 'aeon-Content',
    extend: window.Aeon.Pane
  });

  Coral.register({
    name: 'DisplayContent',
    namespace: window.Aeon,
    tagName: 'aeon-displaycontent',
    className: 'aeon-DisplayContent',

    mixins: [
      window.Aeon.mixin.infiniteScrollContext(),
      window.Aeon.mixin.optimizedScrollContext()
    ]
  });

  Coral.register({
    name: 'ScrollContent',
    namespace: window.Aeon,
    tagName: 'aeon-scrollcontent',
    className: 'aeon-ScrollContent',

    mixins: [
      window.Aeon.mixin.infiniteScrollContext(),
      window.Aeon.mixin.optimizedScrollContext(),
      window.Aeon.mixin.isResizeable()
    ],

    events: {
      'mousewheel': function(event) {
        this.scrollTop -= event.wheelDelta;
        event.preventDefault();
      }
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  Coral.register({
    name: 'Details',
    namespace: window.Aeon,
    tagName: 'aeon-details',
    className: 'aeon-Details',

    properties: {
      status: {
        sync: function() {
          if (this.status.icon) {
            this._elements.status.innerHTML = '<coral-icon class=\'aeon-Card-statusIcon\' style=\'background: ' + this.status.color + '\' icon=\'' + this.status.icon + '\'></coral-icon> ' + this.status.label;
          } else if (this.status.image) {
            this._elements.status.innerHTML = '<div class=\'aeon-Card-statusIcon\' style=\'background-color: ' + this.status.color + '; background-image: url("' + this.status.image + '");\'></div> ' + this.status.label;
          }
          this._elements.status.style.color = this.status.color;
          this._renderDate();
        }
      },
      title: Coral.property.contentZone({
        handle: 'title',
        element: 'aeon-details-title'
      }),
      description: Coral.property.contentZone({
        handle: 'description',
        element: 'aeon-details-description'
      }),
      media: {
        sync: function() {
          if (this.media) {
            this._elements.media.style.display = 'block';
            this._elements.media.src = this.media;
          }
        }
      },
      fields: Coral.property.contentZone({
        handle: 'fields',
        element: 'aeon-details-fields'
      }),
      actions: Coral.property.contentZone({
        handle: 'actions',
        element: 'aeon-details-actions'
      }),
      entry: { },
      container: { },
      start: {
        sync: function() {
          this._renderDate();
        }
      },
      end: {
        sync: function() {
          this._renderDate();
        }
      },
      link: {
        set: function(link) {
          var button = this._elements.viewbutton;
          button.classList[link ? 'add' : 'remove']('is-visible');
          button.href = link;
        },
        get: function() {
          return this._elements.viewbutton.href;
        }
      }
    },

    events: {
      'click .aeon-Action': '_propagateAction'
    },

    _renderDate: function() {
      // TODO: End date, text formatting

      var dateFormat = Coral.i18n.get('MMMM, D YYYY', 'momentjs date: long');
      var timeFormat = Coral.i18n.get('h:mm a', 'momentjs time: short');
      this._elements.datelabel.innerHTML = this.status.dateLabel;
      this._elements.datetext.innerHTML = moment.unix(this.start).format(dateFormat);
      this._elements.time.innerHTML = moment.unix(this.start).format(timeFormat);
    },

    _propagateAction: function(event) {
      this.container.trigger('aeon-card:action', {
        action: event.matchedTarget.attributes.value.value,
        payload: this.entry
      });
    },

    _render: function() {
      this.appendChild(Coral.templates.Aeon.details.call(this._elements));
    }
  });

  Coral.register({
    name: 'Details.Status',
    namespace: window.Aeon,
    tagName: 'aeon-details-status',
    className: 'aeon-Details-status'
  });

  Coral.register({
    name: 'Details.Title',
    namespace: window.Aeon,
    tagName: 'aeon-details-title',
    className: 'aeon-Details-title'
  });

  Coral.register({
    name: 'Details.Description',
    namespace: window.Aeon,
    tagName: 'aeon-details-description',
    className: 'aeon-Details-description'
  });

  Coral.register({
    name: 'Details.Date',
    namespace: window.Aeon,
    tagName: 'aeon-details-date',
    className: 'aeon-Details-date'
  });

  Coral.register({
    name: 'Details.Fields',
    namespace: window.Aeon,
    tagName: 'aeon-details-fields',
    className: 'aeon-Details-fields'
  });

  Coral.register({
    name: 'Details.Actions',
    namespace: window.Aeon,
    tagName: 'aeon-details-actions',
    className: 'aeon-Details-actions'
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  var variants = {
    NORMAL: 'normal',
    LABELLED: 'labelled'
  };

  var ALL_VARIANT_CLASSES = '';
  for(var variant in variants) {
    ALL_VARIANT_CLASSES += 'aeon-Cell--' + variant + ' ';
  }

  Coral.register({
    name: 'Cell',
    namespace: window.Aeon,
    tagName: 'aeon-cell',
    className: 'aeon-Cell',
    extend: window.Aeon.CardContainer,

    events: {
      'drop': function(e) {
        this.$.removeClass('is-droptarget');
        this.trigger('aeon:cell:drop', {
          criteria: this.criteria,
          dateRange: this.dateRange,
          dataTransferEvent: e
        });
      },
      'dragenter': function(event) {
        event.preventDefault();
      },
      'dragover': function(event) {
        this.$.addClass('is-droptarget');
        event.preventDefault();
      },
      'dragleave': function() {
        this.$.removeClass('is-droptarget');
      },
      'click': function(event) {
        if (event.target === this) {
          this.trigger('aeon:cell:click', {
            criteria: this.criteria,
            dateRange: this.dateRange
          });
        }
      }
    },
    properties: {
      'group-id': {
        default: Coral.commons.getUID(),
        reflectAttribute: true,
        transform: Coral.transform.string
      },
      label: {
        default: ' ',
        reflectAttribute: true,
        transform: Coral.transform.string,
        sync: function () {
          this._elements.header.innerHTML = this.label;
        }
      },
      variant: {
        default: 'normal',
        reflectAttribute: true,
        transform: Coral.transform.string,
        sync: function () {
          this.$.removeClass('aeon-Cell--quiet');
          this.$.addClass('aeon-Cell--' + this.variant);
        }
      },
      compact: {
        default: false,
        reflectAttribute: true,
        sync: function () {
          this.$.toggleClass('is-compact', this.compact);
        }
      },
      list: {
        default: false,
        reflectAttribute: true,
        sync: function () {
          this.$.toggleClass('is-list', this.list);
        }
      }
    },

    _render: function() {
      // compatibility with CoralUI
      this.$ = $(this);

      this._elements.header = this.querySelector('aeon-celllabel') || document.createElement('aeon-celllabel');
      this.appendChild(this._elements.header);
    },

    ready: function() {
      if (!this.aeon) {
        return;
      }

      var that = this;
      this._prepareForRedraw();

      if (!this.lookupEntrySet()) {
        this._forEachOwnedEntry(function (entry) {
          that.entries.add(entry);
        });
      }

      this.entries.done();
    }
  });

  Coral.register({
    name: 'Cell.Label',
    namespace: window.Aeon,
    tagName: 'aeon-celllabel',
    className: 'aeon-CellLabel',
    extend: window.Aeon.CardContainer.Header
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  var aeonCellTagName = 'aeon-cell';

  var variants = {
    SWIMLANE: 'swimlane',
    TIMESET: 'timeset',
    QUIET: 'quiet',
    INLINE: 'inline'
  };

  var ALL_VARIANT_CLASSES = '';
  for(var i in variants) {
    ALL_VARIANT_CLASSES += 'aeon-Row--' + variants[i] + ' ';
  }

  var CellCollection = function(host) {
    this._host = host;
  };

  CellCollection.prototype = Object.create(Coral.Collection.prototype);

  CellCollection.prototype.add = function(cell, before) {
    if(!(cell instanceof HTMLElement)) {
      var config = cell;
      cell = document.createElement(aeonCellTagName);
      cell.set(config, true);
    }

    return this._host.insertBefore(cell, before || null);
  };

  CellCollection.prototype.getAll = function() {
    return this._host.querySelectorAll(aeonCellTagName);
  };

  Coral.register({
    name: 'Row',
    namespace: window.Aeon,
    tagName: 'aeon-row',
    className: 'aeon-Row',

    properties: {
      cells: {
        get: function() {
          if(!this._cells) {
            this._cells = new CellCollection(this);
          }

          return this._cells;
        },
        set: function() { }
      },

      label: Coral.property.contentZone({
        handle: 'label',
        element: 'aeon-rowlabel'
      }),

      variant: {
        default: variants.TIMESET,
        reflectAttribute: true,
        transform: Coral.transform.string,
        sync: function () {
          this.$.removeClass(ALL_VARIANT_CLASSES);
          this.$.addClass('aeon-Row--' + this.variant);
        }
      }
    },

    _render: function() {
      // compatibility with CoralUI
      this.$ = $(this);

      var label = this._elements.label = document.createElement('aeon-rowlabel');
      this.insertBefore(label, this.childNodes[0]);
    }
  });

  Coral.register({
    name: 'Row.Label',
    namespace: window.Aeon,
    tagName: 'aeon-rowlabel',
    className: 'aeon-RowLabel'
  });
}());

(function() {
  'use strict';

  var HeaderCellCollection = function(host) {
    this._host = host;
  };

  HeaderCellCollection.prototype = Object.create(Coral.Collection.prototype);

  HeaderCellCollection.prototype.add = function(cell, before) {
    if(!(cell instanceof HTMLElement)) {
      var config = cell;
      cell = document.createElement('aeon-gridheadercell');
      cell.set(config, true);
    }

    return this._host.insertBefore(cell, before || null);
  };

  HeaderCellCollection.prototype.getAll = function() {
    return this._host.querySelectorAll('aeon-gridheadercell');
  };

  Coral.register({
    name: 'GridHeader',
    namespace: window.Aeon,
    tagName: 'aeon-gridheader',
    className: 'aeon-GridHeader',
    properties: {
      cells: {
        get: function () {
          if (!this._cells) {
            this._cells = new HeaderCellCollection(this);
          }

          return this._cells;
        },
        set: function () {
        }
      }
    }
  });

  Coral.register({
    name: 'GridHeader.Cell',
    namespace: window.Aeon,
    tagName: 'aeon-gridheadercell',
    className: 'aeon-GridHeaderCell',
    properties: {
      content: {
        contentZone: true,
        set: function () {
        },
        get: function () {
          return this;
        }
      }
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  var RowCollection = function(host) {
    this._host = host;
  };

  RowCollection.prototype = Object.create(Coral.Collection.prototype);

  RowCollection.prototype.add = function(row, before) {
    if(!(row instanceof HTMLElement)) {
      var config = row;
      row = document.createElement('aeon-row');
      row.set(config, true);
    }

    return this._host.insertBefore(row, before || null);
  };

  RowCollection.prototype.getAll = function() {
    return this._host.querySelectorAll('aeon-row');
  };

  Coral.register({
    name: 'Grid',
    namespace: window.Aeon,
    tagName: 'aeon-grid',
    className: 'aeon-Grid',

    properties: {
      /**
       Are we going to optimize the scroll?

       @type {Object}
       @memberof Aeon.Grid#
       */
      isOptimized: {
        get: function() {
          return this._isOptimized;
        },
        set: function(isOptimized) {
          this._isOptimized = isOptimized;
        }
      },

      scrollContext: {
        set: function(scrollContext) {
          this._scrollContext = scrollContext;
        },
        get: function() {
          return this._scrollContext;
        }
      },

      /**
       The segmentation for the x-axis

       @type {Object}
       @memberof Aeon.Grid#
       */
      xSegments: {
        get: function() {
          if(!this._xSegments) {
            this._xSegments = new window.Aeon.SegmentCollection();
          }
          return this._xSegments;
        },
        set: function() { }
      },

      /**
       The segmentation for the y-axis

       @type {Object}
       @memberof Aeon.Grid#
       */
      ySegments: {
        get: function() {
          if(!this._ySegments) {
            this._ySegments = new window.Aeon.SegmentCollection();
          }
          return this._ySegments;
        },
        set: function() { }
      },

      rowType: {
        get: function() {
          return this._rowType;
        },
        set: function(rowType) {
          this._rowType = rowType;
        }
      },

      // TODO: Revisit this in a future refactor. I don't like it.
      // This may not be the best approach for sharing data scope
      aeon: {
        get: function() {
          return this._aeon;
        },
        set: function(aeon) {
          this._aeon = aeon;
        }
      },

      sparseY: {
        get: function() {
          return this._sparseY;
        },
        set: function(sparseY) {
          this._sparseY = sparseY;
        }
      },

      rows: {
        get: function() {
          if(!this._rows) {
            this._rows = new RowCollection(this);
          }

          return this._rows;
        },
        set: function() { }
      },
      header: {
        get: function() {
          return this._elements.header;
        },
        set: function() {}
      }
    },

    _render: function() {
      var header = this._elements.header = this.querySelector('aeon-grid-header') || document.createElement('aeon-grid-header');
      this.insertBefore(header, this.childNodes[0]);
    },

    /** @private */
    ready: function() {
      this.aeon._elements.content.unregisterCardContainersForInfiniteScroll();
      this.aeon._elements.content.unregisterCardContainersForOptimizedScroll();

      this.innerHTML = '';
      var that = this;

      this.ySegments.eachWithFallback(function(ySegment) {
        var row = document.createElement('aeon-row');
        row.set({
          label: {
            innerHTML: ySegment.label
          },
          variant: that.rowType
        });

        that.xSegments.eachWithFallback(function(xSegment) {
          var cell = document.createElement('aeon-cell');
          cell.set({
            appliedYSegment: ySegment.name,
            criteria: $.extend({}, ySegment.criteria, xSegment.criteria),
            dateRange: xSegment.dateRange || ySegment.dateRange,
            aeon: that.aeon,
            isOptimized: !!that.isOptimized,
            scrollContext: that.scrollContext,
            compact: that.aeon.cardSize === 'S' && that.aeon.cardType !== 'list',
            list: that.aeon.cardType === 'list'
          });
          cell.ready();
          row.cells.add(cell);
        });

        that.rows.add(row);

        if (that.isOptimized) {
          that.scrollContext.bootstrapScrollOptimization();
        }
      });

      if (this.sparseY) {
        this._removeUnpopulatedRows();
      }
    },

    /** @private */
    _removeUnpopulatedRows: function() {
      var rows = this.rows.getAll();
      for(var i = 0; i < rows.length; i += 1) {
        var row = rows[i];
        var isEmpty = true;
        var cells = row.cells.getAll();
        for(var j = 0; j < cells.length; j += 1) {
          var cell = cells[j];
          if (cell.entries.getAll().length) {
            isEmpty = false;
          }
        }

        if (isEmpty) {
          this.rows.remove(row);
        }
      }
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  Coral.register({
    name: 'TimelineHeader',
    namespace: window.Aeon,
    tagName: 'aeon-timelineheader',
    className: 'aeon-TimelineHeader',

    properties: {
      start: {
        set: function(start) {
          this._start = start;
          this._dateChange();
        },
        get: function() {
          return this._start;
        }
      },
      end: {
        set: function(end) {
          this._end = end;
          this._dateChange();
        },
        get: function() {
          return this._end;
        }
      }
    },

    _dateChange: function() {
      this.innerHTML = '';

      var span = moment(this.end).diff(moment(this.start), 'days') + 1;
      var date = moment(this.start);
      var cell;
      var displayedDays = 0;

      if (span > 120) {
        do {
          displayedDays += date.daysInMonth();

          cell = document.createElement('aeon-timelineheader-cell');
          cell.set({
            label: date.format('MMM')
          });

          this.appendChild(cell);

          date = date.add(1, 'months');
        } while (date.isBefore(moment(this.end).add(1, 'month')));

        var offset = (date.format('D') - 1) * -100 / span;
        this.style['margin-left'] = offset + '%';

      } else {
        var range;

        if (span > 30) {
          range = 7;
        } else if (span > 15) {
          range = 2;
        } else {
          range = 1;
        }

        do {
          displayedDays += range;

          cell = document.createElement('aeon-timelineheader-cell');

          cell.set({
            label: date.format(Coral.i18n.get('MMM D', 'momentjs date: medium without year'))
          });

          this.appendChild(cell);

          date = date.add(range, 'day');
        } while (date.isBefore(moment(this.end).add(1, 'day')));
        this.style['margin-left'] = '';
      }

      var width = displayedDays * 100 / span;
      this.style.width = width + '%';
    }
  });

  Coral.register({
    name: 'TimelineHeader.Cell',
    namespace: window.Aeon,
    tagName: 'aeon-timelineheader-cell',
    className: 'aeon-TimelineHeader-cell',

    properties: {
      label: {
        set: function(value) {
          this._elements.label.innerHTML = value;
        },
        get: function() {
          return this._elements.label.innerHTML;
        }
      }
    },

    _render: function() {
      var frag = Coral.templates.Aeon.timelinelabel.call(this._elements);
      this.appendChild(frag);
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  Coral.register({
    name: 'Timeline',
    namespace: window.Aeon,
    tagName: 'aeon-timeline',
    className: 'aeon-Timeline',
    extend: window.Aeon.CardContainer,

    properties: {
      start: {
        set: function(start) {
          this._start = start;
        },
        get: function() {
          return this._start;
        }
      },
      end: {
        set: function(end) {
          this._end = end;
        },
        get: function() {
          return this._end;
        }
      }
    },

    /** @private */
    ready: function() {
      if (!this.aeon) {
        return;
      }

      this._prepareForRedraw();

      var that = this;
      var diff = moment(this.end).endOf('day').diff((moment(this.start).startOf('day')));

      this.cards.setCardType('timeline');
      this.cards.setRenderCallback(function(entry) {
        var startOffset = entry.start.diff(moment(that.start));
        var entryDiff;

        if (entry.end) {
          entryDiff = entry.end.diff(entry.start);
        } else {
          // If there is no end date, the line should continue until the end of the page.
          entryDiff = moment(that.end).endOf('day').diff(entry.start);
        }

        var margin = Math.min((startOffset / diff * 100), 100);
        var baseMargin = 0;

        if (margin < 0) {
          baseMargin = margin;
          margin = 0;
        }

        var width = Math.min((entryDiff / diff * 100) + baseMargin, 100) + '%';
        var blurIn = baseMargin < 0 ? '<div class="aeon-Card-blurIn"></div>' : '';
        return {
          style: 'margin-left: ' + margin + '%;',
          pre: '<div class="aeon-Card-backdrop" style="width: ' +  width + ';"></div>' + blurIn,
          post: ''
        };
      });

      if (!this.lookupEntrySet()) {
        this._forEachOwnedEntry(function (entry) {
          that.entries.add(entry);
        });
      }

      that.entries.done();
    }
  });


}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  var TAG_NAME = 'aeon-filters';
  var CLASS_NAME = 'aeon-Filters';

  Coral.register({
    name: 'Filters',
    namespace: window.Aeon,
    tagName: TAG_NAME,
    className: CLASS_NAME,
    extend: window.Aeon.Pane,

    events: {
      'click [handle="apply"]': '_applyValues',
      'click [handle="reset"]': 'resetValues'
    },

    properties: {
      'namespace': {
        default: '',
        reflectAttribute: true,
        transform: Coral.transform.string
      },
      'value': {
        default: {},
        sync: function() {
          var eventPayload = {};

          if (this.namespace) {
            eventPayload[this.namespace] = this.value;
          } else {
            eventPayload = this.value;
          }

          this.trigger('aeon:filters:change', eventPayload);
          this.resetValues();
        }
      }
    },

    _clearValues: function() {
      var filterElements = this.querySelectorAll('[filter]');
      if (filterElements) {
        for (var i = 0; i < filterElements.length; i++) {
          var el = filterElements[i];
          //This will just clear the filters with status/ platform/ properties
          if (el instanceof Coral.Component) {
            if (el.checked) {
              el.checked = false;
            } else if (el.values) {
              el.values = [];
            }
          }
        }
      }
      this._applyValues();
    },

    // TODO: This is approximately correct
    _applyValues: function() {
      var filterElements = this.querySelectorAll('[filter]');
      var filterObject = {};

      var pathSeeder = function(memo, pathItem) {
        memo[pathItem] = memo[pathItem] || {};
        return memo[pathItem];
      };

      for(var i = 0; i < filterElements.length; i++) {
        var el = filterElements[i];
        var path = el.attributes.filter.value;
        path = path && path.split('.');

        var key = path.pop();
        var cursor = path.reduce(pathSeeder, filterObject);

        if (typeof el.checked !== 'undefined') {
          cursor[key] = cursor[key] || [];
          if (el.checked) {
            cursor[key].push(el.value);
          }
        } else {
          cursor[key] = el.values ? el.values.slice() : el.value;
        }
      }

      //Check if the filter Object has selected elements
      if(this.button) {
        var isActive = false;
        for(var f in filterObject) {
          var value = filterObject[f];
          if(value && value.length > 0) {
            isActive = true;
            break;
          }
        }

        this.button.isActive = isActive;
      }

      this.value = filterObject;
      this.close();
    },

    // TODO: This is approximately correct
    resetValues: function() {
      var filterElements = this.querySelectorAll('[filter]');

      var pathReducer = function(memo, pathItem) {
        return memo && memo[pathItem];
      };

      for(var i = 0; i < filterElements.length; i++) {
        var el = filterElements[i];
        var path = el.attributes.filter.value;
        path = path && path.split('.');

        var cursor = path.reduce(pathReducer, this.value);
        if (!cursor) {
          continue;
        }

        if (typeof el.checked !== 'undefined') {
          el.checked = cursor &&
            cursor.indexOf(el.attributes.value.value) !== -1;
        } else if (el.values) {
          el.values = (cursor || []).slice();
        } else {
          el.value = cursor;
        }

        // Coral elements frequently do not trigger change events programatically
        // TODO: Take this out if it breaks something
        if (el instanceof Coral.Component) {
          var eventPayload = {};
          if (typeof el.checked !== 'undefined') {
            eventPayload.checked = el.checked;
          }
          if (typeof el.values !== 'undefined') {
            eventPayload.values = el.values;
          }
          if (typeof el.value !== 'undefined') {
            eventPayload.value = el.value;
          }
          el.trigger('change', eventPayload);
        }
      }
      this.trigger('aeon:filter:close');
      this.close();
    },

    _isEmpty: function(value) {
      value = value || this.value;
      if (Array.isArray(value)) {
        return value.length === 0;
      } else {
        var isEmpty = true;
        for(var key in value) {
          if (value.hasOwnProperty(key)) {
            if (Array.isArray(value[key])) {
              isEmpty = isEmpty && value[key].length === 0;
              continue;
            }
            isEmpty = isEmpty && this._isEmpty(value[key]);
          }
        }
        return isEmpty;
      }
    },

    /** @private */
    _render: function() {
      // compatibility with CoralUI
      this.$ = $(this);
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  Coral.register({
    name: 'UserFilters',
    namespace: window.Aeon,
    tagName: 'aeon-userfilters',
    className: 'aeon-UserFilters',
    extend: window.Aeon.Filters
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  var TAG_NAME    = 'aeon-settings';
  var CLASS_NAME  = 'aeon-Settings';

  var NamedSegmentCollection = function(name) {
    window.Aeon.SegmentCollection.call(this);
    this._name = name;
  };

  NamedSegmentCollection.prototype = Object.create(window.Aeon.SegmentCollection.prototype);

  var SegmentCollectionSet = function(el) {
    this._segmentCollections = [];
    this._el = el;
  };

  SegmentCollectionSet.prototype.add = function(name, segments) {
    var segmentCollection = new NamedSegmentCollection(name);
    for (var i = 0; i < segments.length; i += 1) {
      segmentCollection.add(segments[i]);
    }

    this._segmentCollections.push(segmentCollection);

    if (this._el) {
      this._el.items.add({
        content: {
          innerHTML: name
        }
      });
    }
  };

  SegmentCollectionSet.prototype.findByName = function(name) {
    for (var i = 0; i < this._segmentCollections.length; i += 1) {
      if (this._segmentCollections[i]._name === name) {
        return this._segmentCollections[i];
      }
    }
  };

  SegmentCollectionSet.prototype.each = function(fn) {
    for (var i = 0; i < this._segmentCollections.length; i += 1) {
      fn(this._segmentCollections[i]._name, this._segmentCollections[i]);
    }
  };

  Coral.register({
    name: 'Settings',
    namespace: window.Aeon,
    tagName: TAG_NAME,
    className: CLASS_NAME,
    extend: window.Aeon.Filters,

    properties: {
      'size': {
        default: 'M',
        reflectAttribute: true,
        transform: Coral.transform.string,
        sync: function() {
          this.value = this.value && $.extend(true, {}, this.value) || {};
          this.value.size = [this.size];
          this.resetValues();
        }
      },
      'groups': {
        get: function() {
          if(!this._groups) {
            this._groups = new SegmentCollectionSet(this._elements.group);
          }
          return this._groups;
        },
        set: function() {}
      },
      'groupBy': {
        default: '',
        reflectAttribute: true,
        transform: Coral.transform.string,
        sync: function() {
          this.value = this.value && $.extend(true, {}, this.value) || {};
          this.value.group = [this.groupBy];

          // TODO: This will be an i18n problem
          if (this.value.group && this.value.group[0] !== 'None') {
            this.value.enablegroup = ['enabled'];
          }
          this.resetValues();
        }
      }
    },

    events: {
      'change [handle="enablegroup"]': '_toggleGroupDropdown'
    },

    _toggleGroupDropdown: function(event) {
      if (!event.target.checked) {
        this._elements.group.value = '';
      }
      this._elements.group.disabled = !event.target.checked;
    },

    _render: function() {
      var template = Coral.templates.Aeon.settings.call(this._elements);
      this.appendChild(template);
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  var TAG_NAME = 'aeon-navigator';
  var CLASS_NAME = 'aeon-Navigator';

  Coral.register({
    name: 'Navigator',
    namespace: window.Aeon,
    tagName: TAG_NAME,
    className: CLASS_NAME,

    properties: {
      start: {
        set: function(date){
          this._start = moment(date);
        },
        get: function() {
          return this._start;
        }
      },
      end: {
        set: function(date){
          this._end = moment(date);
        },
        get: function() {
          return this._end;
        }
      },
      pointer: {
        set: function(pointer) {
          this._pointer = pointer;
        },
        get: function() {
          return this._pointer;
        }
      },
      numOfColumns: {
        default: 7
      }
    },

    events:{
      'click [handle="today"]': '_setPointerToHead',
      'click [handle="previous"]': '_setPointerToPrevious',
      'click [handle="next"]': '_setPointerToNext'
    },

    render: function(opts) {
      if(typeof opts === 'object') {
        this.set(opts);
      }

      var viewRangeStart = moment(this.pointer);
      var viewRangeEnd = viewRangeStart.clone().add(this.numOfColumns-1, 'days');

      if(this.start.isAfter(viewRangeStart) && this.start.isBefore(viewRangeEnd) || this.start.isSame(viewRangeStart) || this.start.isSame(viewRangeEnd)) {
        this._elements.previous.setAttribute('disabled', 'disabled');
      }

      if((this.end.isAfter(viewRangeStart) && this.end.isBefore(viewRangeEnd)) || this.end.isSame(viewRangeStart) || this.end.isSame(viewRangeEnd)) {
        this._elements.next.setAttribute('disabled', 'disabled');
      }
    },

    _setPointerToHead: function(){
      return;
    },

    _setPointerToNext: function(){
      this._movePointer('add');
    },

    _setPointerToPrevious: function(){
      this._movePointer('subtract');
    },

    _movePointer: function(operation) {
      var cursor = moment(this._pointer)[operation](this.numOfColumns, 'days');

      this.pointer = (cursor.isBefore(this.start) ? this.start : cursor).format('YYYY-MM-DD');
      this.trigger('aeon:navigator:paginate', {pointer: this.pointer});
    },

    _render: function() {
      var template = Coral.templates.Aeon.navigator.call(this._elements);
      this.appendChild(template);
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';
  
  /** @ignore */
  function toMoment(value, format) {
    if (value === 'today') {
      return moment().startOf('day');
    }
    else if (moment.isMoment(value)) {
      return value.isValid() ? value.clone() : null;
    }
    else {
      // if the value provided is a date it does not make sense to provide a format to parse the date
      var result = moment(value, value instanceof Date ? null : format);
      return result.isValid() ? result : null;
    }
  }
  
  /** @ignore */
  function noop() {
  }
  
  /**
   Slides in new month tables, slides out old tables, and then cleans up the leftovers when it is done.
   @ignore
   */
  function TableAnimator(host) {
    this.host = host;
    
    this._addContainerIfNotPresent = function(width, height) {
      if (!this.container) {
        // Get a fresh container for the animation:
        Coral.templates.Aeon.container.call(
          this,
          {
            width: width,
            height: height
          }
        );
        this.host.appendChild(this.container);
      }
    };
    
    this._removeContainerIfEmpty = function() {
      if (this.container && this.container.children.length === 0) {
        this.host.removeChild(this.container);
        this.container = null;
      }
    };
    
    this.slide = function(newTable, direction) {
      var replace = direction === undefined;
      
      var oldTable = this.oldTable;
      
      // Should the replace flag be raised, or no old table be present, then do a non-transitioned (re)place and exit
      if (replace || !oldTable) {
        if (oldTable) {
          oldTable.parentNode.removeChild(oldTable);
        }
        this.host.insertBefore(newTable, this.host.firstChild);
        this.oldTable = newTable;
        return;
      }
      
      var boundingClientRect = oldTable.getBoundingClientRect();
      var width = boundingClientRect.width;
      var height = boundingClientRect.height;
      this._addContainerIfNotPresent(width, height);
      
      // Add both the old and the new table to the container:
      this.container.appendChild(oldTable);
      this.container.appendChild(newTable);
      
      oldTable.parentNode.removeChild(oldTable);
      this._removeContainerIfEmpty();
      
      this.host.appendChild(newTable);
      this._removeContainerIfEmpty();
      
      this.oldTable = newTable;
    };
  }
  
  /** @ignore */
  var ARRAYOF6 = [0, 0, 0, 0, 0, 0];
  
  /** @ignore */
  var ARRAYOF7 = [0, 0, 0, 0, 0, 0, 0];
  
  /** @ignore */
  var INTERNAL_FORMAT = 'YYYY-MM-DD';
  
  /** @ignore */
  var timeUnit = {
    'YEAR': 'year',
    'MONTH': 'month',
    'WEEK': 'week',
    'DAY': 'day'
  };

  var TAG_NAME = 'aeon-calendar';
  var CLASS_NAME = 'aeon-Calendar';
  var MONTH_TYPES = {
    MIN_MONTH: 'aeon-DateSelector-minMonth',
    MAX_MONTH: 'aeon-DateSelector-maxMonth',
    TRANSIENT_MONTH: 'aeon-DateSelector-transientMonth'
  };

  function isDateInRange(date, startDate, endDate) {
    if (startDate === null && endDate === null) {
      return true;
    }
    else if (startDate === null) {
      return date <= endDate;
    }
    else if (endDate === null) {
      return date >= startDate;
    }
    else {
      return startDate <= date && date <= endDate;
    }
  }

  function validateAsChangedAndValidMoment(newValue, oldValue) {
    // if the value is undefined we change it to null since moment considers both to be different
    newValue = newValue || null;
    oldValue = oldValue || null;

    if (newValue !== oldValue && !moment(newValue).isSame(oldValue, 'day')) {
      return newValue === null || newValue.isValid();
    }

    return false;
  }

  Coral.register({
    name: 'Calendar',
    namespace: window.Aeon,
    tagName: TAG_NAME,
    className: CLASS_NAME,

    properties: {
      /**
       Defines the start day for the week, 0 = Sunday, 1 = Monday etc., as depicted on the calendar days grid.
       @type {Number}
       @default 0
       @htmlattribute startday
       @memberof Aeon.Calendar#
       */
      'startDay': {
        default: typeof moment !== 'undefined' ? ((moment.localeData(Coral.i18n.locale) && typeof moment.localeData(Coral.i18n.locale).firstDayOfWeek !== 'undefined') ? moment.localeData(Coral.i18n.locale).firstDayOfWeek() : 0) : 0,
        attribute: 'startday',
        transform: Coral.transform.number,
        validate: [
          Coral.validate.valueMustChange,
          function(value) {
            return value >= 0 && value < 7;
          }
        ],
        sync: noop,
        alsoSync: ['_renderCalendarFlag']
      },
  
      /**
       The format used to display the current month and year. See http://momentjs.com/docs/#/displaying/ for valid
       format string options.
       @type {String}
       @default "MMMM YYYY"
       @htmlattribute headerformat
       @memberof Aeon.Calendar#
       */
      'headerFormat': {
        default: 'MMMM YYYY',
        attribute: 'headerformat',
        sync: noop,
        alsoSync: ['_renderCalendarFlag']
      },
  
      /**
       The minimal selectable date in the Calendar view. When passed a string, it needs to be 'YYYY-MM-DD' formatted.
       @type {String|Date}
       @default null
       @htmlattribute min
       @memberof Aeon.Calendar#
       */
      'min': {
        default: null,
        transform: function(value) {
          return toMoment(value, this.valueFormat);
        },
        validate: validateAsChangedAndValidMoment,
        get: function() {
          return this._min ? this._min.toDate() : null;
        },
        sync: noop,
        alsoSync: ['_renderCalendarFlag']
      },
  
      /**
       The max selectable date in the Calendar view. When passed a string, it needs to be 'YYYY-MM-DD'
       formatted.
       @type {String|Date}
       @default null
       @htmlattribute max
       @memberof Aeon.Calendar#
       */
      'max': {
        default: null,
        transform: function(value) {
          return toMoment(value, this.valueFormat);
        },
        validate: validateAsChangedAndValidMoment,
        get: function() {
          return this._max ? this._max.toDate() : null;
        },
        sync: noop,
        alsoSync: ['_renderCalendarFlag']
      },
  
      /**
       The format to use on expressing the selected date as a string on the <code>value</code> attribute. See
       http://momentjs.com/docs/#/displaying/ for valid format string options.
       @type {String}
       @default "YYYY-MM-DD"
       @htmlattribute valueformat
       @htmlattributereflected
       @memberof Aeon.Calendar#
       */
      'valueFormat': {
        default: 'YYYY-MM-DD',
        attribute: 'valueformat',
        reflectAttribute: true,
        set: function(value) {
          this._valueFormat = value;
          this._elements.input.value = this.value;
        }
      },
  
      /**
       The current value. When set to 'today', the value is coerced into the clients local date expressed as string
       formatted in accordance to the set <code>valueFormat</code>.
       @type {String}
       @default ""
       @fires Aeon.Calendar#change
       @htmlattribute value
       @memberof Aeon.Calendar#
       */
      'value': {
        default: '',
        transform: function(value) {
          return toMoment(value, this.valueFormat);
        },
        validate: function(newVal, oldVal) {
          return validateAsChangedAndValidMoment(newVal, this._value);
        },
        get: function() {
          return this._value ? this._value.format(this.valueFormat) : '';
        },
        set: function(value) {
          this._value = value;
          this._elements.input.value = this.value;
      
          // resets the view cursor, so the selected month will be in view
          this._cursor = null;
      
          this._queueSync('_renderCalendarFlag', 'required');
        }
      },
  
      /**
       The value returned, or set, as a Date. If the value is '' it will return <code>null</code>.
       @type {Date}
       @default null
       @memberof Aeon.Calendar#
       */
      'valueAsDate': {
        attribute: null,
        transform: function(value) {
          return (value instanceof Date) ? moment(value) : '';
        },
        get: function() {
          return this._value ? this._value.toDate() : null;
        },
        set: function(value) {
          this.value = value;
        }
      },
  
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       @memberof Aeon.Calendar#
       */
      'name': {
        default: '',
        reflectAttribute: true,
        transform: Coral.transform.string,
        get: function() {
          return this._elements.input.name;
        },
        set: function(value) {
          this._elements.input.name = value;
        }
      },
  
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       This is ignored for checkbox, radio or fileupload.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       @memberof Aeon.Calendar#
       */
      'readOnly': {
        default: false,
        reflectAttribute: true,
        attribute: 'readonly',
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.setAttribute('aria-readonly', this.readOnly);
        }
      },
  
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       @memberof Aeon.Calendar#
       */
      'required': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle('is-required', this.required && this._value === null);
        }
      },
  
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       @memberof Aeon.Calendar#
       */
      'disabled': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle('is-disabled', this.disabled);
          this._elements.prev.disabled = this.disabled;
          this._elements.next.disabled = this.disabled;
          this._elements.body.setAttribute('aria-disabled', this.disabled);
          this._elements.body[this.disabled ? 'removeAttribute' : 'setAttribute']('tabindex', '0');
        },
        // Have the view reflect the disabled state change (in disabled state, all day buttons become span's
        alsoSync: ['_renderCalendarFlag']
      },
  
      /**
       Whether the current value of this field is invalid or not.
       @type {Boolean}
       @default false
       @htmlattribute invalid
       @htmlattributereflected
       @memberof Aeon.Calendar#
       */
      'invalid': {
        efault: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        sync: function() {
          this.classList.toggle('is-invalid', this.invalid);
        },
        // If the selected date is on display, the view needs to reflect it being invalid
        alsoSync: ['_renderCalendarFlag']
      },
  
      /**
       Internal property that other properties use via `alsoSync` to schedule a calendar redraw. It makes sure that
       `_renderCalendar` is invoked only once per frame as a result of `alsoSync` invoking `Component._queueSync` that
       removes duplicate entries for the given property (`_renderCalendarFlag` in this case), maintaining only the last
       one added.
       @ignore
       */
      '_renderCalendarFlag': {
        attribute: null,
        sync: function() {
          this._renderCalendar();
        }
      },
      
      disableleftpagination: {
        default: '',
        reflectAttribute: true
      },
      disablerightpagination: {
        default: '',
        reflectAttribute: true
      },
      leftpaginationoffset: {
        default: 1,
        reflectAttribute: true,
        transform: Coral.transform.number
      },
      rightpaginationoffset: {
        default: 1,
        reflectAttribute: true,
        transform: Coral.transform.number
      }
    },

    events: {
      'click .aeon-Calendar-nextMonth,.aeon-Calendar-prevMonth': '_onNextOrPreviousMonthClick',
      'click .aeon-Calendar-calendarBody .aeon-Calendar-date': '_onDayClick',
      'key:up .aeon-Calendar-calendarBody': '_onUpKey',
      'key:right .aeon-Calendar-calendarBody': '_onRightKey',
      'key:down .aeon-Calendar-calendarBody': '_onDownKey',
      'key:left .aeon-Calendar-calendarBody': '_onLeftKey',
      'key:home .aeon-Calendar-calendarBody': '_onHomeOrEndKey',
      'key:end .aeon-Calendar-calendarBody': '_onHomeOrEndKey',
      'key:pageup': '_onPageUpKey',
      'key:pagedown': '_onPageDownKey',
  
      'key:meta+pageup': '_onCtrlPageUpKey', // On OSX we use Command+Page Up
      'key:meta+pagedown': '_onCtrlPageDownKey', // On OSX we use Command+Page Down
      'key:ctrl+pageup': '_onCtrlPageUpKey', // On Windows, we use CTRL+Page Up
      'key:ctrl+pagedown': '_onCtrlPageDownKey', // On Windows, we use CTRL+Page Down
  
      'key:enter .aeon-Calendar-calendarBody': '_onEnterKey',
      'key:space .aeon-Calendar-calendarBody': '_onEnterKey',
      
      'global:reset': '_onFormReset',
      
      'mousedown .aeon-Calendar-calendarBody .aeon-Calendar-date': '_onDayClick'
    },
  
    /**
     Resets the formField when a reset is triggered on the parent form.
     @protected
     @memberof Aeon.Calendar#
     */
    _onFormReset: function(event) {
      if (event.target.contains(this)) {
        this.reset();
      }
    },
  
    /**
     Resets the <code>value</code> to the initial value.
     */
    reset: function() {
      // since the 'value' property is not reflected, form components use it to restore the initial value. When a
      // component has support for values, this method needs to be overwritten
      this.value = Coral.transform.string(this.getAttribute('value'));
    },
    
    /**
     Clears the <code>value</code> of formField to the default value.
     */
    clear: function() {
      this.value = '';
    },
  
    /**
     sets focus to appropriate descendant
     */
    focus: function() {
      if (!this.contains(document.activeElement) && !this.disabled) {
        this._setActiveDescendant();
        this._elements.body.focus();
      }
    },
  
    /** @ignore */
    _render: function() {
      // Clean Up (cloneNode support)
      while (this.firstChild) {
        this.removeChild(this.firstChild);
      }
      this.appendChild(Coral.templates.Aeon.calendar.call(this._elements));
    },
  
    /** @ignore */
    _initialize: function() {
      // Internal keeper of the month that is currently on display.
      this._cursor = null;
    
      // Internal keeper for the id of the currently focused date cell or the cell that would receive focus when the
      // calendar body receives focus.
      this._activeDescendant = null;
      this._animator = new TableAnimator(this._elements.body);
      this.setAttribute('role', 'region');
    },
  
    /** @ignore */
    _renderCalendar: function(slide) {
      var cursor = this._requireCursor();
      var displayYear = cursor.year();
      var displayMonth = cursor.month();
      var self = this;
      var oldTable = this._animator.oldTable;
    
      this._elements.heading.innerHTML = moment([displayYear, displayMonth, 1]).format(this.headerFormat);
    
      var newTable = this._renderTable(displayYear, displayMonth + 1);
      this.togglePaginationArrows();
    
      if (oldTable) {
        Coral.commons.transitionEnd(newTable, function() {
          Coral.commons.nextFrame(function() {
            self._setActiveDescendant();
          });
        });
      }
    
      this._animator.slide(newTable, slide);
    
      var el = this._elements.body.querySelector('.is-selected');
      var selectedId = el ? el.id : null;
    
      // This will be overwritten later if there is any other function setting the attribute
      this._activeDescendant = selectedId;
    
      this._setActiveDescendant();
    },
  
    /**
     Returns <code>true</code> if moment specified is before <code>min</code>.
     @param {moment} currentMoment
     A moment to test.
     @param {String} unit
     Year, Month, Week, Day
     @returns {Boolean}
     <code>true</code> if moment specified is before <code>min</code>
     @ignore
     */
    _isBeforeMin: function(currentMoment, unit) {
      var min = this.min ? moment(this.min) : null;
      return min && currentMoment.isBefore(min, unit);
    },
  
    /**
     Returns <code>true</code> if moment specified is after <code>max</code>.
     @param {moment} currentMoment
     A moment to test.
     @param {String} unit
     Year, Month, Week, Day
     @returns {Boolean}
     <code>true</code> if moment specified is after <code>max</code>
     @ignore
     */
    _isAfterMax: function(currentMoment, unit) {
      var max = this.max ? moment(this.max) : null;
      return max && currentMoment.isAfter(max, unit);
    },
  
    /**
     Returns <code>true</code> if moment specified is greater than or equal to <code>min</code> and less than or equal to <code>max</code>.
     @param {moment} currentMoment
     A moment to test.
     @param {String} unit
     Year, Month, Week, Day
     @returns {Boolean}
     <code>true</code> if moment specified falls within <code>min</code>/<code>max</code> date range.
     @ignore
     */
    _isInRange: function(currentMoment, unit) {
      return !(this._isBeforeMin(currentMoment, unit) || this._isAfterMax(currentMoment, unit));
    },
  
    /**
     Updates the aria-activedescendant property for the calendar grid to communicate the currently focused date, or the
     date that should get focus when the grid receives focus, to assistive technology.
     @ignore
     */
    _setActiveDescendant: function() {
      var el;
    
      if (!this._activeDescendant || !this._elements.body.querySelector('#' + this._activeDescendant + ' [data-date]')) {
        this._activeDescendant = null;
        el = this._elements.body.querySelector('.is-selected');
        var selectedId = el ? el.id : null;
        el = this._elements.body.querySelector('.is-today');
        var todayId = el ? el.id : null;
      
        this._activeDescendant = selectedId || todayId;
      
        if (!this._activeDescendant ||
          !this._elements.body.querySelector('#' + this._activeDescendant + ' [data-date]')
        ) {
          var currentMoment = this._value;
        
          if (currentMoment) {
            var dates = this._elements.body.querySelectorAll('[data-date]');
            if (dates.length) {
              if (this._isBeforeMin(currentMoment)) {
                el = dates[0];
              }
              else if (this._isAfterMax(currentMoment)) {
                el = dates[dates.length - 1];
              }
            }
          }
        
          if (el) {
            this._activeDescendant = el.parentElement.id;
          }
        }
      }
    
      el = this._elements.body.querySelector('.is-focused');
      if (el) {
        el.classList.remove('is-focused');
      }
    
      this._elements.body.setAttribute('aria-activedescendant', this._activeDescendant);
    
      this._updateTableCaption();
    
      if (!this._activeDescendant) {
        return;
      }
    
      el = document.getElementById(this._activeDescendant);
      if (el) {
        el.classList.add('is-focused');
      }
    },
  
    /** @ignore */
    _onEnterKey: function(event) {
      event.preventDefault();
    
      var el = this._elements.body.querySelector('td.is-focused .aeon-Calendar-date');
    
      if (el) {
        el.click();
      }
    
      this._validateCalendar();
    },
  
    /** @ignore */
    _onUpKey: function(event) {
      event.preventDefault();
    
      this._gotoPreviousOrNextTimeUnit(timeUnit.WEEK, false);
      this._validateCalendar();
    },
  
    /** @ignore */
    _onDownKey: function(event) {
      event.preventDefault();
    
      this._gotoPreviousOrNextTimeUnit(timeUnit.WEEK, true);
      this._validateCalendar();
    },
  
    /** @ignore */
    _onRightKey: function(event) {
      event.preventDefault();
    
      this._gotoPreviousOrNextTimeUnit(timeUnit.DAY, true);
      this._validateCalendar();
    },
  
    /** @ignore */
    _onLeftKey: function(event) {
      event.preventDefault();
    
      this._gotoPreviousOrNextTimeUnit(timeUnit.DAY, false);
      this._validateCalendar();
    },
  
    /** @ignore */
    _onHomeOrEndKey: function(event) {
      event.preventDefault();
      var isHome = event.keyCode === Coral.Keys.keyToCode('home');
      var direction = '';
      var operator = isHome ? 'subtract' : 'add';
      var el = this._elements.body.querySelector('td.is-focused .aeon-Calendar-date');
    
      if (el) {
        var currentActive = el.dataset.date;
        var currentMoment = moment(currentActive);
        var difference = isHome ? currentMoment.date() - 1 : currentMoment.daysInMonth() - currentMoment.date();
        this._getToNewMoment(event, direction, operator, difference);
        this._setActiveDescendant();
      }
    
      this._validateCalendar();
    },
  
    /** @ignore */
    _onPageDownKey: function(event) {
      event.preventDefault();
      this._gotoPreviousOrNextTimeUnit(timeUnit.MONTH, true);
      this._validateCalendar();
    },
  
    /** @ignore */
    _onPageUpKey: function(event) {
      event.preventDefault();
      this._gotoPreviousOrNextTimeUnit(timeUnit.MONTH, false);
      this._validateCalendar();
    },
  
    /** @ignore */
    _onCtrlPageDownKey: function(event) {
      event.preventDefault();
      this._gotoPreviousOrNextTimeUnit(timeUnit.YEAR, true);
      this._validateCalendar();
    },
  
    /** @ignore */
    _onCtrlPageUpKey: function(event) {
      event.preventDefault();
      this._gotoPreviousOrNextTimeUnit(timeUnit.YEAR, false);
      this._validateCalendar();
    },
    
    _onDayClick: function(event) {
      event.stopPropagation();

      this._elements.body.focus();

      var date = moment(event.target.getAttribute('data-date'), 'YYYY-MM-DD');
      this._setDate(date);
    },

    _setDate: function(selectedDate) {
      var dateLocal;

      // Carry over any user set time info
      if (this._value) {
        dateLocal = this._value.clone();
      }

      // Set attribute so a change event will be triggered if the user has selected a different date
      if (validateAsChangedAndValidMoment(selectedDate, dateLocal)) {
        this.value = selectedDate.local();
        this.trigger('change');
      }

      this._validateCalendar();
      this.trigger('aeon:calendar:dayClick', {value: this.value, calendar: this.getAttribute('handle')});
    },

    _onNextOrPreviousMonthClick: function(event) {
      event.preventDefault();

      var isNext = (this._elements.next === event.matchedTarget);
      var offset = (isNext ? this.rightpaginationoffset : this.leftpaginationoffset);

      this._gotoPreviousOrNextTimeUnit('month', isNext, offset);
      event.matchedTarget.focus();
      this._validateCalendar();
      this.trigger('aeon:calendar:paginate', {isNext: isNext});
    },

    _validateCalendar: function() {
      this.invalid = !(this._value === null || isDateInRange(this._value, this.min, this.max));
    },

    _updateTableCaption: function() {
      var self = this;
      var caption = self._elements.body.querySelector('caption');
  
      if (!caption) {
        return;
      }
  
      if (caption.firstChild) {
        caption.removeChild(caption.firstChild);
      }
      if (this._activeDescendant) {
        var activeDescendant = this._elements.body.querySelector('#' + this._activeDescendant);
        var captionText = document.createTextNode(activeDescendant.getAttribute('title'));
        caption.appendChild(captionText);
      }
      
      this.trigger('aeon:calendar:render', {calendar: this.getAttribute('handle')});
    },

    _gotoPreviousOrNextTimeUnit: function(unit, isNext, offset) {
      var direction = isNext ? 'left' : 'right';
      var operator = isNext ? 'add' : 'subtract';
      var el = this._elements.body.querySelector('td.is-focused .aeon-Calendar-date');
      var newOffset = (typeof offset !== 'undefined' ? offset : (isNext ? this.rightpaginationoffset : this.leftpaginationoffset) );

      if (el) {
        var currentActive = el.getAttribute('data-date');
        var currentMoment = moment(currentActive);
        var newMoment = currentMoment[operator](newOffset, unit);
        var difference = Math.abs(moment(currentActive).diff(newMoment, 'days'));
        this._getToNewMoment(null, direction, operator, difference, newOffset);
        this._setActiveDescendant();
      }
      else {
        this._requireCursor();
        this._cursor[operator](newOffset, unit);
        this._renderCalendar(direction);
      }
    },
    
    _getToNewMoment: function(event, direction, operator, difference, offset) {
      var currentActive = this._elements.body.querySelector('td.is-focused .aeon-Calendar-date')
          .getAttribute('data-date');
      var currentMoment = moment(currentActive);
      var currentMonth = currentMoment.month();
      var currentYear = currentMoment.year();
      var newMoment = currentMoment[operator](difference, 'days');
      var newMonth = newMoment.month();
      var newYear = newMoment.year();
      var newMomentValue = newMoment.local().format('YYYY-MM-DD');

      if (newMonth !== currentMonth) {
        this._requireCursor({
          override: true,
          currentMoment: currentMoment
        });
        this._cursor[operator](offset, 'months');
        this._renderCalendar(direction);
      }
      else if (newMonth === currentMonth && newYear !== currentYear) {
        this._requireCursor();
        this._cursor[operator](1, 'years');
        this._renderCalendar(direction);
      }

      var dateQuery = '.aeon-Calendar-date[data-date^=' + JSON.stringify(newMomentValue) + ']';
      var newDescendant = this._elements.body.querySelector(dateQuery);
      if (newDescendant) {
        var newDescendantId = newDescendant.parentNode.getAttribute('id');
        this._activeDescendant = newDescendantId;
      }
    },

    _gotoMonthYear: function(month, year) {
      var cursor = moment([year, month, 1]);
      var displayYear = cursor.year();
      var displayMonth = cursor.month();

      this._elements.heading.innerHTML = moment([displayYear, displayMonth, 1]).format(this.headerFormat);

      var newTable = this._renderTable(displayYear, displayMonth + 1);
      this.togglePaginationArrows();

      this._animator.slide(newTable);

      var el = this._elements.body.querySelector('.is-selected');
      var selectedId = el ? el.id : null;

      // This will be overwritten later if there is any other function setting the attribute
      this._activeDescendant = selectedId;
      this._setActiveDescendant();
      this.value = cursor;
    },

    _requireCursor: function(opts) {
      var cursor = this._cursor;
      var overrideOpts = (typeof opts !== 'undefined' ? opts : {});

      if (!cursor || !cursor.isValid()) {
        // When its unknown what month we should be showing, use the set date. If that is not available, use 'today'
        cursor = (this._value ? this._value.clone().startOf('day') : moment()).startOf('month');
        this._cursor = cursor;
      } else if(overrideOpts.override && overrideOpts.currentMoment) {
        this._cursor = overrideOpts.currentMoment.startOf('month');
      }

      return cursor;
    },

    _renderTable: function(year, month) {
      var firstDate = moment([year, month - 1, 1]);
      var monthStartsAt = (firstDate.day() - this.startDay) % 7;
      var dateLocal = this._value ? this._value.clone().startOf('day') : null;
  
      if (monthStartsAt < 0) {
        monthStartsAt += 7;
      }
  
      var data = {
    
        dayNames: ARRAYOF7.map(
          function(_, index, days) {
            var dayMoment = moment().day((index + this.startDay) % 7);
            var dayDetail = {
              dayAbbr: dayMoment.format('dd'),
              dayFullName: dayMoment.format('dddd')
            };
            return dayDetail;
          },
          this),
    
        weeks: ARRAYOF6.map(
          function(_, weekIndex) {
            return ARRAYOF7.map(
              function(_, dayIndex) {
                var result = {};
                var cssClass = this.disabled ? ['is-disabled'] : [];
                var ariaSelected = false;
                var ariaInvalid = false;
                var day = (weekIndex * 7 + dayIndex) - monthStartsAt;
                var cursor = moment([year, month - 1]);
                // we use add() since 'day' could be a negative value
                cursor.add(day, 'days');
            
                var isCurrentMonth = (cursor.month() + 1) === parseFloat(month);
                var dayOfWeek = moment().day((dayIndex + this.startDay) % 7).format('dddd');
                var isToday = cursor.isSame(moment(), 'day');
            
                var cursorLocal = cursor.clone().startOf('day');
            
                if (isToday) {
                  cssClass.push('is-today');
                }
            
                if (dateLocal && cursorLocal.isSame(dateLocal, 'day')) {
                  ariaSelected = true;
                  cssClass.push('is-selected');
                  if (this.invalid) {
                    ariaInvalid = true;
                    cssClass.push('is-invalid');
                  }
                }
            
                if (isCurrentMonth) {
                  cssClass.push('is-currentMonth');
                  if (!this.disabled && isDateInRange(cursor, this.min, this.max)) {
                    result.dateAttr = cursorLocal.local().format(INTERNAL_FORMAT);
                    result.weekIndex = cursor.week();
                    result.formattedDate = cursor.format('LL');
                  }
                }
            
                result.isDisabled = this.disabled || !result.dateAttr;
                result.dateText = cursor.date();
                result.cssClass = cssClass.join(' ');
                result.isToday = isToday;
                result.ariaSelected = ariaSelected;
                result.ariaInvalid = ariaInvalid;
                result.dateLabel = dayOfWeek;
                result.weekIndex = cursor.week();
            
                return result;
              },
              this
            );
          },
          this)
      };
  
      var handles = {};
      Coral.templates.Aeon.table.call(handles, data);
      
      return handles.table;
    },

    togglePaginationArrows: function() {
      if(this.disableleftpagination === 'true') {
        this.querySelector('.aeon-Calendar-prevMonth').style.display = 'none';
      }
      if(this.disablerightpagination === 'true') {
        this.querySelector('.aeon-Calendar-nextMonth').style.display = 'none';
      }
    },

    toggleMonthAndDateClasses: function(min, max) {
      this.toggleMonthClass(min, max);
      this.toggleCalendarDateClass(min, max);
    },

    toggleCalendarDateClass: function(min, max) {
      var calendarBody = $(this).find('.aeon-Calendar-calendarBody');
      var calendarDays = $(this).find('.aeon-Calendar-date');
      var selectorMin = moment(min);
      var selectorMax = moment(max);
      var i, il, el, $el, date;

      if(calendarBody.hasClass(MONTH_TYPES.TRANSIENT_MONTH)) {
        return;
      }

      calendarBody.find('.is-selected').removeClass('is-selected');

      for(i = 0, il = calendarDays.length; i < il; i++) {
        el = calendarDays[i];
        date = moment(el.getAttribute('data-date'));
        $el = $(el);

        $el.removeClass('aeon-Calendar-inDateRange');
        $el.parent().removeClass('is-selected');
        if(date.diff(selectorMin) > 0 && date.diff(selectorMax) < 0){
          $el.addClass('aeon-Calendar-inDateRange');
        }
        if(date.diff(selectorMin) === 0 || date.diff(selectorMax) === 0) {
          $el.parent().addClass('is-selected');
        }
      }
    },

    toggleMonthClass: function(min, max) {
      var monthClass = this.getMonthClass(min, max);
      $(this).find('.aeon-Calendar-calendarBody').removeClass('aeon-DateSelector-minMonth aeon-DateSelector-maxMonth aeon-DateSelector-transientMonth');

      if(monthClass) {
        $(this).find('.aeon-Calendar-calendarBody').addClass(monthClass);
      }
    },

    getMonthClass: function(min, max) {
      this._requireCursor();
      var monthVal = this._cursor._d.getMonth();
      var minMonthVal = moment(min).month();
      var maxMonthVal = moment(max).month();
      var classList = [];

      if(monthVal > minMonthVal && monthVal < maxMonthVal) {
        classList.push(MONTH_TYPES.TRANSIENT_MONTH);
      }
      if(monthVal === minMonthVal) {
        classList.push(MONTH_TYPES.MIN_MONTH);
      }
      if(monthVal === maxMonthVal) {
        classList.push(MONTH_TYPES.MAX_MONTH);
      }

      return classList.join(' ');
    }
  });
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  var TAG_NAME = 'aeon-datepopover';
  var CLASS_NAME = 'aeon-DatePopover';
  var DEFAULT_DATE_FORMAT = 'YYYY-MM-DD';
  var JANUARY = 0, DECEMBER = 11;
  // The time it should take for overlays to fade in milliseconds
  // Important: This should be greater than or equal to the CSS transition time
  var FADETIME = 350;
  
  // The tab capture element that lives at the top of the body
  var topTabCaptureEl;
  var bottomTabCaptureEl;
  
  // A reference to the backdrop element
  var backdropEl;
  
  // The starting zIndex for overlays
  var startZIndex = 10000;
  
  // Tab keycode
  var TAB_KEY = 9;
  
  /**
   Focus trap options.
   @memberof Aeon.DatePopover
   @enum {String}
   */
  var trapFocus = {
    /** Focus is trapped such that the use cannot focus outside of the overlay. */
    ON: 'on',
    /** The user can focus outside the overlay as normal. */
    OFF: 'off'
  };
  
  /**
   Return focus options.
   @memberof Aeon.DatePopover
   @enum {String}
   */
  var returnFocus = {
    /** When the overlay is closed, the element that was focused before the it was shown will be focused again. */
    ON: 'on',
    /** Nothing will be focused when the overlay is closed. */
    OFF: 'off'
  };
  
  /**
   Focus behavior options.
   @memberof Aeon.DatePopover
   @enum {String}
   */
  var focusOnShow = {
    /** When the overlay is opened, it will be focused. */
    ON: 'on',
    /** The overlay will not focus itself when opened. */
    OFF: 'off'
  };
  
  // A stack interface for overlays
  var _overlays = [];
  var overlays = {
    pop: function(instance) {
      // Get overlay index
      var index = this.indexOf(instance);
      
      if (index === -1) {
        return null;
      }
      
      // Get the overlay
      var overlay = _overlays[index];
      
      // Remove from the stack
      _overlays.splice(index, 1);
      
      // Return the passed overlay or the found overlay
      return overlay;
    },
    
    push: function(instance) {
      // Pop overlay
      var overlay = this.pop(instance) || {
          instance: instance
        };
      
      // Get the new highest zIndex
      var zIndex = this.getHighestZIndex() + 10;
      
      // Store the zIndex
      overlay.zIndex = zIndex;
      instance.style.zIndex = zIndex;
      
      // Push it
      _overlays.push(overlay);
      
      if (overlay.backdrop) {
        // If the backdrop is shown, we'll need to reposition it
        // Generally, a component will not call _pushOverlay unnecessarily
        // However, attachedCallback is asynchronous in polyfilld environments,
        // so _pushOverlay will be called when shown and when attached
        doRepositionBackdrop();
      }
      
      return overlay;
    },
    
    indexOf: function(instance) {
      // Loop over stack
      // Find overlay
      // Return index
      for (var i = 0; i < _overlays.length; i++) {
        if (_overlays[i].instance === instance) {
          return i;
        }
      }
      return -1;
    },
    
    get: function(instance) {
      // Get overlay index
      var index = this.indexOf(instance);
      
      // Return overlay
      return index === -1 ? null : _overlays[index];
    },
    
    top: function() {
      var length = _overlays.length;
      return length === 0 ? null : _overlays[length - 1];
    },
    
    getHighestZIndex: function() {
      var overlay = this.top();
      return overlay ? overlay.zIndex : startZIndex;
    },
    
    some: function() {
      return _overlays.some.apply(_overlays, arguments);
    },
    
    forEach: function() {
      return _overlays.forEach.apply(_overlays, arguments);
    }
  };
  
  /**
   Hide the backdrop if no overlays are using it.
   */
  function hideOrRepositionBackdrop() {
    if (!backdropEl || !backdropEl._isOpen) {
      // Do nothing if the backdrop isn't shown
      return;
    }
    
    // Loop over all overlays
    var keepBackdrop = overlays.some(function(overlay) {
      // Check for backdrop usage
      if (overlay.backdrop) {
        return true;
      }
    });
    
    if (!keepBackdrop) {
      // Hide the backdrop
      doBackdropHide();
    }
    else {
      // Reposition the backdrop
      doRepositionBackdrop();
    }
    
    // Hide/create the document-level tab capture element as necessary
    // This only applies to modal overlays (those that have backdrops)
    var top = overlays.top();
    if (!top || !(top.instance.trapFocus === trapFocus.ON && top.instance._requestedBackdrop)) {
      hideDocumentTabCaptureEls();
    }
    else if (top && top.instance.trapFocus === trapFocus.ON && top.instance._requestedBackdrop) {
      createDocumentTabCaptureEls();
    }
  }
  
  /**
   Actually reposition the backdrop to be under the topmost overlay.
   */
  function doRepositionBackdrop() {
    // Position under the topmost overlay
    var top = overlays.top();
    
    if (top) {
      
      // The backdrop, if shown, should be positioned under the topmost overlay that does have a backdrop
      for (var i = _overlays.length - 1; i > -1; i--) {
        if (_overlays[i].backdrop) {
          backdropEl.style.zIndex = _overlays[i].zIndex - 1;
          break;
        }
      }
      
      // ARIA: Set hidden properly
      hideEverythingBut(top.instance);
    }
  }
  
  /**
   Cancel the backdrop hide mid-animation.
   */
  var fadeTimeout;
  function cancelBackdropHide() {
    clearTimeout(fadeTimeout);
  }
  
  /**
   Actually hide the backdrop.
   */
  function doBackdropHide() {
    document.body.classList.remove('aeon-noScroll');
    
    // Start animation
    Coral.commons.nextFrame(function() {
      backdropEl.classList.remove('is-open');
      
      cancelBackdropHide();
      fadeTimeout = setTimeout(function() {
        backdropEl.style.display = 'none';
      }, FADETIME);
    });
    
    // Set flag for testing
    backdropEl._isOpen = false;
    
    // Wait for animation to complete
    showEverything();
  }
  
  /**
   Actually show the backdrop.
   */
  function doBackdropShow(zIndex, instance) {
    document.body.classList.add('aeon-noScroll');
    
    if (!backdropEl) {
      backdropEl = document.createElement('div');
      backdropEl.className = 'aeon-Backdrop';
      document.body.appendChild(backdropEl);
      
      backdropEl.addEventListener('click', handleBackdropClick);
    }
    
    // Show just under the provided zIndex
    // Since we always increment by 10, this will never collide
    backdropEl.style.zIndex = zIndex - 1;
    
    // Set flag for testing
    backdropEl._isOpen = true;
    
    // Start animation
    backdropEl.style.display = '';
    Coral.commons.nextFrame(function() {
      // Add the class on the next animation frame so backdrop has time to exist
      // Otherwise, the animation for opacity will not work.
      backdropEl.classList.add('is-open');
      
      cancelBackdropHide();
    });
    
    hideEverythingBut(instance);
  }
  
  /**
   Handles clicks to the backdrop, calling backdropClickedCallback for every overlay
   */
  function handleBackdropClick(event) {
    overlays.forEach(function(overlay) {
      if (typeof overlay.instance.backdropClickedCallback === 'function') {
        overlay.instance.backdropClickedCallback(event);
      }
    });
  }
  
  /**
   Set aria-hidden on every immediate child except the one passed, which should not be hidden.
   */
  function hideEverythingBut(instance) {
    // ARIA: Hide all the things
    var children = document.body.children;
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      
      // If it's not a parent of or not the instance itself, it needs to be hidden
      if (child !== instance && !child.contains(instance)) {
        var currentAriaHidden = child.getAttribute('aria-hidden');
        if (currentAriaHidden) {
          // Store the previous value of aria-hidden if present
          // Don't blow away the previously stored value
          child._previousAriaHidden = child._previousAriaHidden || currentAriaHidden;
          if (currentAriaHidden === 'true') {
            // It's already true, don't bother setting
            continue;
          }
        }
        else {
          // Nothing is hidden by default, store that
          child._previousAriaHidden = 'false';
        }
        
        // Hide it
        child.setAttribute('aria-hidden', 'true');
      }
    }
    
    // Always show ourselves
    instance.setAttribute('aria-hidden', 'false');
  }
  
  /**
   Show or restore the aria-hidden state of every child of body.
   */
  function showEverything() {
    // ARIA: Show all the things
    var children = document.body.children;
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      // Restore the previous aria-hidden value
      child.setAttribute('aria-hidden', child._previousAriaHidden || 'false');
    }
  }
  
  /**
   Create the global tab capture element.
   */
  function createDocumentTabCaptureEls() {
    if (!topTabCaptureEl) {
      topTabCaptureEl = document.createElement('div');
      topTabCaptureEl.setAttribute('aeon-datepopover-tabcapture', '');
      topTabCaptureEl.tabIndex = 0;
      document.body.insertBefore(topTabCaptureEl, document.body.firstChild);
      topTabCaptureEl.addEventListener('focus', function(event) {
        var top = overlays.top();
        if (top && top.instance.trapFocus === trapFocus.ON) {
          // Focus on the first tabbable element of the top overlay
          Array.prototype.some.call(top.instance.querySelectorAll(Coral.commons.TABBABLE_ELEMENT_SELECTOR), function(item) {
            if (item.offsetParent !== null && !item.hasAttribute('aeon-datepopover-tabcapture')) {
              item.focus();
              return true;
            }
          });
        }
      });
      
      bottomTabCaptureEl = document.createElement('div');
      bottomTabCaptureEl.setAttribute('aeon-datepopover-tabcapture', '');
      bottomTabCaptureEl.tabIndex = 0;
      document.body.appendChild(bottomTabCaptureEl);
      bottomTabCaptureEl.addEventListener('focus', function(event) {
        var top = overlays.top();
        if (top && top.instance.trapFocus === trapFocus.ON) {
          var tabbableElement = Array.prototype.filter.call(top.instance.querySelectorAll(Coral.commons.TABBABLE_ELEMENT_SELECTOR), function(item) {
            return item.offsetParent !== null && !item.hasAttribute('aeon-datepopover-tabcapture');
          }).pop();
          
          // Focus on the last tabbable element of the top overlay
          if (tabbableElement) {
            tabbableElement.focus();
          }
        }
      });
    }
    else {
      if (document.body.firstElementChild !== topTabCaptureEl) {
        // Make sure we stay at the very top
        document.body.insertBefore(topTabCaptureEl, document.body.firstChild);
      }
      
      if (document.body.lastElementChild !== bottomTabCaptureEl) {
        // Make sure we stay at the very bottom
        document.body.appendChild(bottomTabCaptureEl);
      }
    }
    
    // Make sure the tab capture elemenst are shown
    topTabCaptureEl.style.display = 'inline';
    bottomTabCaptureEl.style.display = 'inline';
  }
  
  /**
   Called after all overlays are hidden and we shouldn't capture the first tab into the page.
   */
  function hideDocumentTabCaptureEls() {
    if (topTabCaptureEl) {
      topTabCaptureEl.style.display = 'none';
      bottomTabCaptureEl.style.display = 'none';
    }
  }

  function debounce(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
  }
  
  /**
   Re-position the overlay if it's currently open.
   @ignore
   */
  function repositionIfOpen() {
    /* jshint -W040 */
    if (this.open) {
      // Re-position accordingly
      this._position();
    }
  }
  
  /**
   Lowecase the passed string if it's a string, passthrough if not.
   @ignore
   */
  function transformAlignment(alignment) {
    // Just pass through non-strings
    return typeof alignment === 'string' ? alignment.toLowerCase() : alignment;
  }
  
  /**
   Valid alignment pairs.
   @enum {Object}
   @memberof Aeon.DatePopover
   */
  var align = {
    /** Use the top of the left side as an anchor point. */
    LEFT_TOP: 'left top',
    /** Use the center of the left side as an anchor point. */
    LEFT_CENTER: 'left center',
    /** Use the bottom of the left side as an anchor point. */
    LEFT_BOTTOM: 'left bottom',
    /** Use the center of the top side as an anchor point. */
    CENTER_TOP: 'center top',
    /** Use the center as an anchor point. */
    CENTER_CENTER: 'center center',
    /** Use the center of the bottom side as an anchor point. */
    CENTER_BOTTOM: 'center bottom',
    /** Use the top of the right side as an anchor point. */
    RIGHT_TOP: 'right top',
    /** Use the center of the right side as an anchor point. */
    RIGHT_CENTER: 'right center',
    /** Use the bottom of the right side as an anchor point. */
    RIGHT_BOTTOM: 'right bottom'
  };
  
  /**
   Collision detection strategies.
   @enum {String}
   @memberof Aeon.DatePopover
   */
  var collision = {
    /** Flips the element to the opposite side of the target and the collision detection is run again to see if it will fit. Whichever side allows more of the element to be visible will be used. */
    FLIP: 'flip',
    /** Shift the element away from the edge of the window. */
    FIT: 'fit',
    /** First applies the flip logic, placing the element on whichever side allows more of the element to be visible. Then the fit logic is applied to ensure as much of the element is visible as possible. */
    FLIP_FIT: 'flipfit',
    /** Does not apply any collision detection. */
    NONE: 'none'
  };
  
  /**
   Anchored overlay targets.
   @enum {String}
   @memberof Aeon.DatePopover
   */
  var target = {
    /** Use the previous sibling element in the DOM. */
    PREVIOUS: '_prev',
    /** Use the next sibling element in the DOM. */
    NEXT: '_next'
  };
  
  /**
   Overlay placement values.
   @enum {Object}
   @memberof Aeon.DatePopover
   */
  var placement = {
    /** An overlay anchored to the left of the target. */
    LEFT: 'left',
    /** An overlay anchored to the right of the target. */
    RIGHT: 'right',
    /** An overlay anchored at the bottom the target. */
    BOTTOM: 'bottom',
    /** An overlay anchored at the top target. */
    TOP: 'top'
  };
  
  /**
   Boolean enumeration for popover closable state.
   @memberof Aeon.DatePopover
   @enum {String}
   */
  var closable = {
    /** Show a close button on the popover and close the popover when clicked. */
    ON: 'on',
    /**
     Do not show a close button. Elements with the <code>aeon-close</code> attributes will still close the
     popover.
     */
    OFF: 'off'
  };
  
  /**
   Popover interaction values.
   @enum {String}
   @memberof Aeon.DatePopover
   */
  var interaction = {
    /** Show when the target is clicked and hide when clicked outside of the target and popover. */
    ON: 'on',
    /** Do not show or hide automatically. */
    OFF: 'off'
  };
  
  /**
   Popover variants.
   @memberof Aeon.DatePopover
   @enum {String}
   */
  var variant = {
    /** A popover with the default, gray header and no icon. */
    DEFAULT: 'default',
    /** A popover with a red header and warning icon, indicating that an error has occurred. */
    ERROR: 'error',
    /** A popover with an orange header and warning icon, notifying the user of something important. */
    WARNING: 'warning',
    /** A popover with a green header and checkmark icon, indicates to the user that an operation was successful. */
    SUCCESS: 'success',
    /** A popover with a blue header and question mark icon, provides the user with help. */
    HELP: 'help',
    /** A popover with a blue header and info icon, informs the user of non-critical information. */
    INFO: 'info'
  };
  /**
   Map of variant -> icon class names
   @ignore
   */
  var ICON_CLASSES = {
    'error': 'alert',
    'warning': 'alert',
    'success': 'checkCircle',
    'help': 'helpCircle',
    'info': 'infoCircle'
  };
  
  // A string of all possible variant classnames
  var ALL_VARIANT_CLASSES = [];
  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push(CLASS_NAME + '--' + variant[variantValue]);
  }

  Coral.register({
    name: 'DatePopover',
    namespace: window.Aeon,
    tagName: TAG_NAME,
    className: CLASS_NAME,
    properties: {
      /**
       The element the overlay should position relative to. It accepts values from {@link Aeon.DatePopover.target}, as
       well as a DOM element or a CSS selector. If a CSS selector is provided, the first matching element will be used.
       If a target is not specified, the overlay will not respect {@link Aeon.DatePopover#alignMy},
       {@link Aeon.DatePopover#alignAt}, or {@link Aeon.DatePopover#collision}.
       @type {Aeon.DatePopover.target|?HTMLElement|String}
       @default null
       @htmlattribute target
       @memberof Aeon.DatePopover#
       */
      'target': {
        default: null,
        // We don't want to validate that the value must change here
        // If a selector is provided, we'll take the first element matching that selector
        // If the DOM is modified and the user wants a new target with the same selector,
        // They should be able to set target = 'selector' again and get a different element
        validate: function(value) {
          return value === null || typeof value === 'string' || value instanceof Node;
        },
        set: function(value) {
          // Store new value
          this._target = value;
      
          if (this.target) {
            if (this.open) {
              // If the overlay is already visible, we should move it
              this._position();
          
              // To make it return focus to the right item, change the target
              if (this._returnFocus === returnFocus.ON) {
                this.returnFocusTo(this._getTarget());
              }
            }
          }
        }
      },
      
      /**
       Whether to trap tabs and keep them within the overlay.
       @type {Aeon.DatePopover.trapFocus}
       @default Aeon.DatePopover.trapFocus.ON
       @htmlattribute trapfocus
       @memberof Aeon.DatePopover#
       */
      'trapFocus': {
        default: trapFocus.ON,
        attribute: 'trapfocus',
        validate: Coral.validate.enumeration(trapFocus),
        set: function(value) {
          if (value === trapFocus.ON) {
            // Give ourselves tabIndex if we are not focusable
            if (this.tabIndex < 0) {
              this.tabIndex = 0;
            }
        
            // Create elements
            this._elements.topTabCapture = document.createElement('div');
            this._elements.topTabCapture.setAttribute('aeon-datepopover-tabcapture', 'top');
            this._elements.topTabCapture.tabIndex = 0;
            this.insertBefore(this._elements.topTabCapture, this.firstElementChild);
            this._elements.intermediateTabCapture = document.createElement('div');
            this._elements.intermediateTabCapture.setAttribute('aeon-datepopover-tabcapture', 'intermediate');
            this._elements.intermediateTabCapture.tabIndex = 0;
            this.appendChild(this._elements.intermediateTabCapture);
            this._elements.bottomTabCapture = document.createElement('div');
            this._elements.bottomTabCapture.setAttribute('aeon-datepopover-tabcapture', 'bottom');
            this._elements.bottomTabCapture.tabIndex = 0;
            this.appendChild(this._elements.bottomTabCapture);
        
            // Add listeners
            this._handleTabCaptureFocus = this._handleTabCaptureFocus.bind(this);
            this._handleRootKeypress = this._handleRootKeypress.bind(this);
            this._vent.on('keydown', this._handleRootKeypress);
            this._vent.on('focus', '[aeon-datepopover-tabcapture]', this._handleTabCaptureFocus);
          }
          else {
            // Don't just put this in an else, check if we currently have it disabled
            // so we only attempt to remove elements if we were previously capturing tabs
            if (this.trapFocus === trapFocus.ON) {
              // Remove elements
              this.removeChild(this._elements.topTabCapture);
              this.removeChild(this._elements.intermediateTabCapture);
              this.removeChild(this._elements.bottomTabCapture);
              this._elements.topTabCapture = null;
              this._elements.intermediateTabCapture = null;
              this._elements.bottomTabCaptureEl = null;
          
              // Remove listeners
              this._vent.off('keydown', this._handleRootKeypress);
              this._vent.off('focus', '[aeon-datepopover-tabcapture]', this._handleTabCaptureFocus);
            }
          }
      
          this._trapFocus = value;
        }
      },
  
      /**
       Whether to return focus to the previously focused element when closed.
       @type {Aeon.DatePopover.returnFocus}
       @default Aeon.DatePopover.returnFocus.ON
       @htmlattribute returnfocus
       @memberof Aeon.DatePopover#
       */
      'returnFocus': {
        default: returnFocus.ON,
        attribute: 'returnfocus',
        validate: Coral.validate.enumeration(returnFocus)
      },
  
      // JSDoc inherited
      'focusOnShow': {
        default: focusOnShow.ON,
        attribute: 'focusonshow',
        validate: [
          Coral.validate.valueMustChange,
          function(value) {
            return typeof value === 'string' || value instanceof HTMLElement;
          }
        ]
      },
  
      /**
       The popover's content element.
       @contentzone
       @name content
       @type {HTMLElement}
       @memberof Aeon.DatePopover#
       */
      'content': Coral.property.contentZone({
        handle: 'content',
        tagName: 'aeon-datepopover-content',
        defaultContentZone: true,
        insert: function(content) {
          this._elements.contentWrapper.appendChild(content);
        }
      }),
  
      /**
       The popover's header element.
       @contentzone
       @name header
       @type {HTMLElement}
       @memberof Aeon.DatePopover#
       */
      'header': Coral.property.contentZone({
        handle: 'header',
        tagName: 'aeon-datepopover-header',
        insert: function(header) {
          this._elements.headerContent.appendChild(header);
        },
        set: function(value) {
          // Stop observing the old header and observe the new one
          this._observeHeader();
      
          // Check if header needs to be hidden
          this._hideHeaderIfEmpty();
        }
      }),
  
      /**
       The point on the overlay we should anchor from when positioning.
       @type {Aeon.DatePopover.align}
       @default Aeon.DatePopover.align.LEFT_CENTER
       @htmlattribute alignmy
       @memberof Aeon.DatePopover#
       */
      'alignMy': {
        default: align.LEFT_CENTER,
        attribute: 'alignmy',
        transform: transformAlignment,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(align)
        ],
        sync: repositionIfOpen
      },
  
      /**
       The point on the target we should anchor to when positioning.
       @type {Aeon.DatePopover.align}
       @default Aeon.DatePopover.align.RIGHT_CENTER
       @htmlattribute alignat
       @memberof Aeon.DatePopover#
       */
      'alignAt': {
        default: align.RIGHT_CENTER,
        attribute: 'alignat',
        transform: transformAlignment,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(align)
        ],
        sync: repositionIfOpen
      },
  
      /**
       The distance the overlay should be from its target.
       @type {Number}
       @default 5
       @htmlattribute offset
       @memberof Aeon.DatePopover#
       */
      'offset': {
        default: 5,
        transform: Coral.transform.number,
        validate: function(value) {
          return typeof value === 'number';
        },
        set: function(value) {
          this._offset = value;
    
          if (this.open) {
            // If the overlay is already visible, we should move it accordingly
            this._position();
          }
        }
      },
  
      /**
       The placement of the overlay. This property sets {@link Aeon.DatePopover#alignMy} and {@link Aeon.DatePopover#alignAt}.
       @type {Aeon.DatePopover.placement}
       @default null
       @htmlattribute placement
       @memberof Aeon.DatePopover#
       */
      'placement': {
        // default: null, // Don't provide a defualt here
        transform: transformAlignment,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(placement)
        ],
        set: function(value) {
          var alignValues = this._placementAlignValues[value];
      
          this.alignMy = alignValues.alignMy;
          this.alignAt = alignValues.alignAt;
      
          this._placement = value;
        }
      },
  
      /**
       The bounding element for the overlay. The overlay will be sized and positioned such that it is contained within
       this element. It accepts both a DOM Element or a CSS selector. If a CSS selector is provided, the first matching
       element will be used.
       @type {HTMLElement|String}
       @default window
       @memberof Aeon.DatePopover#
       */
      'within': {
        default: window,
        sync: repositionIfOpen
      },
  
      /**
       The collision handling strategy when positioning the overlay relative to a target.
       @type {Aeon.DatePopover.collision}
       @default Aeon.DatePopover.collision.FLIP_FIT
       @htmlattribute collision
       @memberof Aeon.DatePopover#
       */
      'collision': {
        default: collision.FLIP_FIT,
        sync: repositionIfOpen
      },
  
      'open': {
        default: false,
        reflectAttribute: true,
        transform: Coral.transform.boolean,
        attributeTransform: Coral.transform.booleanAttr,
        triggerBefore: function(newValue, oldValue) {
          // We have to manually implement triggerBefore since we can trigger multiple events
          return this.trigger(newValue ? 'aeon-datepopover:beforeopen' : 'aeon-datepopover:beforeclose');
        },
        set: function(value, silent) {
          // We need to store the value here as we're not using the default setter
          this._open = value;
          this._openSilently = !!silent;
    
          // Set synchronously as it does not affect rendering
          if (this.open) {
            // Set aria-hidden false before we show
            // Otherwise, screen readers will not announce
            this.setAttribute('aria-hidden', 'false');
          }
          else {
            // Doesn't matter when we set aria-hidden true (nothing being announced)
            this.setAttribute('aria-hidden', 'true');
          }
    
          // Synchronous operations
          if (this.parentNode) {
            // Don't do anything if we're not in the DOM yet
            // This prevents errors related to allocating a zIndex we don't need
            if (this.open) {
              // Do this check afterwards as we may have been appended inside of _show()
        
              // Set z-index
              this._pushOverlay();
        
              if (this.returnFocus === returnFocus.ON) {
                this._elementToFocusWhenHidden =
                  // cached element
                  this._elementToFocusWhenHidden ||
                  // element passed via returnFocusTo()
                  this._returnFocusToElement ||
                  // element that had focus before opening the overlay
                  (document.activeElement === document.body ? null : document.activeElement);
              }
            }
            else {
              // Release zIndex
              this._popOverlay();
            }
          }
        },
        sync: function() {
          var self = this;
  
          if (this.open) {
            if (this.trapFocus === trapFocus.ON) {
              // Make sure tab capture elements are positioned correctly
              if (
                // Tab capture elements are no longer at the bottom
              this._elements.topTabCapture !== this.firstElementChild ||
              this._elements.bottomTabCapture !== this.lastElementChild ||
              // Tab capture elements have been separated
              this._elements.bottomTabCapture.previousElementSibling !== this._elements.intermediateTabCapture
              ) {
                this.insertBefore(this._elements.intermediateTabCapture, this.firstElementChild);
                this.appendChild(this._elements.intermediateTabCapture);
                this.appendChild(this._elements.bottomTabCapture);
              }
            }
    
            // The default style should be display: none for overlays
            // Show ourselves first for centering calculations etc
            this.style.display = 'block';
    
            Coral.commons.nextFrame(function() {
              self.classList.add('is-open');
      
              var openComplete = function() {
                if (self.open) {
          
                  // handles the focus behavior based on accessibility recommendations
                  self._handleFocus();
          
                  if (!self._openSilently) {
                    self.trigger('aeon-datepopover:open');
                  }
                }
              };
      
              if (self._overlayAnimationTime) {
                // Wait for animation to complete
                Coral.commons.transitionEnd(self, openComplete);
              }
              else {
                // Execute immediately
                openComplete();
              }
            });
          }
          else {
            // Fade out
            Coral.commons.nextFrame(function() {
              self.classList.remove('is-open');
      
              var closeComplete = function() {
                if (!self.open) {
                  // Hide self
                  self.style.display = 'none';
          
                  // makes sure the focus is returned per accessibility recommendations
                  self._handleReturnFocus();
          
                  if (!self._openSilently) {
                    self.trigger('aeon-datepopover:close');
                  }
                }
              };
      
              if (self._overlayAnimationTime) {
                // Wait for animation to complete
                Coral.commons.transitionEnd(self, closeComplete);
              }
              else {
                // Execute immediately
                closeComplete();
              }
            });
          }
          
          var target = this._getTarget();
          if (target) {
            if (this.open) {
              // Check if the target already has is-selected
              this._targetWasSelected = target.classList.contains('is-selected');
          
              // Only bother adding the class if the target doesn't have it
              if (!this._targetWasSelected) {
                // Highlight target
                target.classList.add('is-selected');
              }
            }
            else if (!this._targetWasSelected) {
              // When closed, only remove the class if the target didn't have it before
              target.classList.remove('is-selected');
            }
          }
  
          if (this.open) {
            // Position when opened
            this._position();
          }
        }
      },
  
      /**
       Whether the popover should show itself when the target is interacted with.
       @type {Aeon.DatePopover.interaction}
       @default Aeon.DatePopover.interaction.ON
       @name interaction
       @htmlattribute interaction
       @memberof Aeon.DatePopover#
       */
      'interaction': {
        default: interaction.ON,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(interaction)
        ]
      },
  
      /**
       The popover's variant.
       @type {Aeon.DatePopover.variant}
       @default Aeon.DatePopover.variant.DEFAULT
       @htmlattribute variant
       @memberof Aeon.DatePopover#
       */
      // Inherit from Dialog
      'variant': {
        default: variant.DEFAULT,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(variant)
        ],
        sync: function() {
          // Remove all variant classes
          this.classList.remove.apply(this.classList, ALL_VARIANT_CLASSES);
    
          if (this.variant === variant.DEFAULT) {
            this._elements.icon.icon = '';
      
            // ARIA
            this.setAttribute('role', 'dialog');
          }
          else {
            this._elements.icon.icon = ICON_CLASSES[this.variant];
      
            // Set new variant class
            // Don't use this._className; use the constant
            // This lets popover get our styles for free
            this.classList.add(CLASS_NAME + '--' + this.variant);
      
            // ARIA
            this.setAttribute('role', 'alertdialog');
          }
        }
      },
  
      /**
       Whether the popover should have a close button.
       @type {Aeon.DatePopover.closable}
       @default Aeon.DatePopover.closable.OFF
       @htmlattribute closable
       @htmlattributereflected
       @memberof Aeon.DatePopover#
       */
      'closable': {
        default: closable.OFF,
        reflectAttribute: true,
        validate: [
          Coral.validate.valueMustChange,
          Coral.validate.enumeration(closable)
        ],
        sync: function() {
          this._elements.closeButton.style.display = this.closable === closable.ON ? '' : 'none';
        }
      },
  
      /**
       The popover's icon.
       @type {String}
       @default ""
       @htmlattribute icon
       @memberof Aeon.DatePopover#
       */
      'icon': Coral.property.proxy({
        path: '_elements.icon.icon'
      }),
      
      'value': {
        default: {},
        sync: function (e) {
          this.trigger('aeon:filter:dateChange', {date: this.value});
        }
      },
      'start': {
        default: '2016-01-01',
        set: function(start) {
          var value = $.extend(true, {}, this.value);
          value.start = start;

          this.min = start;

          this.set({
            value: value
          });
        },
        get: function() {
          return this.value.start;
        }
      },
      'end': {
        default: '2016-01-31',
        set: function(end) {
          var value = $.extend(true, {}, this.value);
          value.end = end;

          this.max = end;

          this.set({
            value: value
          });
        },
        get: function() {
          return this.value.end;
        }
      },
      'dateFormat': {
        default: DEFAULT_DATE_FORMAT,
        attribute: 'dateformat',
        sync: function() {}
      }
    },
  
    // Use the fade time from overlay
    _overlayAnimationTime: FADETIME,
  
    /** @ignore */
    _observeHeader: function() {
      if (this._headerObserver) {
        this._headerObserver.disconnect();
        this._headerObserver.observe(this._elements.header, {
          childList: true, // Catch changes to childList
          characterData: true, // Catch changes to textContent
          subtree: true // Monitor any child node
        });
      }
    },
  
    /**
     Hide the header wrapper if the header content zone is empty.
     @ignore
     */
    _hideHeaderIfEmpty: function() {
      var header = this._elements.header;
      var headerWrapper = this._elements.headerWrapper;
      var headerContent = this._elements.headerContent;
    
      // If it's empty and has no non-textnode children, hide the header
      var hiddenValue = header.children.length === 0 && header.textContent.replace(/\s*/g, '') === '';
    
      // Only bother if the hidden status has changed
      if (hiddenValue !== headerWrapper.hidden) {
        headerWrapper.hidden = hiddenValue;
      
        if (hiddenValue) {
          headerContent.removeAttribute('role');
          headerContent.removeAttribute('aria-level');
        }
        else {
          headerContent.setAttribute('role', 'heading');
          headerContent.setAttribute('aria-level', '2');
        }
      
        // Reposition as the height has changed
        this.reposition();
      }
    },
  
    /**
     @ignore
     @todo maybe this should be mixin or something
     */
    _handleCloseClick: function(event) {
      var dismissTarget = event.matchedTarget;
      var dismissValue = dismissTarget.getAttribute('aeon-datepopover-close');
      if (!dismissValue || this.matches(dismissValue)) {
        this.hide();
        event.stopPropagation();
      }
    },
  
    _handleClick: function(event) {
      if (this.interaction === interaction.OFF) {
        // Since we use delegation, just ignore clicks if interaction is off
        return;
      }
    
      var eventTarget = event.target;
      var targetEl = this._getTarget();
    
      var eventIsWithinTarget = targetEl ? targetEl.contains(eventTarget) : false;
    
      if (eventIsWithinTarget) {
        // When target is clicked
      
        if (!this.open && !targetEl.disabled) {
          // Open if we're not already open and target element is not disabled
          this.show();
        }
        else {
          this.hide();
        }
      }
      else if (this.open && !this.contains(eventTarget)) {
        // Close if we're open and the click was outside of the target and outside of the popover
        this.hide();
      }
    },
  
    /** @ignore */
    attachedCallback: function() {
      this.trigger('coral-component:attached');
  
      // A component that is in the DOM should respond to global events
      this._delegateGlobalEvents();
      
      // @todo CUI-3739 - expose methods on prototype and call from there
      // Re-implmement behavior from Aeon.DatePopover's attachedCallback
      if (this.open) {
        this._pushOverlay();
      
        if (this._showBackdropOnAttached) {
          // Show the backdrop again
          this._showBackdrop();
        }
      
        // @todo CUI-3899 - add this to Aeon.DatePopover
        // Reposition when attached if open
        this.reposition();
      }
    },
    
    events: {
      'global:capture:click': '_handleClick',
      'click [aeon-datepopover-close]': '_handleCloseClick',
      'global:resize': '_position',
      'global:key:escape': '_handleEscape',
      
      'aeon-datepopover:beforeclose': 'beforePopoverClose',
      'aeon-datepopover:beforeopen': 'onBeforePopoverOpen',
      'aeon:calendar:dayClick': '_setDate',
      'aeon:calendar:render': 'toggleMonthAndDateClasses',
      'aeon:calendar:paginate': 'syncCalendarPagination',
      'click [handle="reset"]': 'closePopover',
      'click [handle="apply"]': 'applyDates',
      'click [handle="today"]': 'setStartAndEndDates',
      'click [handle="thisweek"]': 'setStartAndEndDates',
      'click [handle="nextweek"]': 'setStartAndEndDates'
    },
  
    _initialize: function() {
      // ARIA
      this.setAttribute('role', 'dialog');
      this.setAttribute('aria-live', 'assertive'); // This helped annoucements in certian screen readers
    
      // Listen for mutations
      this._headerObserver = new MutationObserver(this._hideHeaderIfEmpty.bind(this));
    
      // Watch for changes to the header element's children
      this._observeHeader();
    },

    _render: function() {
      // compatibility with CoralUI
      this.$ = $(this);

      var frag = document.createDocumentFragment();
      var template = Coral.templates.Aeon.datepopover.call(this._elements);

      // Create a wrapper for the header
      // This lets us apply the right CSS classes to the outer container
      var headerWrapper = this._elements.headerWrapper = document.createElement('div');
      headerWrapper.className = 'aeon-DatePopover-header';

      // Create a wrapper for the content
      // This lets us apply the CSS classes to the outer container, while letting the user freely apply classes to the
      // content zone
      var contentWrapper = this._elements.contentWrapper = document.createElement('div');
      contentWrapper.className = 'aeon-DatePopover-content';

      // Render the template for the header and move it into the wrapper
      var headerFrag = Coral.templates.Aeon.header.call(this._elements);
      headerWrapper.appendChild(headerFrag);

      // Try to find the header
      var foundHeader = template.querySelector('aeon-datepopover-header');

      // Fetch or create the header, content, and footer sub-components
      var header = foundHeader || document.createElement('aeon-datepopover-header');
      var content = template.querySelector('aeon-datepopover-content') || document.createElement('aeon-datepopover-content');

      this.header = header;
      this.content = content;

      if (!foundHeader) {
        // Hide the wrapper if no header was provided
        headerWrapper.hidden = true;
      }

      // Move the rendered header template into the frag
      frag.appendChild(headerWrapper);

      // Move the content and footer sub-components to the frag
      frag.appendChild(contentWrapper);

      // Finally, move any remaining elements into the content sub-component
      while (this.firstChild) {
        content.appendChild(this.firstChild);
      }

      // Add the frag to the component
      this.appendChild(frag);
    },
  
    /*
     Get the element the overlay is anchored to.
     @protected
     @param {HTMLElement|String} [target]
     A specific target value to use.
     If not provided, the current value of the {@link Aeon.DatePopover#target} property will be used.
     @memberof Aeon.DatePopover#
     @returns {HTMLElement|null}
     */
    _getTarget: function(targetValue) {
      // Use passed target
      targetValue = targetValue || this.target;
    
      if (targetValue instanceof Node) {
        // Just return the provided Node
        return targetValue;
      }
    
      // Dynamically get the target node based on target
      var newTarget = null;
      if (typeof targetValue === 'string') {
        if (targetValue === target.PREVIOUS) {
          newTarget = this.previousElementSibling;
        }
        else if (targetValue === target.NEXT) {
          newTarget = this.nextElementSibling;
        }
        else {
          newTarget = document.querySelector(targetValue);
        }
      }
    
      return newTarget;
    },
  
    /**
     Re-position the overlay if it's currently open.
     @function
     @memberof Aeon.DatePopover#
     */
    reposition: repositionIfOpen,
  
    /**
     Position the overlay according to {@link Aeon.DatePopover#target} and
     {@link Aeon.DatePopover#alignMy}/{@link Aeon.DatePopover#alignAt}.
     @protected
     @memberof Aeon.DatePopover#
     */
    _position: function() {
      // @todo do this sync style so we don't position more than necessary?
    
      // Do nothing unless open
      if (!this.open) {
        return;
      }
    
      var targetEl = this._getTarget();
    
      // Do nothing unless we have a target
      if (!targetEl) {
        return;
      }
    
      // A hook to allow implementation of strategies for preventing miscalculation
      this._beforePosition();
    
      // Apply offset
      var offset = this.offset;
      var offsetStrings = [];
      var alignMy = this.alignMy;
      var alignAt = this.alignAt;
      var alignMyParts = alignMy.split(' ');
      var alignAtParts = alignAt.split(' ');
    
      offsetStrings[0] = (offset > 0) ? '+' + offset : offset;
      offsetStrings[1] = (offset > 0) ? '-' + offset : '+' + -offset;
    
      if (offset) {
        if (alignMyParts[1] === 'top' && (alignAtParts[1] === 'bottom' || alignAtParts[1] === 'top')) {
          alignMy += offsetStrings[0];
        }
        else if (alignMyParts[1] === 'bottom' && (alignAtParts[1] === 'top' || alignAtParts[1] === 'bottom')) {
          alignMy += offsetStrings[1];
        }
        else if (alignMyParts[0] === 'left' && (alignAtParts[0] === 'right' || alignAtParts[0] === 'left')) {
          alignMy = alignMyParts.join(offsetStrings[0] + ' ');
        }
        else if (alignMyParts[0] === 'right' && (alignAtParts[0] === 'left' || alignAtParts[0] === 'right')) {
          alignMy = alignMyParts.join(offsetStrings[1] + ' ');
        }
      }
    
      // Perform the positioning calculation
      // TODO remove jQuery UI position dep
      $(this).position({
        my: alignMy,
        at: alignAt,
        using: this._positionCallback,
        of: targetEl,
        collision: this.collision,
        within: this.within
      });
    },
  
    /**
     Called before positioning to setup the element (width etc).
     @protected
     */
    _beforePosition: function() {
      var windowWidth = window.innerWidth;
    
      // Set max width if we're on the left or right
      if (this.alignMy.indexOf('left') === 0 || this.alignMy.indexOf('right') === 0) {
        // Make sure we're visible by setting display
        this.style.display = 'block';
      
        var target = this._getTarget();
      
        // Get the position and width of the target
        var targetPos = target.getBoundingClientRect();
      
        // Get the max width of the overlay
        var distanceFromRight = windowWidth - (targetPos.left + targetPos.width);
        var distanceFromLeft = targetPos.left;
        var maxWidth = Math.max(distanceFromLeft, distanceFromRight);
      
        // Set the width
        this.style.maxWidth = maxWidth + 'px';
      
        // Reset display value
        this.style.display = '';
      }
      else {
        // Top and bottom tooltips should never be wider than the screen
        this.style.maxWidth = windowWidth + 'px';
      }
    
      // Don't let the current position dictate the width of the element
      // If we're on the extreme left/right, we may be squishing
      this.style.left = '-9999px';
      this.style.top = '-9999px';
    },
  
    /**
     Receive the jQueryUI position utility's result and trigger events.
     @ignore
     @param {Object} position
     The calculated position.
     @param {Object} position.left
     The left position.
     @param {Object} position.right
     The right position.
     @fires Aeon.DatePopover#aeon-datepopover:positioned
     */
    _positionCallback: function(position, feedback) {
      this._applyPosition(position, feedback);
      this.trigger('aeon-datepopover:positioned', feedback);
    },
  
    /**
     Apply the calculated position.
     @protected
     @param {Object} position
     The calculated position.
     @param {Object} position.left
     The left position.
     @param {Object} position.right
     The right position.
     */
    _applyPosition: function(position, feedback) {
      this.style.top = position.top + 'px';
      this.style.left = position.left + 'px';
    },
  
    detachedCallback: function() {
      this.trigger('coral-component:detached');
  
      // A component that isn't in the DOM should not be responding to global events
      this._undelegateGlobalEvents();
      
      if (this.open) {
        // Release zIndex as we're not in the DOM any longer
        // When we're re-added, we'll get a new zIndex
        this._popOverlay();
      
        if (this._requestedBackdrop) {
          // Mark that we'll need to show the backdrop when attached
          this._showBackdropOnAttached = true;
        }
      }
    },
  
    /**
     Open the overlay and set the z-index accordingly.
     @returns {Aeon.DatePopover} this, chainable
     @memberof Aeon.DatePopover#
     */
    show: function() {
      this.open = true;
    
      return this;
    },
  
    /**
     Close the overlay.
     @returns {Aeon.DatePopover} this, chainable
     @memberof Aeon.DatePopover#
     */
    hide: function() {
      this.open = false;
    
      return this;
    },
  
    /**
     Set the element that focus should be returned to when the overlay is hidden.
     @param {HTMLElement} element
     The element to return focus to. This must be a DOM element, not a jQuery object or selector.
     @returns {Aeon.DatePopover} this, chainable
     @memberof Aeon.DatePopover#
     */
    returnFocusTo: function(element) {
      if (this.returnFocus === returnFocus.OFF) {
        // Switch on returning focus if it's off
        this.returnFocus = returnFocus.ON;
      }
    
      // If the element is not focusable,
      if (element.offsetParent === null || !element.matches(Coral.commons.FOCUSABLE_ELEMENT_SELECTOR)) {
      
        // add tabindex so that it is programmatically focusable.
        element.setAttribute('tabindex', -1);
      
        // On blur, restore element to its prior, not-focusable state
        var tempVent = new window.Vent(element);
        tempVent.on('blur.afterFocus', function(event) {
        
          // Wait a frame before testing whether focus has moved to an open overlay or to some other element.
          Coral.commons.nextFrame(function() {
          
            // If overlay remains open, don't remove tabindex event handler until after it has been closed
            var top = overlays.top();
            if (top && top.instance.contains(document.activeElement)) {
              return;
            }
            tempVent.off('blur.afterFocus');
            event.matchedTarget.removeAttribute('tabindex');
          });
        }, true);
      }
    
      this._returnFocusToElement = element;
      return this;
    },
  
    /**
     Check if this overlay is the topmost.
     @protected
     @memberof Aeon.DatePopover#
     */
    _isTopOverlay: function() {
      var top = overlays.top();
      return top && top.instance === this;
    },
  
    /**
     Push the overlay to the top of the stack.
     @protected
     @memberof Aeon.DatePopover#
     */
    _pushOverlay: function() {
      overlays.push(this);
    },
  
    /**
     Remove the overlay from the stack.
     @protected
     @memberof Aeon.DatePopover#
     */
    _popOverlay: function() {
      overlays.pop(this);
    
      // Automatically hide the backdrop if required
      hideOrRepositionBackdrop();
    },
  
    /**
     Show the backdrop.
     @protected
     @memberof Aeon.DatePopover#
     */
    _showBackdrop: function() {
      var overlay = overlays.get(this);
    
      // Overlay is not tracked unless the component is in the DOM
      // Hence, we need to check
      if (overlay) {
        overlay.backdrop = true;
        doBackdropShow(overlay.zIndex, this);
      }
    
      // Mark on the instance that the backdrop has been requested for this overlay
      this._requestedBackdrop = true;
    
      // Mark that the backdrop was requested when not attached to the DOM
      // This allows us to know whether to push the overlay when the component is attached
      if (!this.parentNode) {
        this._showBackdropOnAttached = true;
      }
    
      if (this.trapFocus === trapFocus.ON) {
        createDocumentTabCaptureEls();
      }
    },
  
    /**
     Show the backdrop.
     @protected
     @memberof Aeon.DatePopover#
     */
    _hideBackdrop: function() {
      var overlay = overlays.get(this);
    
      if (overlay) {
        overlay.backdrop = false;
      
        // If that was the last overlay using the backdrop, hide it
        hideOrRepositionBackdrop();
      }
    
      // Mark on the instance that the backdrop is no longer needed
      this._requestedBackdrop = false;
    },
  
    /**
     Handles keypresses on the root of the overlay and marshalls focus accordingly.
     @protected
     */
    _handleRootKeypress: function(event) {
      if (event.target === this && event.keyCode === TAB_KEY) {
        // Skip the top tabcapture and focus on the first focusable element
        this._focusOn('first');
      
        // Stop the normal tab behavior
        event.preventDefault();
      }
    },
  
    /**
     Handles focus events on tab capture elements.
     @protected
     @memberof Aeon.DatePopover#
     */
    _handleTabCaptureFocus: function(event) {
      // Avoid moving around if we're trying to focus on aeon-datepopover-tabcapture
      if (this._ignoreTabCapture) {
        this._ignoreTabCapture = false;
        return;
      }
    
      // Focus on the correct tabbable element
      var target = event.target;
      var which = (target === this._elements.intermediateTabCapture ? 'first' : 'last');
    
      this._focusOn(which);
    },
  
    /**
     Handles the focus behavior. When "on" is specified it would try to find the first tababble descendent in the
     content and if there are no valid candidates it will focus the element itself.
     @protected
     @memberof Aeon.DatePopover#
     */
    _handleFocus: function() {
      // ON handles the focusing per accessibility recommendations
      if (this.focusOnShow === focusOnShow.ON) {
        this._focusOn('first');
      }
      else if (this.focusOnShow instanceof HTMLElement) {
        this.focusOnShow.focus();
      }
      else if (typeof this.focusOnShow === 'string' && this.focusOnShow !== focusOnShow.OFF) {
        // we need to add :not([aeon-datepopover-tabcapture]) to avoid selecting the tab captures
        var selectedElement = this.querySelector(this.focusOnShow + ':not([aeon-datepopover-tabcapture])');
      
        if (selectedElement) {
          selectedElement.focus();
        }
        // in case the selector does not match, it should fallback to the default behavior
        else {
          this._focusOn('first');
        }
      }
    },
  
    /**
     @protected
     @memberof Aeon.DatePopover#
     */
    _handleReturnFocus: function() {
      if (this.returnFocus === returnFocus.ON && this._elementToFocusWhenHidden) {
        if (document.activeElement && !this.contains(document.activeElement)) {
          // Don't return focus if the user focused outside of the overlay
          return;
        }
      
        // Return focus, ignoring tab capture if it is an overlay
        this._elementToFocusWhenHidden._ignoreTabCapture = true;
        this._elementToFocusWhenHidden.focus();
        this._elementToFocusWhenHidden._ignoreTabCapture = false;
      
        // Drop the reference to avoid memory leaks
        this._elementToFocusWhenHidden = null;
      }
    },
  
    /**
     Focus on the first or last element.
     @param {String} which
     one of "first" or "last"
     @protected
     */
    _focusOn: function(which) {
      var tabTarget;
      if (which === 'first' || which === 'last') {
        // @todo: shall this be focussable or tabbable?
        tabTarget = Array.prototype.filter.call(this.querySelectorAll(Coral.commons.TABBABLE_ELEMENT_SELECTOR), function(item) {
          return item.offsetParent !== null && !item.hasAttribute('aeon-datepopover-tabcapture');
        })[which === 'first' ? 'shift' : 'pop']();
      }
    
      // if we found a focusing target we focus it
      if (tabTarget) {
        tabTarget.focus();
      }
      // otherwise the element itself should get focus
      else {
        this.focus();
      }
    },
  
    /**
     Hides the overlay if it's on the top. When <code>interaction</code> is OFF it is ignored.
     @ignore
     */
    _handleEscape: function(event) {
      if (this.interaction === interaction.ON && this.open && this._isTopOverlay()) {
        this.hide();
      }
    },

    _setDate: function(e){
      var me = this;
      var calendars;
      var maxDate;
      var i, il, el;

      this.checkMinMaxDateRange(e);
      this.selectionMode(e.detail);
      maxDate = (this.getContext('triggerEndDateInput') ? '' : this.max);

      calendars = this._elements.content.querySelectorAll('.aeon-Calendar');
      for(i = 0, il = calendars.length; i < il; i++) {
        el = calendars[i];
        el.toggleMonthAndDateClasses(me.min, maxDate);
      }

      if(this.getContext('triggerEndDateInput')) {
        setTimeout(function() {
          me.closePopover();
        }, 100);
      }
    },

    _setMinDate: function(e) {
      this.min = e.value;
      this.start = this.min;
    },

    _setMaxDate: function(e) {
      this.max = e.value;
      this.end = this.max;
    },

    beforePopoverClose: function(e){
      var opts = {};
      var me = this;
      var aeonFilterChangeFn = debounce(function(){
        me.trigger('aeon:filters:change', {date: me.value});
      }, 200);

      if(this.getContext('triggerFilterChange')) {
        aeonFilterChangeFn();
      } else if(this.getContext('triggerEndDateInput')) {
        opts.openEndDatePicker = true;
        this._setMaxDate({value: moment(this.start).add(1, 'day').format('YYYY-MM-DD')});
      } else {
        this.restorePrevValues();
      }
      this.trigger('aeon:popover:close', opts);
    },

    applyDates: function(e) {
      this.setContext('triggerFilterChange');
      this.closePopover(e);
    },

    closePopover: function() {
      this.hide();
    },

    onBeforePopoverOpen: function() {
      this.positionOverlay(this.target);
      this.initializeContext();
      this.selectionMode = this.setDateSelectionMode(this.datePicker);
      this.savePrevValues();
      this.initializeCalendars();
    },

    initializeContext: function() {
      this._context = {
        triggerFilterChange: false,
        triggerEndDateInput: false,
        blurred: false
      };
    },

    initializeCalendars: function() {
      var calendars = this.getCalendars();
      var leftCalendar = calendars[0];
      var rightCalendar = calendars[1];
      var cursor = this.start;
      var minMonth, minYear, nextMonth, nextYear;

      if(this.isMaxDateSelectionMode()) {
        cursor = (this.end.length > 0 ? this.end : this.start);
      }

      minMonth = moment(cursor).month();
      minYear = moment(cursor).year();
      nextMonth = minMonth + 1;
      nextYear = minYear;

      //Set the correct month and year values
      if(minMonth >= DECEMBER) {
        nextMonth = JANUARY;
        nextYear = minYear + 1;
      }

      leftCalendar._gotoMonthYear(minMonth, minYear);
      rightCalendar._gotoMonthYear(nextMonth, nextYear);

      this.calendarsInitialized = true;
    },

    restorePrevValues: function() {
      this.start = this.prevStart;
      this.end = this.prevEnd;
    },

    savePrevValues: function() {
      this.prevStart = this.start;
      this.prevEnd = this.end;
    },

    setDateSelectionMode: function(target) {
      if(target && target.$.hasClass('aeon-DateRangePicker--end')) {
        return this._setMaxDate;
      } else {
        return this._setMinDate;
      }
    },

    setStartAndEndDates: function(e) {
      var targetDates = e.target.getAttribute('handle');
      var startDate, endDate;
      var offsets = {
        'thisweek': {
          'start': 0,
          'end': 6
        },
        'nextweek': {
          'start': 7,
          'end': 13
        }
      };

      if(targetDates === 'today'){
        startDate = moment();
        endDate = startDate;
      } else {
        startDate = moment().weekday(offsets[targetDates].start);
        endDate = moment().weekday(offsets[targetDates].end);
      }

      this.start = startDate.format(this.dateFormat);
      this.end = endDate.format(this.dateFormat);
      this.syncCalendars(endDate);
    },

    setContext: function(key) {
      this._context[key] = true;
    },

    positionOverlay: function(target) {
      var $target = $(target),
          isDateRangePickerStart;

      isDateRangePickerStart = $target.closest('aeon-DateRangePicker').hasClass('aeon-DateRangePicker--start');
      this.classList.remove('aeon-DatePopover-startdatepicker', 'aeon-DatePopover-enddatepicker');

      if(isDateRangePickerStart) {
        this.classList.add('aeon-DatePopover-startdatepicker');
      } else {
        this.classList.add('aeon-DatePopover-enddatepicker');
      }
    },

    syncCalendarPagination: function(e) {
      var calendars = this.getCalendars();
      var leftCalendar = calendars[0];
      var rightCalendar = calendars[1];
      var isNext = e.detail.isNext;

      if(isNext) {
        leftCalendar._gotoPreviousOrNextTimeUnit('month', isNext);
      } else {
        rightCalendar._gotoPreviousOrNextTimeUnit('month', isNext);
      }
    },

    syncCalendars: function(e) {
      var calendars = this.getCalendars();
      var leftCalendar = calendars[0];
      var rightCalendar = calendars[1];
      var gotoDate = ((e.detail && e.detail.value) || e);
      var gotoYear = gotoDate.year();
      var gotoMonth;
      var leftCalendarMonth;
      var rightCalendarMonth;
      var targetCalendar;

      gotoMonth = parseInt(gotoDate.month() / 2) * 2;
      leftCalendarMonth = gotoMonth;
      rightCalendarMonth = gotoMonth + 1;
      targetCalendar = gotoDate.month() % 2 === 0 ? leftCalendar : rightCalendar;

      leftCalendar._gotoMonthYear(leftCalendarMonth, gotoYear);
      rightCalendar._gotoMonthYear(rightCalendarMonth, gotoYear);
      if( e.detail && e.detail.setTargetCalendar ) {
        targetCalendar._setDate(gotoDate);
      }
    },

    toggleMonthAndDateClasses: function(e) {
      var calendarSelector = e.detail.calendar;
      var calendar = this._elements[calendarSelector];
      calendar.toggleMonthAndDateClasses(this.min, this.max);
    },

    checkMinMaxDateRange: function(e) {
      var isMaxDateBeforeStartDate;
      var isMinDateAfterEndDate;

      if(e && e.detail) {
        isMaxDateBeforeStartDate = (this.isMaxDateSelectionMode() && e.detail.value < this.start);
        isMinDateAfterEndDate = (this.isMinDateSelectionMode() && e.detail.value > this.end);
      }

      if(isMinDateAfterEndDate || isMaxDateBeforeStartDate) {
        this.setContext('triggerEndDateInput');
      }

      if(isMaxDateBeforeStartDate) {
        this.selectionMode = this._setMinDate;
      }
    },

    getCalendars: function() {
      return this._elements.content.querySelectorAll('aeon-calendar');
    },

    getContext: function(key) {
      return this._context[key];
    },

    isMinDateSelectionMode: function() {
      return this.selectionMode === this._setMinDate;
    },

    isMaxDateSelectionMode: function() {
      return this.selectionMode === this._setMaxDate;
    }
  });
  
  Coral.register( /** @lends Aeon.DatePopover.Content */ {
    /**
     @class Aeon.DatePopover.Content
     @classdesc A Popover Content component
     @extends Coral.Component
     @htmltag aeon-datepopover-content
     */
    name: 'DatePopover.Content',
    namespace: window.Aeon,
    tagName: 'aeon-datepopover-content'
  });
  
  Coral.register( /** @lends Aeon.DatePopover.Header */ {
    /**
     @class Aeon.DatePopover.Header
     @classdesc A Popover Header component
     @extends Coral.Component
     @htmltag aeon-datepopover-header
     */
    name: 'DatePopover.Header',
    namespace: window.Aeon,
    tagName: 'aeon-datepopover-header'
  });
  
  Coral.register( /** @lends Aeon.DatePopover.Separator */ {
    /**
     @class Aeon.DatePopover.Separator
     @classdesc A Popover Separator component
     @extends Coral.Component
     @htmltag aeon-datepopover-separator
     */
    name: 'DatePopover.Separator',
    namespace: window.Aeon,
    tagName: 'aeon-datepopover-separator',
    className: 'aeon-DatePopover-separator'
  });
  
  // Expose enums globally
  window.Aeon.DatePopover.closable = closable;
  window.Aeon.DatePopover.interaction = interaction;
  window.Aeon.DatePopover.variant = variant;
  window.Aeon.DatePopover.align = align;
  window.Aeon.DatePopover.collision = collision;
  window.Aeon.DatePopover.target = target;
  window.Aeon.DatePopover.placement = placement;
  window.Aeon.DatePopover.interaction = interaction;
  window.Aeon.DatePopover.trapFocus = trapFocus;
  window.Aeon.DatePopover.returnFocus = returnFocus;
  window.Aeon.DatePopover.focusOnShow = focusOnShow;
}());

/*
 * ADOBE CONFIDENTIAL
 *
 * Copyright 2016 Adobe Systems Incorporated
 * All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and may be covered by U.S. and Foreign Patents,
 * patents in process, and are protected by trade secret or copyright law.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 */

(function() {
  'use strict';

  var DEFAULT_DATE_FORMAT = 'll';

  function debounce(func, wait) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  Coral.register({
    name: 'DateRangePicker',
    namespace: window.Aeon,
    tagName: 'aeon-daterangepicker',
    className: 'aeon-DateRangePicker',

    properties: {
      value: {
        default: '',
        sync: function() {
          this._elements.daterangedisplay.innerHTML = moment(this.value).format(DEFAULT_DATE_FORMAT);
          this._elements.daterangeinput.value = this.value;
        }
      },
      'invalid': {
        sync: function() {
          var invalid = this.invalid;
          var $daterangeinput = this._elements.daterangeinput.$;

          $daterangeinput.toggleClass('is-invalid', invalid);
          this._elements.daterangeinput.invalid = invalid;
          this._elements.daterangeinput.setAttribute('aria-invalid', invalid);
        }
      },
      'popover': {
        reflectAttribute: true,
        set: function(popover) {
          this._popover = popover;
          this._boundPopover = document.querySelector(popover);
        },
        get: function() {
          return this._boundPopover;
        }
      }
    },

    events: {
      'click': 'onClick'
    },

    _render: function() {
      // compatibility with CoralUI
      this.$ = $(this);

      var template = Coral.templates.Aeon.daterangepicker.call(this._elements);
      this.appendChild(template);
    },

    onClick: function(e){
      this.togglePopover(e);
      this.toggleInput(e);
    },

    toggleInput: function() {
      if(!this.classList.contains('is-active')) {
        this.enableInput();
      } else {
        this.disableInput();
      }
    },

    togglePopover: function() {
      var popover;
      if(this.popover === null) {
        this.popover = this._popover;
      }
      popover = this.popover;
      popover.target = this;
      popover.datePicker = this;
      popover.show();
      this.focusInput();
    },

    enableInput: function() {
      this.classList.add('is-active');
      this.focusInput();
    },

    disableInput: function() {
      this.classList.remove('is-active');
    },

    focusInput: function(val) {
      var WAIT = 100;
      var me = this;
      var debounceFocus = debounce(function(val){
        var inputField = me._elements.daterangeinput;
        if (me.popover) {
          me.popover.returnFocusTo(me);
        }
        if(me.popover && !me.popover.open) {
          me.popover.show();
        }
        if (typeof val !== 'undefined') {
          inputField.value = val;
        }
        inputField.focus();
      }, WAIT);

      debounceFocus(val);
    }

  });

}());
