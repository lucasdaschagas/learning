 <%--
  ADOBE CONFIDENTIAL

  Copyright 2015 Adobe Systems Incorporated
  All Rights Reserved.

  NOTICE:  All information contained herein is, and remains
  the property of Adobe Systems Incorporated and its suppliers,
  if any.  The intellectual and technical concepts contained
  herein are proprietary to Adobe Systems Incorporated and its
  suppliers and may be covered by U.S. and Foreign Patents,
  patents in process, and are protected by trade secret or copyright law.
  Dissemination of this information or reproduction of this material
  is strictly forbidden unless prior written permission is obtained
  from Adobe Systems Incorporated.
--%><%
 %><%@include file="/libs/dam/gui/coral/components/commons/ui/viewsettings/viewsettings.jsp" %><%
%><%@page import="java.time.ZoneId,
                  java.time.ZonedDateTime,
                  java.time.format.DateTimeFormatter,
                  java.time.format.FormatStyle,
                  java.util.ArrayList,
                  java.util.Calendar,
                  java.util.Collections,
                  org.apache.commons.lang3.tuple.MutablePair,
                  org.apache.commons.lang3.tuple.Pair,
                  java.util.Comparator,
                  java.util.Date,
                  java.util.HashMap,
                  java.util.Iterator,
                  java.util.LinkedList,
                  java.util.List,
                  java.util.Locale,
                  java.util.Map,
                  java.util.ResourceBundle,
                  java.io.UnsupportedEncodingException,
                  javax.jcr.Node,
                  javax.jcr.RepositoryException,
                  javax.jcr.security.AccessControlManager,
                  java.net.URLDecoder,
                  org.apache.commons.lang.StringUtils,
                  org.apache.jackrabbit.util.Text,
                  org.apache.sling.api.SlingHttpServletRequest,
                  org.apache.sling.api.resource.Resource,
                  org.apache.sling.api.resource.ResourceResolver,
                  org.apache.sling.api.resource.ValueMap,
                  org.apache.sling.api.scripting.SlingScriptHelper,
                  org.apache.sling.featureflags.Features,
                  org.apache.sling.caconfig.resource.ConfigurationResourceResolver,
                  org.json.JSONException,
                  org.json.JSONObject,
                  org.json.JSONArray,
                  com.adobe.granite.security.user.UserPropertiesManager,
                  com.adobe.granite.security.user.UserProperties,
                  com.adobe.dam.print.ids.StringConstants,
                  com.adobe.granite.security.user.util.AuthorizableUtil,
                  com.adobe.granite.security.user.UserPropertiesService,
                  org.apache.jackrabbit.api.security.user.Authorizable,
                  com.adobe.granite.ui.components.AttrBuilder,
                  com.adobe.granite.ui.components.Tag,
                  com.day.cq.commons.LanguageUtil,
                  com.day.cq.dam.api.Asset,
                  com.day.cq.dam.api.DamConstants,
                  com.day.cq.dam.api.Rendition,
                  com.day.cq.dam.api.thumbnail.DefaultThumbnailService,
                  com.day.cq.dam.commons.util.DynamicMediaServicesConfigUtil,
                  com.day.cq.dam.commons.util.UIHelper,
                  com.day.cq.dam.commons.util.DamUtil,
                  com.day.cq.dam.entitlement.api.EntitlementConstants,
                  com.day.cq.i18n.I18n,
                  com.day.cq.replication.ReplicationQueue,
                  com.day.cq.replication.ReplicationStatus,
                  com.day.cq.wcm.msm.api.LiveRelationshipManager,
                  com.day.cq.workflow.exec.Workflow,
                  com.day.cq.workflow.status.WorkflowStatus,
                  static com.adobe.granite.workflow.job.AbsoluteTimeoutHandler.ABS_TIME,
                  static com.day.cq.commons.jcr.JcrConstants.JCR_CONTENT,
                  static com.day.cq.commons.jcr.JcrConstants.JCR_TITLE,
                  static com.day.cq.commons.servlets.AbstractListServlet.ListItem.SCHEDULED_ACTIVATION_WORKFLOW_ID,
                  static com.day.cq.commons.servlets.AbstractListServlet.ListItem.SCHEDULED_DEACTIVATION_WORKFLOW_ID"%><%
%><%@taglib prefix="cq" uri="http://www.day.com/taglibs/cq/1.0"%><%
%><%--###
Base API
=========
This JSP is included by spawned pages, hence it may gets called multiple time. This JSP should not evaluate or perform any execution task,
rather it should only contain methods & configs to avoid performance overhead.
###--%><%
//Attributes set by \contentrenderer\base\init\base.jsp should be accessed through following constants

final String ASSET = "com.adobe.cq.assets.contentrenderer.asset";

final String RESOURCE_NODE = "com.adobe.cq.assets.contentrenderer.resourceNode";

final String REQUEST_PREFIX = "com.adobe.cq.assets.contentrenderer.requestPrefix";

final String REQUEST_SUFFIX = "com.adobe.cq.assets.contentrenderer.requestSuffix";

final String CACHE_KILLER = "com.adobe.cq.assets.contentrenderer.ck";

final String ENABLED_DYNAMIC_MEDIA = "com.adobe.cq.assets.contentrenderer.enabledDynamicMedia";

final String ENABLED_DYNAMIC_MEDIA_SCENE7 = "com.adobe.cq.assets.contentrenderer.enabledDynamicMediaScene7";

final String PUBLISH_DATE_IN_MILLIS = "com.adobe.cq.assets.contentrenderer.publishDateInMillis";

final String PUBLISHED_DATE = "com.adobe.cq.assets.contentrenderer.publishedDate";

final String IS_DEACTIVATED = "com.adobe.cq.assets.contentrenderer.isDeactivated";

final String PUBLISHED_BY = "com.adobe.cq.assets.contentrenderer.publishedBy";

final String SHOW_DESKTOP_LINKS = "com.adobe.cq.assets.contentrenderer.showDesktopLinks";

final String RESOURCE_PATH = "com.adobe.cq.assets.contentrenderer.resourcePath";

final String TYPE = "com.adobe.cq.assets.contentrenderer.type";

final String RESOURCE_TITLE = "com.adobe.cq.assets.contentrenderer.resourceTitle";

final String RESOURCE_ABSOLUTE_TITLE = "com.adobe.cq.assets.contentrenderer.resourceAbsTitle";

final String TIMELINE = "com.adobe.cq.assets.contentrenderer.timeLine";

final String IS_FOLDER = "com.adobe.cq.assets.contentrenderer.isFolder";

final String ACTION_RELS = "com.adobe.cq.assets.contentrenderer.actionRels";

final String SHOW_QUICK_ACTIONS = "com.adobe.cq.assets.contentrenderer.showQuickActions";

final String NAVIGATION_ALLOWED = "com.adobe.cq.assets.contentrenderer.allowNavigation";

final String IS_MERGED_PRINT_TEMPLATE = "com.adobe.cq.assets.contentrenderer.asset.isMergedPrintAsset";

final String HAS_REPLICATE_ACCESS = "com.adobe.cq.assets.contentrenderer.replicateAccess";

final String IS_OMNISEARCH_REQUEST = "com.adobe.cq.assets.contentrenderer.isOmniSearchRequest";

final String IS_SNIPPET_REQUEST = "com.adobe.cq.assets.contentrenderer.isSnippetRequest";

final String ASSET_VANITY = "/assets.html";

final String VIEW_SETTINGS = "com.adobe.cq.assets.contentrenderer.view.settings";

final String IS_LIVE_COPY = "com.adobe.cq.assets.contentrenderer.asset.isLiveCopy";

%><%!
final String RENDITION_TYPE_OGG = "rendition.ogg";
final String RENDITION_TYPE_MP4 = "rendition.mp4";
final String RENDITION_TYPE_MPEG = "rendition.mpeg";
final String RENDITION_TYPE_WAV = "rendition.wav";
final String RENDITION_TYPE_M4V = "rendition.m4v";
final String RENDITION_TYPE_PROXY = "rendition.proxy";
final String RENDITION_TYPE_PROXY_THUMB = "rendition.proxy.thumbnail";
final String RENDITION_TYPE_PROXY_MIMETYPE = "rendition.proxy.mimetype";
final String SHOW_INSIGHT = "showInsight";

final long MAX_PREVIEW_SIZE = 5*(1024*1024); //max is 5MB

final String REPLICATION_ACTION_STATUS_PROP = "dam:portalReplicationAction";
final String REPLICATION_LAST_PUBLISHED = "dam:portalReplicationDate";

private List<String> getActionRels(Resource resource, Asset asset, AccessControlManager acm) {
    List<String> actionRels = new ArrayList<String>();
    return actionRels;
}


private String getThumbnailUrl(Asset asset, int width,
        boolean showOriginalIfNoRenditionAvailable, boolean showOriginalForGifImages, SlingScriptHelper sling) {
    final DefaultThumbnailService thumbnailService = sling.getService(DefaultThumbnailService.class);
    if (thumbnailService != null && asset == null) {
        return thumbnailService.getDefaultThumbnail(null); // thumbnail service handles null mimetype
    }
    String thumbnailUrl;
    String mimeType = asset.getMimeType();
    Rendition thumbnailRendition = UIHelper.getBestfitRendition(asset, width);
    if (thumbnailRendition != null) {
        if ("image/gif".equals(mimeType) && showOriginalForGifImages) {
            Rendition originalRendition = asset.getRendition(DamConstants.ORIGINAL_FILE);
            thumbnailUrl = originalRendition.getPath();
        } else if (DamConstants.ORIGINAL_FILE.equals(thumbnailRendition.getName()) && !showOriginalIfNoRenditionAvailable) {
            thumbnailUrl = thumbnailService.getDefaultThumbnail(mimeType);
        } else {
            thumbnailUrl = asset.getPath() + "/jcr:content/renditions/" + thumbnailRendition.getName();
        }
    } else {
        Rendition originalRendition = asset.getRendition(DamConstants.ORIGINAL_FILE);
        String size = asset.getMetadata(DamConstants.DAM_SIZE) != null? asset.getMetadata(DamConstants.DAM_SIZE).toString(): null;
        if(originalRendition != null && UIHelper.canRenderOnWeb(originalRendition.getMimeType()) && size != null && Long.parseLong(size) < MAX_PREVIEW_SIZE){
            //use original thumbnail if condition is met
            thumbnailUrl = originalRendition.getPath();
        }else{
            thumbnailUrl = thumbnailService.getDefaultThumbnail(mimeType);
        }
    }
    thumbnailUrl = Text.escapePath(thumbnailUrl);
    return thumbnailUrl;
}


private List<String> getActionRels(boolean hasWorkflowMgmt, boolean hasReplicate,boolean hasRemoveNode, boolean hasModifyAccessControl, boolean hasModifyProperties, boolean hasAddChild, boolean isExpiredAsset, boolean isExpiredSubAsset, boolean isDAMAdmin, boolean isContentFragment) {
	return getActionRels(null, hasWorkflowMgmt, hasReplicate, hasRemoveNode, hasModifyAccessControl, hasModifyProperties, hasAddChild, isExpiredAsset, isExpiredSubAsset, isDAMAdmin, isContentFragment, false);
}

private List<String> getActionRels(Node node, boolean hasWorkflowMgmt, boolean hasReplicate,boolean hasRemoveNode, boolean hasModifyAccessControl, boolean hasModifyProperties, boolean hasAddChild, boolean isExpiredAsset, boolean isExpiredSubAsset, boolean isDAMAdmin, boolean isContentFragment, boolean isSmartCropped) {

    List<String> actionRels = new ArrayList<String>();
    boolean isDMAsset = false;
    boolean isDMSet = false;
    if(node != null){
        try{
            if (node.hasProperty("jcr:content/metadata/dam:scene7ID")) {
                String dmType = node.hasProperty("jcr:content/dam:s7damType") ? node.getProperty("jcr:content/dam:s7damType").getString() : "";
                isDMAsset = true;
                if (dmType.endsWith("Set")){
                    isDMSet = true;
                }
            }
        } catch(Exception ex){
        }
    }

    actionRels.add("cq-damadmin-admin-actions-removefromcollection");
    if(isDAMAdmin || (!isExpiredAsset && !isExpiredSubAsset)) {
        boolean canShare = false;
        actionRels.add("cq-siteadmin-admin-actions-copy-activator");

        if(hasWorkflowMgmt || hasReplicate ) {
            actionRels.add("cq-siteadmin-admin-actions-publish-activator");
        }
        if (hasReplicate) {
            actionRels.add("cq-damadmin-admin-actions-publish-activator");
            if (!isDMSet && !isContentFragment) {
                actionRels.add("cq-damadmin-admin-actions-mpshare-activator");
            }
            if (isDMAsset){
                actionRels.add("cq-damadmin-admin-actions-dmpublish-activator");
            }
        }

        if (hasRemoveNode) {
            actionRels.add("cq-damadmin-admin-actions-move-activator");
        }

        if (hasModifyAccessControl) {
            canShare = true;
            actionRels.add("cq-damadmin-admin-actions-adhocassetshare-activator");
            actionRels.add("cq-damadmin-admin-actions-publicLinkShare-activator");
        }

        if (canShare) {
            actionRels.add("cq-damadmin-admin-actions-share-activator");
        }

        if (hasModifyProperties && hasAddChild) {
            actionRels.add("cq-damadmin-admin-actions-create-activator");
        }
    }

    if (hasReplicate) {
            actionRels.add("cq-damadmin-admin-actions-unpublish-activator");
            actionRels.add("cq-siteadmin-admin-actions-unpublish-activator");
            if (!isDMSet && !isContentFragment) {
                actionRels.add("cq-damadmin-admin-actions-mpunshare-activator");
            }
            if (isDMAsset){
                actionRels.add("cq-damadmin-admin-actions-dmpublish-activator");
            }
    }
    if (hasRemoveNode) {
            actionRels.add("cq-damadmin-admin-actions-delete-activator");
    }

    if(isSmartCropped) {
        actionRels.add("cq-damadmin-admin-actions-smartcrop-activator");
    }

    return actionRels;
}

private String getDisplayLanguage(String sourcePath, Boolean asset) {
        String locale = null;
        Locale localeObj = null;
        String langValue = "";
        String root = LanguageUtil.getLanguageRoot(sourcePath);
        if (root != null && !(asset && root.equals(sourcePath))) {
            locale = root.substring(root.lastIndexOf("/") + 1);
        }
        if (locale != null) {
            localeObj = LanguageUtil.getLocale(locale);
            if (localeObj != null) {
                langValue = localeObj.getDisplayLanguage();
            }
            langValue += " (" + locale + ")";
        }
        return langValue;
    }

    private boolean isMergedPrintTemplate(Node resourceNode) {
        try {
            return (resourceNode.hasProperty("jcr:content/metadata/"+StringConstants.MERGED_TYPE) &&
                    resourceNode.getProperty("jcr:content/metadata/"+StringConstants.MERGED_TYPE).getString().equals(StringConstants.MERGED_TYPE_TEMPLATE));
        } catch (Exception ex) {
            log("Exception occurred while checking whether the asset is Merged print Template "
                    + ex.getMessage());
        }
        return false;
    }

    private boolean isMergedPrintAsset(Node resourceNode) {
        try {
            return (resourceNode.hasNode("jcr:content/related/"+StringConstants.CATALOG_RELATION));
        } catch (Exception ex) {
            log("Exception occurred while checking whether the asset is Merged print asset "
                    + ex.getMessage());
        }
        return false;
    }

    private boolean hasIndesignTags(Node resourceNode){
        try {
            return (resourceNode.hasNode("jcr:content/renditions/"+getResourceName(resourceNode)+".xml"));
        } catch (Exception ex) {
            log("Exception occurred while checking whether the asset has indesign tag's xml exported "
                    + ex.getMessage());
        }
        return false;
    }

    private static String getResourceName(Node resNode) throws RepositoryException {
        //get the name of the ID print template
        String name = resNode.getName();
        int idx = name.lastIndexOf('.');
        if(idx > 0) {
            name = name.substring(0, idx);
        }
        return name;
    }

    private String getProxyRenditionProperty(Rendition rendition, String propName){
        final ValueMap map = rendition.getProperties();
        String propVal = null;
        if (map != null){
            propVal = map.get(propName, "");
        }
        return propVal;
    }

     /***
      * @return A map containing all the renditions for playing the video
      * if originalAllowed is false ,don't consider original rendition
      */
    private Map<String,String> getVideoRenditions(Asset asset, SlingScriptHelper sling){
        String oggRenditionPath = null,mp4RenditionPath = null,m4VRenditionPath = null;
        Map<String,String > renditions = new HashMap();
        SlingHttpServletRequest request = sling.getRequest();
        boolean originalAllowed =  (null != request.getAttribute("allowOriginal")) ? ((Boolean)request.getAttribute("allowOriginal")) : true;
        boolean isDynamicMediaEnabled = false;
        String proxyRenditionPath = null;
        String proxyRenditionMimeType = null;
        String proxyRenditionPostImg = null;
        final Features featureManager = sling.getService(Features.class);
        if (featureManager.getFeature(EntitlementConstants.ASSETS_DYNAMICMEDIA_FEATURE_FLAG_PID)!=null &&
                featureManager.isEnabled(EntitlementConstants.ASSETS_DYNAMICMEDIA_FEATURE_FLAG_PID)) {
            isDynamicMediaEnabled = true;
        }

        for (Iterator<Rendition> it = asset.listRenditions(); it.hasNext();) {
            Rendition rendition = it.next();
            String renditionMimeType = rendition.getMimeType();
            //if original rendition is not allowed in link share, don't set it as source
            if(!originalAllowed && "original".equals(rendition.getName())){
                continue;
            }
            // check if its a proxy rendition by its proxyurl. So making sure the amazon video will work
             String proxyUrl = null;
            if (isDynamicMediaEnabled) {
                proxyUrl = getProxyRenditionProperty(rendition, "dam:proxyUrl");
            }

            if (StringUtils.isNotEmpty (proxyUrl)) {
                String serverUrl = DynamicMediaServicesConfigUtil.getServiceUrl(request.getResourceResolver());
                proxyRenditionPath = serverUrl + "private/" + DynamicMediaServicesConfigUtil.getRegistrationId(request.getResourceResolver()) + proxyUrl;
                proxyRenditionMimeType = rendition.getMimeType();
                proxyRenditionPostImg =  "/is/image" + asset.getPath();

            }else if (null != renditionMimeType) {
                if (renditionMimeType.equals("video/ogg")) {
                    oggRenditionPath = rendition.getPath();
                }

                if (renditionMimeType.equals("video/mp4")) {
                    mp4RenditionPath = rendition.getPath();
                }
                // handling mime types video/m4v, video/x-m4v
                if ( rendition.getMimeType().endsWith("m4v")) {
                    m4VRenditionPath = rendition.getPath();
                }
            }
        }
        if(oggRenditionPath != null){
            renditions.put(RENDITION_TYPE_OGG,oggRenditionPath);
        }
        if(mp4RenditionPath != null) {
            renditions.put(RENDITION_TYPE_MP4, mp4RenditionPath);
        }
        if(m4VRenditionPath != null) {
            renditions.put(RENDITION_TYPE_M4V, m4VRenditionPath);
        }

        if(proxyRenditionPath != null){
            renditions.put(RENDITION_TYPE_PROXY,proxyRenditionPath);
            renditions.put(RENDITION_TYPE_PROXY_THUMB,proxyRenditionPostImg);
            renditions.put(RENDITION_TYPE_PROXY_MIMETYPE,proxyRenditionMimeType);
        }
        return renditions;
    }

    /**
      * check if the given resource can be rendered as video
      * @return true , if resource can be played as video, false otherwise
     */
    private boolean isSupportedVideo(Asset asset, SlingScriptHelper sling){
        if(asset != null){
            boolean originalAllowed =  (null != sling.getRequest().getAttribute("allowOriginal")) ? ((Boolean)sling.getRequest().getAttribute("allowOriginal")) : true;
            String mimeType = asset.getMimeType();
            if(null == mimeType){
                return false;
            }

            if (mimeType.contains("video") || mimeType.equals("application/x-shockwave-flash")) {
                Map<String,String> availableRenditions = getVideoRenditions(asset,sling);
                if(!availableRenditions.isEmpty() || ( originalAllowed && (mimeType.equals("video/mp4")
                        || mimeType.equals("video/ogg") || mimeType.equals("video/quicktime")
                        || mimeType.equals("video/webm") || mimeType.equals("video/x-ms-wmv")
                        || mimeType.equals("application/x-shockwave-flash")))){
                    return  true;
                }
            }
        }
        return false;
    }

     /***
      * @return A map containing all the renditions for playing the aideo
      * if originalAllowed is false ,don't consider original rendition
      */
    private Map<String,String> getAudioRenditions(Asset asset, SlingScriptHelper sling) {
        String oggAudioRenditionPath = null;
        String mpegAudioRenditionPath = null;
        String wavAudioRenditionPath = null;
        Map<String,String > renditions = new HashMap();
        SlingHttpServletRequest request = sling.getRequest();
        boolean originalAllowed =  (null != request.getAttribute("allowOriginal")) ? ((Boolean)request.getAttribute("allowOriginal")) : true;
        for (Iterator<Rendition> it = asset.listRenditions(); it.hasNext();) {
            Rendition rendition = it.next();
            //if original rendition is not allowed in link share, don't set it as source
            if(!originalAllowed && "original".equals(rendition.getName())){
                continue;
            }
            if (rendition.getMimeType().equals("audio/ogg")) {
                oggAudioRenditionPath = rendition.getPath();
            }

            if (rendition.getMimeType().equals("audio/mpeg")) {
                mpegAudioRenditionPath = rendition.getPath();
            }
            if( rendition.getMimeType().equals("audio/x-wav") || rendition.getMimeType().equals("audio/wav") ) {
                wavAudioRenditionPath = rendition.getPath();
            }

        }
        if(oggAudioRenditionPath != null){
            renditions.put(RENDITION_TYPE_OGG,oggAudioRenditionPath);
        }
        if(mpegAudioRenditionPath != null) {
            renditions.put(RENDITION_TYPE_MPEG, mpegAudioRenditionPath);
        }
        if(wavAudioRenditionPath != null) {
            renditions.put(RENDITION_TYPE_WAV, wavAudioRenditionPath);
        }
        return renditions;
    }


    /**
      * check if the given resource can be rendered as audio
      * @return true , if resource can be played as audio, false otherwise
     */
    private boolean isSupportedAudio(Asset asset, SlingScriptHelper sling){
        if(asset != null){
            boolean originalAllowed =  (null != sling.getRequest().getAttribute("allowOriginal")) ? ((Boolean)sling.getRequest().getAttribute("allowOriginal")) : true;
            String mimeType = asset.getMimeType();
            if(null == mimeType){
                return false;
            }

            if (mimeType.contains("audio") ) {
                Map<String,String> availableRenditions = getAudioRenditions(asset,sling);
                if(!availableRenditions.isEmpty() || ( originalAllowed && (mimeType.equals("audio/mpeg") || mimeType.equals("audio/ogg") || mimeType.equals("audio/x-wav")))){
                    return  true;
                }
            }
        }
        return false;
    }

    /** Method to check if original rendition is allowed for audio/video source
     * @return false, if allowOriginal attribute is false, true otherwise
     */
    private boolean isOriginalAllowed(HttpServletRequest request){
        return  (null != request.getAttribute("allowOriginal")) ? ((Boolean)request.getAttribute("allowOriginal")) : true;
    }

     /**
      *Method to extract title of an resource, unlike UIHelper.getTitle it doesn't fallback to resource's name
      */
     private String getResourceTitle(Resource resource, String defaultTitle) {
    	 return DamUtil.getTitle(resource);
     }



     private String getStatus(int maxQueuePos, String actionType, I18n i18n) {
         String status = "";
         if (maxQueuePos > 0) {
             if ("Activate".equals(actionType)) {
                 status = i18n.get("Publication Pending. #{0} in the queue.", "0 is the position in the queue", maxQueuePos);
             } else {
                 status = i18n.get("Un-publication Pending. #{0} in the queue.", "0 is the position in the queue", maxQueuePos);
             }
         }
         return status;
     }

     /**
      * Publication Related Methods
      */
     private String getPublicationPendingStatus(ReplicationStatus replicationStatus, I18n i18n) {
         if (replicationStatus == null) return "";
         String actionType = "";
         int maxQueuePos = -1;
         for (ReplicationQueue.Entry e : replicationStatus.getPending()) {
             if (e.getQueuePosition() > maxQueuePos) {
                 maxQueuePos = e.getQueuePosition();
                 actionType = e.getAction().getType().getName();
             }
         }
         maxQueuePos = maxQueuePos + 1;

         return getStatus(maxQueuePos, actionType, i18n);
     }




     /**
      * Publication Related Methods
      */
     private String getPublicationPendingStatus(HttpServletRequest request, Resource resource , I18n i18n) {
          String actionType = "";
          int maxQueuePos = -1;
          String path = resource.getPath();
          Map<String, Pair <String,Integer>>  buildEntryMap =  (Map<String, Pair <String,Integer>>)request.getAttribute("buildEntryMap");
          if(buildEntryMap != null && buildEntryMap.containsKey(path)) {
              Pair<String, Integer> pair = buildEntryMap.get(path);
              actionType = pair.getKey();
              maxQueuePos = pair.getValue();
          }


          maxQueuePos = maxQueuePos + 1;

          return getStatus(maxQueuePos, actionType, i18n);
     }


     private String getOnOffTimeStatus(ValueMap properties, I18n i18n, Locale locale) {
         if (properties == null) return "";

         Calendar onTimeDate = properties.get("onTime", Calendar.class);
         Calendar offTimeDate = properties.get("offTime", Calendar.class);

         String status = "";

         if (onTimeDate != null) {
             status += i18n.get("On Time") + ": ";
             status += formatTime(locale, onTimeDate.getTimeInMillis());
         }
         if (offTimeDate != null) {
             status += (status.length() > 0) ? "\n" : "";
             status += i18n.get("Off Time") + ": ";
             status += formatTime(locale, offTimeDate.getTimeInMillis());
         }
         return status;
     }

     private String formatTime(Locale locale, Long time) {
         DateTimeFormatter pattern = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM);
         ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(new Date(time).toInstant(), ZoneId.systemDefault());
         return zonedDateTime.format(pattern);
     }

     /**
      * Single object that contains all publication info for
      * current resource. Can be used uniformly across all three views.
      */

     private static class PublicationStatus {

         private String action;
         private boolean pending;
         private boolean later;

         private Date lastReplicationDate;
         private String pendingStatus;
         private String laterStatus;

         String getAction() {
             return action;
         }

         void setAction(String action) {
             this.action = action;
         }

         boolean isPending() {
             return pending;
         }

         void setPending(boolean pending) {
             this.pending = pending;
         }

         boolean isLater() {
             return later;
         }

         void setLater(boolean later) {
             this.later = later;
         }

         public Date getLastReplicationDate() {
             return lastReplicationDate;
         }

         public void setLastReplicationDate(Date lastReplicationDate) {
             this.lastReplicationDate = lastReplicationDate;
         }

         String getPendingStatus() {
             return pendingStatus;
         }

         void setPendingStatus(String pendingStatus) {
             this.pendingStatus = pendingStatus;
         }

         String getLaterStatus() {
             return laterStatus;
         }

         void setLaterStatus(String laterStatus) {
             this.laterStatus = laterStatus;
         }

         public String getIcon() {
             String icon = null;
             if (action.equalsIgnoreCase("PUBLISH")) {
                 icon = "globe";
             } else if (action.equalsIgnoreCase("UNPUBLISH")) {
                 icon = "globeStrike";
             }
             return icon;
         }

         public String getBriefStatus() {
             String briefStatus = "";
             if (this.isLater()) {
                 briefStatus = "Later";
             }
             if (this.isPending()) {
                 briefStatus = "Pending";
             }
             return briefStatus;
         }

         public String getDetailedStatus() {
             String detailedStatus = "";
             if (this.isLater()) {
                 detailedStatus = laterStatus;
             }
             if (this.isPending()) {
                 detailedStatus = pendingStatus;
             }
             return detailedStatus;
         }
     }

     private PublicationStatus getOtherPublicationStatus(HttpServletRequest httpRequest, Resource resource, I18n i18n) {
         PublicationStatus status = new PublicationStatus();
         Map<String, Pair <String,Integer>>  buildEntryMap =  (Map<String, Pair <String,Integer>>)httpRequest.getAttribute("buildEntryMap");

         String pendingStatus;

         if(buildEntryMap != null) {
             pendingStatus = getPublicationPendingStatus(httpRequest, resource, i18n);
         } else {
             ReplicationStatus replicationStatus = resource.adaptTo(ReplicationStatus.class);
             pendingStatus =  getPublicationPendingStatus(replicationStatus, i18n);
         }


         if (pendingStatus.length() > 0) {
             status.setPending(true);
             status.setPendingStatus(pendingStatus);
             if (pendingStatus.startsWith("Publication")) {
                 status.setAction("PUBLISH");
             } else {
                 status.setAction("UNPUBLISH");
             }
         } else {
             WorkflowStatus workflowStatus = resource.adaptTo(WorkflowStatus.class);
             List<Workflow> workflows = getScheduledWorkflows(workflowStatus);
             if (!workflows.isEmpty()) {
                 status.setLater(true);
                 status.setLaterStatus(getScheduledStatus(workflows, i18n, resource, httpRequest));
                 if (isScheduledActivationWorkflow(workflows.get(workflows.size() - 1))) {
                     status.setAction("PUBLISH");
                 } else {
                     status.setAction("UNPUBLISH");
                 }
             }
         }


         if (!status.isPending() && !status.isLater()) {
             Resource jcrContentResource = resource.getChild(JCR_CONTENT);
             if (null != jcrContentResource) {
                 ValueMap assetVM = jcrContentResource.getValueMap();
                 Calendar lastReplicated = assetVM.get("cq:lastReplicated", Calendar.class);
                 if (null != lastReplicated) {
                     status.setLastReplicationDate(lastReplicated.getTime());
                 }
                 String lastReplicationAction = assetVM.get("cq:lastReplicationAction", String.class);
                 if ("Deactivate".equals(lastReplicationAction)) {
                     status.setAction("UNPUBLISH");
                 } else if ("Activate".equals(lastReplicationAction)) {
                     status.setAction("PUBLISH");
                 }
             }
         }

         return status;
     }

     private PublicationStatus getPublicationStatus(HttpServletRequest httpRequest, Resource resource, I18n i18n) {
         PublicationStatus status = new PublicationStatus();
         Resource contentResource = resource.getChild(JCR_CONTENT);
         if (contentResource != null) {
             ValueMap valueMap = contentResource.adaptTo(ValueMap.class);
             // Check if BP distribution date is newer or equal to AEM Publish replication date.
             // If yes, we update BP related properties. Otherwise we switch to AEM Publish flow.
             if (valueMap.containsKey(REPLICATION_ACTION_STATUS_PROP) &&
                (!valueMap.containsKey(REPLICATION_LAST_PUBLISHED) ||
                (valueMap.get(DamConstants.PN_PAGE_LAST_REPLICATED, Calendar.class) != null &&
                valueMap.get(REPLICATION_LAST_PUBLISHED, Calendar.class).compareTo(valueMap.get(DamConstants.PN_PAGE_LAST_REPLICATED, Calendar.class)) >= 0))) {
           	    String statusProp = valueMap.get(REPLICATION_ACTION_STATUS_PROP, String.class);
           	    Calendar replicateTime = valueMap.get(REPLICATION_LAST_PUBLISHED, Calendar.class);
           	    if ("ActivateQueued".equals(statusProp)) {
           	    	status.setPending(true);
           	    	status.setPendingStatus(i18n.get("Publication Pending."));
           	    	status.setAction("PUBLISH");
           	    }
           	    if ("DeactivateQueued".equals(statusProp)) {
           	    	status.setPending(true);
           	    	status.setPendingStatus(i18n.get("Un-publication Pending."));
           	    	status.setAction("UNPUBLISH");
           	    }
           	    if ("Activate".equals(statusProp)) {
           	    	status.setAction("PUBLISH");
           	    	if (replicateTime != null) {
           	    	    status.setLastReplicationDate(replicateTime.getTime());
           	    	}
           	    }
           	    if ("Deactivate".equals(statusProp)) {
           	    	status.setAction("UNPUBLISH");
           	    	if (replicateTime != null) {
           	    	    status.setLastReplicationDate(replicateTime.getTime());
           	    	}
           	    }
           	    if ("ActivateErrored".equals(statusProp) || "DeactivateErrored".equals(statusProp)) {
           	    	// BP distribution error status not to be shown - fallback to previous status..
           	    	return getOtherPublicationStatus(httpRequest, resource, i18n);
           	    }
           	    return status;
             } else {
                 return getOtherPublicationStatus(httpRequest, resource, i18n);
             }
         } else {
             return getOtherPublicationStatus(httpRequest, resource, i18n);
         }
     }

     private PublicationStatus getPublicationStatus(HttpServletRequest httpRequest, I18n i18n) {
         SlingHttpServletRequest request = (SlingHttpServletRequest) httpRequest;
         Resource resource = request.getResource();
         return getPublicationStatus(httpRequest, resource, i18n);
     }

     private String getScheduledStatus(List<Workflow> scheduledWorkflows, I18n i18n, Resource resource,
                                       HttpServletRequest servletRequest)
     {
         SlingHttpServletRequest httpServletRequest = (SlingHttpServletRequest) servletRequest;
         String resourcePath = resource.getPath();
         StringBuilder status = new StringBuilder();
         int i = 0;

         for (Workflow scheduledWorkflow : scheduledWorkflows) {
             if (i > 0) {
                 status.append("\n\n");
             }

             if (isScheduledActivationWorkflow(scheduledWorkflow)) {
                 status.append(i18n.get("Publication Pending")).append("\n");
                 try {
                     String versions = scheduledWorkflow.getWorkflowData().getMetaDataMap().get("versions", String.class);
                     if (versions != null) {
                         JSONObject jsonObject = new JSONObject(versions);
                         String version = jsonObject.get(resourcePath).toString();
                         if (StringUtils.isNotEmpty(version)) {
                             status.append(i18n.get("Version")).append(": ").append(version).append("\n");
                         }
                     }
                 } catch (JSONException jse) {
                     // ignore
                 }
             } else {
                 status.append(i18n.get("Un-publication Pending")).append("\n");
             }

             status.append(i18n.get("Scheduled")).append(": ");
             Long workflowABSTime = scheduledWorkflow.getWorkflowData().getMetaDataMap().get(ABS_TIME, Long.class);
             if (workflowABSTime != null) {
                 status.append(formatTime(httpServletRequest.getLocale(), workflowABSTime));
             }
             status.append(" (")
                     .append(AuthorizableUtil.getFormattedName(
                         httpServletRequest.getResourceResolver(), scheduledWorkflow.getInitiator()))
                     .append(")");
             i++;
         }

         return status.toString();
     }

     private List<Workflow> getScheduledWorkflows(WorkflowStatus workflowStatus) {
         List<Workflow> scheduledWorkflows = new LinkedList<Workflow>();

         // Get the scheduled workflows
         if (workflowStatus != null) {
             List<Workflow> workflows = workflowStatus.getWorkflows(false);
             for (Workflow workflow : workflows) {
                 if (isScheduledActivationWorkflow(workflow) || isScheduledDeactivationWorkflow(workflow)) {
                     scheduledWorkflows.add(workflow);
                 }
             }
         }

         // Sort the scheduled workflows by time started
         Collections.sort(scheduledWorkflows, new Comparator<Workflow>() {
             public int compare(Workflow o1, Workflow o2) {
                 return o1.getTimeStarted().compareTo(o2.getTimeStarted());
             }
         });

         return scheduledWorkflows;
     }
     // TODO: Replace constants with a workflow API tracked by CQ-4222642
     private boolean isScheduledActivationWorkflow(Workflow workflow) {
         final String SCHEDULED_ACTIVATION_WORKFLOW_ID_NEW = "/var/workflow/models/scheduled_activation";
         final String SCHEDULED_TREE_ACTIVATION_WORKFLOW_ID_VAR = "/var/workflow/models/scheduled_tree_activation";
         return (workflow != null
                     && (workflow.getWorkflowModel().getId().equals(SCHEDULED_ACTIVATION_WORKFLOW_ID)
                         || workflow.getWorkflowModel().getId().equals(SCHEDULED_ACTIVATION_WORKFLOW_ID_NEW)
                         || workflow.getWorkflowModel().getId().equals(SCHEDULED_TREE_ACTIVATION_WORKFLOW_ID_VAR))
                 );
     }

     private boolean isScheduledDeactivationWorkflow(Workflow workflow) {
         final String SCHEDULED_DEACTIVATION_WORKFLOW_ID_NEW = "/var/workflow/models/scheduled_deactivation";
         return (workflow != null
                     && (workflow.getWorkflowModel().getId().equals(SCHEDULED_DEACTIVATION_WORKFLOW_ID)
                        || workflow.getWorkflowModel().getId().equals(SCHEDULED_DEACTIVATION_WORKFLOW_ID_NEW))
                 );
     }

     private JSONObject getViewSettings(SlingScriptHelper sling) {
         Authorizable user =  sling.getRequest().getResourceResolver().adaptTo(Authorizable.class);
         UserPropertiesManager upm = sling.getRequest().getResourceResolver().adaptTo(UserPropertiesManager.class);
         Resource preferenceNode = null;
         String savedViewSetting = null;
         JSONObject jsonObj = null;
         UserProperties userProps = null;
         try {
             userProps = upm.getUserProperties(user.getID(), "");
             if(userProps != null) {
                 preferenceNode = userProps.getResource(UserPropertiesService.PREFERENCES_PATH);
             }
         } catch (RepositoryException e) {
             // can't read user preferences,use default settings
         }

         if(preferenceNode != null) {
             savedViewSetting = (String) preferenceNode.getValueMap().get(VIEW_SETTINGS_PREFERENCE_NAME);
         }

         if(sling.getRequest().getAttribute(SHOW_INSIGHT) != null || savedViewSetting == null) {
             // no preference saved, use default setting from configurations
             savedViewSetting = DEFAULT_VIEW_SETTING_NAME;
         }

         try {
             // return default view settings
             ValueMap confMap = getViewConfigValueMap(savedViewSetting, sling);
             if (confMap == null) {
                 // default fallback when no card settings configuration present
                 jsonObj = new JSONObject();
                 jsonObj.put(VIEW_SETTINGS_PN_NAME, DEFAULT_VIEW_SETTING_NAME);
                 jsonObj.put(VIEW_SETTINGS_PN_CARD_WIDTH, 242l);
                 jsonObj.put(VIEW_SETTINGS_PN_INSIGHT, false);
                 jsonObj.put(VIEW_SETTINGS_PN_DATE_FORMAT, "");
                 String[] propertiesToShow = new String[]{VIEW_PN_LAST_MODIFICATION, VIEW_PN_IS_MERGED_PRINT_TEMPLATE,
                         VIEW_PN_CHECKED_OUT_BY, VIEW_PN_PUBLISHED_DATE, VIEW_PN_STATUS,
                         VIEW_PN_IS_ASSETEXPIRED, VIEW_PN_SIZE, VIEW_PN_COMMENTS_COUNT, VIEW_PN_RESOLUTION,
                         VIEW_PN_AVERAGE_RATING};
                 JSONArray props = new JSONArray(propertiesToShow);
                 jsonObj.put(VIEW_SETTINGS_PN_PROPS, props);
             } else {
                 // return view settings default size configuration
                 jsonObj = new JSONObject();
                 jsonObj.put(VIEW_SETTINGS_PN_NAME, savedViewSetting);
                 jsonObj.put(VIEW_SETTINGS_PN_CARD_WIDTH, confMap.get(VIEW_SETTINGS_PN_CARD_WIDTH));
                 jsonObj.put(VIEW_SETTINGS_PN_INSIGHT, confMap.get(VIEW_SETTINGS_PN_INSIGHT));
                 jsonObj.put(VIEW_SETTINGS_PN_DATE_FORMAT, confMap.get(VIEW_SETTINGS_PN_DATE_FORMAT, ""));
                 String[] propertiesToShow = confMap.get(VIEW_SETTINGS_PN_PROPS, String[].class);
                 JSONArray props = new JSONArray(propertiesToShow);
                 jsonObj.put(VIEW_SETTINGS_PN_PROPS, props);
             }
         } catch (JSONException exp) {
             //ignore
         }
         return jsonObj;
     }

     private Resource getViewConfigResource(String cardSize, SlingScriptHelper sling) {
         ConfigurationResourceResolver configResResolver = sling.getService(ConfigurationResourceResolver.class);
         if (configResResolver != null) {
             Resource tenantAssetRootResource = sling.getRequest().getResourceResolver().getResource(DamUtil.getTenantAssetsRoot(sling.getRequest().getResourceResolver()));
             Resource resource = configResResolver.getResource(tenantAssetRootResource, VIEW_SETTINGS_CONFIG_BUCKET, VIEW_SETTINGS_CONFIG_PATH + "/" + cardSize);
             return resource;
         } else {
             return null;
         }
     }

     private ValueMap getViewConfigValueMap(String size, SlingScriptHelper sling) {
         Resource configRes = getViewConfigResource(size, sling);
         if (configRes != null) {
             return configRes.getValueMap();
         } else {
             return null;
         }
     }

     private List<String> getViewSettingProperties(JSONArray propArr){
         List<String> properties = new ArrayList<>();
         if(propArr != null) {
             try {
                 for (int i = 0; i < propArr.length(); i++) {
                     properties.add(propArr.getString(i));
                 }
             } catch (JSONException exp){
                 //ignore
             }
         }
         return properties;
     }

     private boolean isContentFragment(Resource resource) {
         Resource contentResource = resource.getChild(JCR_CONTENT);
         boolean isFragment = false;
         if (contentResource != null) {
             ValueMap contentProps = contentResource.adaptTo(ValueMap.class);
             isFragment = contentProps.get("contentFragment", false);
         }
         if (!isFragment) {
             return false;
         }
         // check if editor is available - otherwise, handle as normal asset
         ResourceResolver resolver = resource.getResourceResolver();
         Resource editorRsc =
                 resolver.getResource("/libs/dam/cfm/admin/content/fragment-editor");
         return (editorRsc != null);
     }

    private boolean isLiveCopy(Resource resource) {
        ResourceResolver resolver = resource.getResourceResolver();
        LiveRelationshipManager liveRelationshipManager = resolver.adaptTo(LiveRelationshipManager.class);
        return liveRelationshipManager.hasLiveRelationship(resource);
    }

 %>
